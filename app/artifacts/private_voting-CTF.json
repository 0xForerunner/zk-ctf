{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_join",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACJx4CAAIBHgIAAwAKKgIDBCQCAAQAAACDJQAAAlAnAgIAAC0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUtDgIFACIFAgUtDgIFACIFAgUtDgIFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAgcAIgcCBy0OAgcAIgcCBy0OAgcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwAQJwIIBAktCAAJLQoECi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAJiLQIAACcCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAACYi0CAAAtCwYBCyIAAYBEAAckAgAHAAABuicCCAQAPAYIAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAOQLQIAAC0LAwEBIgABgEYABC0LBAMKKgMCAQsiAAGARAACJAIAAgAAAgslAAAEoycCAQALLwoAAQACHAoCBAYcCgQBADAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAACTyoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF2rtV/+xXZjk8BAIBJiUAAAInLQsEBgsiAAaARAAHJAIABwAAAoQnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAADHCMAAAKdLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJwILAQEkAgAKAAACxyUAAAS1LgIAB4ADKACABAQABCUAAATHLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEYABQ4qBgUHJAIABwAAAwclAAAFVS0OCgEtDggCLQ4FAy0OCQQjAAADjycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAOQLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAExy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBGAAMtDggEIwAAA48mJQAAAicuCIBFAAUjAAADoA0iAAWAQwAGJAIABgAABBAjAAADtS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEJiMAAASSLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAExy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAASSASIABYBGAAYtCgYFIwAAA6AqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAATiIwAABO0uAIADgAUjAAAFVC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVALgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUPKAGABQQAAQMAgAYAAoAGIwAABVQmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjRbuMqEIbfxde5YAYYoK+yqqq0TVeRorTKtkc6qvruZwbz46SS0Vmv9ib+MobfDPwwTj6n58Pjx8+H4/nl9dd09+NzerwcT6fjz4fT69P+/fh61ujn5OyDnJ/u/E6veboTvZJ+T3bN85Vlvnqa7igYSIPgALFBRCQiIohIAOQGyQNSg8wAe0TcTexSAyIAbjEijIhHxEdAaRACIDeIHoBHCANMUKeEkwNEQGmQPSA3KAxo3b0jQGpAiBDasPUSg9TAI1Ln2aDOc4UAyA0iGkc0FgIgktC9ZlGhNKhZVMDTC7oXNC6tcXABgIhZhbKBdS8KHBt4D8gNgg6VnUFqEAkQAaWBeAAaJ3RPiGR0z9adFIoHWBs1UnTcgBwgN2DzvTPIDbwm6NmgNLAJ92p+IX2EzwZ2S9MRW68KZrYKtkwzBIAqB1UW0V5BBybm+RlSA8tihtigoE3JMyQnDcw/gQ1SAw6A0sDGU8HGM0OPWBt1XTLPVzDPVzCTzBABaGwmmQG9zOFB5zCbw2eIgNLAvDFDasBozOjuEfHo7tE9oLu5JeiuzLZhK9iRMkNskAggDXIAtDnMtj1naJNZXIsUM0BQP5c6P7rcpT6rQmpQJ6qCzE4o9tAZmjdKdgBECiKlRcg516nHiDotsQKqRp0pgXzv4XuPut5SybKvsTrsmWROgFydrZl6zIbeyPqWSgVUeswsGZ1VBysbjRKIoEyUQNWgMxVQXe5KwXVaYr0dlkGp60l/RrVs+vraTahqD++Xw8GK2lWZ0+L3tr8czu/T3fnjdNpN/+xPH7XRr7f9uV7f9xe9qxkczs96VcGX4+lg9LVberv1rsRkS1C7K0fpEiXeaNC6RtQ1aBKKuSvI7Sh4XSFHq15VQTeLW1MY5yG85JF5LY+wrhGKS00iFJK1UcRBHiFgMnOQsC2P6/XIYS2PgYbEBAmJJXWFeDuKPBiFl4BBBFrGoC9HNxJlIBGlKbBbFsNTvnXVII2UbONWCT3Rl+XgfJsHDaypbxlY0asFZfdNYWBNpkJIhF1Z1/CDDcJI5Nrcv6VQ4Eyt59vy4IxBsL9akd/SSNQXNY0ySX9Xg0Rw4JCkvE0jJQ+NVHibRnGYUyq8rjHaaaEvC8UgqzuNB8siycGiicUvJ8btXuOBv5J0hav51F8+//vMEcJOE/GrZw4PDk8vjCLgJV+Pwt9qyOj4TH06uSy7lco3jcGq6lsj3JW0MK2Wszyazr7jk8h6RRydn/oy0Q1KkVfL0TgVXlKRVQlPo71Gqe81v5QC/Y23pR4J0Zo3vB9tk25xCpxWHeoH5T1zhkV1hVeLsx/Vd5f7e4rWyFWJkUP1f4X+oqLD91teEhx3CSfr9WAkQd3k6rS8TWJ546K8bRS+1zXFbaOI3eJ6gKZtErKcwblsS2SpBJ63JeJDf+fycVMiKWBBUpAtAiXA3iVuSmJ5gy68bQTdU/rj9A9T+C5wr1/3T8fLzV+JXyZ1Oe4fT4f29eXj/HR19/3fN9zBX5Fvl9enw/PH5WBKy/+R+vGD9U8TFrq3X5z6VX927nR/2Veyu5odS7j/ssH8Bw==",
      "brillig_names": [
        "_join"
      ]
    },
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZzbbhw5Dobfpa99oSMl5lUGg4GTOAMDhhN4kgUWQd59SUokyx6U0FZnb9Kf6aq/RYmiJMrIz8vnh48//v7r8fnL138uH/74efn48vj09Pj3X09fP91/f/z6TNafl8D/xFQuH/IdfeLlA9Bnpp8bf+L4LG181nT5gPzZxifMnwHGZwvzs8xPHJ99/tz7+ER6L6a7SwpBoU+IMCFFgsZAXxbprZSTglpKVKgKOKEWBbVAVqDXE39FqxN6noBRgZqR+t0lcwsH1AlRLVEtSS3cjwJZLVmf4aYOUGXuzAFqAX2msYWampGamsPdpQT6VU4MdQI3Y4BaklqSWXBCVkvRZ7gZAlWVeVAzjX6BqoATeDwHqIV7TIB7bAC/1RhwQA1FQS1RLVEtKSu0CTzKA2ACd90A/gpkwAk8ygMofgp1VOVRHtAmtKiglp4U1IL6DHsxAAcAezGAvyISxKzQJnCsDqgTOAAGmAUnFH49MfQJHAkDYAJHwgC18NQawO3JDDiBx2JAm8Dza8C0NI6fAdyeQsDxM0AtHD8FGehLKzW15ajAFvr2xmNRWaf1CfztlV/nyS2AakG21LtLD2wBBrbQUHbuwwFq4UionYEt1IzOcSjAvkNgqBO6WjpbqIUd2ZIY2EINQ565A9TCLkNhYAs1DNllAIY6Iasl61s8cGIpRUEtHH7ceOTw4/Ygh98AtTS2IANZGlu4xwaohXusUeNj4GzVOBUHKEZm4wgexCHcQKgp4Qwaohk1MYZoZLZoNk62PTBxBPcoBErZbNlsnD8mFaOuVLOR2XiNmMQq8r08JXsWYlth6tHIbDyok4pRn5Q4qiaZLSYjVqlM4hsIsY0XsiS+dSFQKmbjRDMJlcS3QV0JzMbZZpD4hkK8KnLvJvYNoxAoodk4YifhpMy+TepK0WyceAaxb5iEWJn7NLNvWITYVmVBj0Zmq8GoGHUl9m2S2VoyYhXZKohvslkQ31C2DbwuB2kCOzewyGI/kVfnwEqyWCmiYfYHsluLW4tbeWQU3Qr+bAuO/m09OoIhyrNZsDiiYg3ZsRly3CmCYQqO1TBHR7cWf7aIAvdurdGxOqKh7GomNsPmrzV/rQfHg9XFhscDuyKE5Ggtgxgci6O/lrKjW7OLZWsvlOhYHa1lUF2s+mvuPIB/RXNrk2c5OqEnRzAcwz2wOHbFFpKjibXo1mhisoBSohUsjmiY3ZrdWtzKqXQibwoUmyFvDBTBsPmzzZ+VXTbvpSm3yldkQflinoV9NLIKomF2a5bmsG99NJI7tY82dEFpg2ztJeRSFOQ2JG5D50mWBzUl7uhJOEnW6EGyrx3kNntO9otBTg7coASC3ZBzpKJbk1uTWyUUJ7q1+LMSfwOrfxvImaXJoSU6VkP0B9CsMQTHgxUNo1uTP5vAMEfHZliSozxbGWtwrI5oKFNnYjeUQJroYsPNgc0Q3Yr2bJL5wocYwmYYo2N1RMMxQgP9teyvZTAsbi0uNjweWBy7IXjLwMWav9b8teYt627tIsZHyITZsSnmEB2rIxrG7GhiObk1uZiMG28hk6zFit1QRmigjBDvgwnRUFomKMfGiZK4eatM2A0lzgZKr/PWlxAMi1ul13kjncYyPFB6faJbwa3gVknRA7tglbN7dJSv4PlWZeJMdKvM2NLkpJ8cm2F1Kx+rYpFigOSuiW6VIJhYDbtbu1vRrWhWORxOlDGeiIbJn5U1vfK4gXQJn7CSnOumlU8KkY9bSc52kc9ZhN0QzSoHO0UwjG6VNgyUfM8nszQWpYHZrdKpfGKjuSBfAYJi5Z5ssgzzKY1QrOxQk/AUL5qE50DJJQNlaZW0LWdCymSEXdo7UNaniWgo82IiD2yWWo00J7NDXcZ4IhhKgp5YDJs/2/0BGdjMzneJvoldEWW7NxENR3sHunW0l7sPZQ5NBENZRCeiYfXXZKUfCK4g4clFFsLqiIYSJROb4XBooL5G9azgeLCiYcyOzVDKcVyFIWyGEjsT0VDyw0DJyhO7IehYEIJhC45uHV5IBW54gVKDy4YS6xPBUJZQrtsQVkc0zNmxGUqWm+ivVRerB6uLgYuBizUXa/5a89e6vyZpm+tDOUraFpypLUmRUJ7Ngs1wfMVAMBwBHgSLIxqiW9GsUupSdGt0awqOB2s3lC3VRDAs/lrx12QGiG9jd881qAzDoYFVHYKRigcerGgoGbFUwa7YQnaUPuNQHpv3iWCY7Cuk/jUxZ8duKF5MtDa06tbqz0qsT3Td5t824iH/+nV30dL8X99fHh64Mn+o1VMF/9v9y8Pz98uH5x9PT3eX/9w//ZCH/vl2/yyf3+9f6LfUuQ/Pn+mTBL88Pj0w/brzt8P5q7R/55kmrxNXMAmsrzTiuUYNXVtA2E0BXrcinSv0yqcPUeg1hzOFtR+8lVE/ejrzo5xrUCWgTQnamMBZK+rCj1K0Mzvtg/b8OI5HL2d+rDRyL+oI12h8ROrrdvSVBu/VhkSJ3grKhldLFC6KDQkqcJxKxIUrVASPU4PmaPbO6K8lFtHZwBSa9wRtRTe78xBab7qTT9vnnWGOUAZsp+2Ii/ikOrmGeKcl9yy64ipAQ7eJRkN8KgELT7g8pK5Q8/NOlFO90MIrYwmnXfobQjT+hhhNt8doWsRoxKrDQnuBdIgO2OzSdtqlaRGldBpVDTp3xtN2pEWU0oFKExgdksK5xiJMC0QdFkqj5VxjEad0TaWrUqP15XRVaguJgtqMVkPYkqjcxilxmPfvkYBo8UUXkKcSy75I3hdwOu3zIkTptkFnfaaDnEnQjcM7NFCbQVcW5VxjlUgDX4eNMA8dXaO+0VglUosuKn2eKywCFKI6Aocs+i+FpR+2LpFL4VRjPU2sL+jGo59Ok9z/vxpc41dfoB7GJNZ3aHRbZFvsexqtWjZvh63T+zTQ0ijNmj0NTz20g4NTjWUahRwtjdZ8Oi5lER/Vkw/dJZ2n83J7Gi3LBJYsjQKcng/KqkepkGbTngplpyls3R1+TqHT7Gl31MUyS1tybQcXwU+HdqmRoq2QVKrc1WimAbinkW3jQsXpuKmRqmnU3XYcdh0t72kU25RSkXtXI1mfltp3NcA02mafFrT4qGGzHTVZfxyn/js1LD4qbMZptXlLu8GypwE+X6D0XQ0bW4DN/vAliqZc20zrdgCjQv357hgW+RSyLQ2QSz1LhbDIp711laDaeDrdU17tCe6dFVpB02jni1xbnp1AszrdCx9nfry+HeiLLdZNXxDMF8R27ktZ1o+C1Y9eZdP8WqOu+iOAnSVLPNVY+UJFeh1bqszXc19WUVqLznyacOeR3hZhil0XBsTDeo1vegMXnvSsvUGVsPP1aamBST3JFCh7Gt1mC2nUTQ33BTNs+mIFj4yLHLbWqLq2lBDirb6QRtrSoJKaVQkChE0NKyKV0Lbb0V0Dbu+PtjcuJdo+m7ZAmxrB1muqqaWbfYklb/piWb2ksDm2KdjYprg5ttGOlKTRbu6PtDjaLtuRo2nkfN6nuDxEBbtaoLuF0/LLKiPTNawdj8PhtuhtTo5hsZFqvuzTXZiLcF3ptciqmORJ6HBXw7HyWiKtDnNoy34KuBBZFHKqTbrjzdX7JFD3lRDrpivJ8jod69KmSLMgS23hzHLZBzs0AJTzbZDE4uk+KB8qdAlPrynCatbl6sXG457uX5Hab79yWV5AoUUZYdrS6NGK+z2mvXb0YNXsfY1ox1u6P6qb7bjuDuq3XEKtC+u1eV1qszZf0s0SV1XH4uoK6ury2Eqj2tx/tR97c9Oa0m/I66s7qCvz+vIodm1eXxXXr8zrS4nr8vrSlWvz+vqYfV1eX0VHsHoS3VzULYnoVfF4KOO8S8L/yCP2vVZk9Mt83GtFtds0ujRuexLg984d9xwJJkE3cnsSxa+M65YjvyO0wLb6EdqeI80vBRumLQn07sS0JdF8LSiwI4BFF0asW/3gf8CEaa8FNr+w1Rtd2BPo3eYn4eE+sl+tgL5HwUN59O1KtrpvSt0KYKn3uNWKZqW8V3/S0a8fTLv3x1dFuHe0wQrWHTHvtcEqcOFwG/ouheQK8VaFvNeGbFEZSr51LI5/kPIOBfvTQDze979Lod0WD7H7prkfCxE1b0kk3JLA6gVqgE2J5BJtT8LK04R7jkS0v9pK4fzPWa6ViG9KMn/Sj/efHl9e/f8dv1js5fH+49PD/PHLj+dPh99+/+83/Y3+/x/fXr5+evj84+WBlfw/AaF//gDKlXRM//PuEvmnWu6gJf6Jf5mpIpV74R/ltxTBUMOfv7hp/wM=",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZnbTis7DIbfpddcJHbiJLwKQqhAWapUFdQFW9pCvPuyEzszRZoIpnDTfONO/nFs59Dp++Zxd//2525/fHr+u7m+ed/cn/aHw/7P3eH5Yfu6fz6y9X3j5MN7buCK29ha0GsI2ubWImibWhv0OlBrI/eL0ubWErU2BW3L5to7hswP8tKjIIO/2oDzBkXBcycfBIoCmEX8qSAONSCF4A3MIk41kO6JgUAhOYOskNkfAAF+KIilhAboJChFICp4s0jckAeIErgG/HSUXugNzCIeYhYghWiWWBSIHxpAgC2BBQOwz9EJkIIoNzBLMEswS01IBbOQ3UNJIZmyBCFy5EMpDaJDA/0qerN4s4BZICmgWdDuCcHAlGNUIGcgQy4CWSGhQVLI3oAUijOw7uK8AEmaGpjF6z0kaYogEA2KQnW+QlKoUa1gNwe7WSqqgVnIussoKtTwViCFbE/P1j3bzcVuLvr05MBAunMZJ6m6GAWyQi0JgVoSFcRVYgjOIBhkhQgGpEB2M1n3ZJZk3WuRcBknSYFArkHIAvIVhzfXaS9Qe1UoCjK/GvAAiauuSGkRF0DxYEAKkqYGQQHtHslOBUlKBSl1AgFSkFw0yAriT4OikM0iKSBkKNTAO1mSlIqRlJBSNpKpqdT7SgIoCEkGlEKnbCRJUCIj6j2oq6RuS10ldZXcVSQrJEutk1JSKkr8YCMpIqVoJDNZSaPrvVSUUjQK3SZrCJFQDV8Sqs9tREp1cVeKrVg81DJuFDoVI+g26DbsNuy20G2x68XJlo1kyVcio9R7pN6jFgbVLU+iITas3jeKOo669CtNtmJUI1kqZSPsNqndJLsgyv6pREaxK0eLH9ZKbmRxxloHjfpzc7f1fGDPB/Z8BOc61b4fH1cbOxbcvZ52OzkVzM4JfHp42Z52x9fN9fHtcLja/Lc9vNWb/r5sj7V93Z74Wx7B7vjILQs+7Q87oY+rqbdb7sp1lb1256J00CXiuYYfaKDMgiYRfOgKPsYvS4RcTCIGWpTAZQlKzgbCSzN2iZLPFMKyQqIukPLkAoWVwfS0FEwaasQukdyiG2kwjoxWESlH3yXo3Ik8igRYOhLvqUsKZTiMglMogJY0huEk57oGYViszUFlFdk/q0QpUyh4ZfqGFylPXpS06AX+wBTBy+eIjxdPEk+/OkvmAU1+ecnJo2D0gfDvobTohx/UaIYMqsEzJixVKAzGkl222Zo5x4sSflzlMNVXwFUzJYVptqVYlkIKePnKA+HipQfixWsP0A8sPuOhwDQUWpYYFSnJr9vmxnz54l+l38jstHL4lBcziwMRJLDM8lFmPmnxXGNUpnxIMz+gTG7wu4RzDbi4OhAvrg4MP1Ad46F8qTqQfrs65vN+tsHF76wdMJv3YXE5xnL5chxGayn60pdjKEshDaMijTDbImExpEM3vrYrBLx4Vwjhl3eFfvSB2bke/acD8WivT6HPtlSmgUD+NJLBaRSjjSPMDsTgPikMllH+gWrFBfyiclljUKBTYUR06xSKzVbycd04oB/gAGcZ+ZZG8j2paTCSiL+rwS+Z+9GcZufAb2mk1BevVGCdRnF9xhdY1hhNEwd9pvG7n1USHqcfKiGvk6Bpvud1XmAvUcZ1XsS+rfECmtZJ0LQG57JuIFNS+V3OOonQj00YVw0kBUtICrRGoPTzdImrBlGc5bPAOg96TZUULxzCZ4Fbvtw+7E9n/2x9iNRpv70/7PTy6e34MPv29f8X+8b+GXs5PT/sHt9OO1Ga/h7jjxs5c/I/QLfyPpUv+XVgQrngV4M3nl+D+1huP8SVfw==",
      "brillig_names": [
        "_slash"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBUJwAABAMnAgMEAicCBAQAHwoAAwAEgFIdAIBTgFMELgiAUgABLgiAUwACJQAAAFIlAAAAyigCAAEEgFQnAgIEADsOAAIAASgAgEMEAAMoAIBEAQAAKACARQQAACgAgEYAAAAoAIBHAQABKACASAQAASgAgEkEAAIoAIBKAAACKACASwQABCgAgEwAACAoAIBNAABAKACATgAASCgAgE8AAGgoAIBQAABwKwCAUQAAAAAAAAAAAwAAAAAAAAAAJiUAAAiDLQgBAwAAAQIBLgyARAADLQgBBAAAAQIBLgyARgAELQgBBQAAAQIBLgyASgAFHgIABgEeAgAHAAoqBgcIJAIACAAAARglAAAIrB4CAAYFHAoGCAQcCggHABwKBwYEJwIHAAMvCgAHAAgtCAEHJwIJBAIACAEJAScDBwQBACIHAgktCgkKLQ4ICicCCQQKLQgACi0KBwsACAAJACUAAAi+LQIAAC0KCwgMKggGByQCAAcAAAGIJQAACOMtCAEGJwIHBAQACAEHAScDBgQBACIGAgctCgcILgyARgAIACIIAgguDIBGAAgAIggCCC4MgEYACCsCAAcAAAAAAAAAAAIAAAAAAAAAAC0IAQgnAgkEBQAIAQkBJwMIBAEAIggCCS0KCQouDIBGAAoAIgoCCi4MgEYACgAiCgIKLgyARgAKACIKAgotDgcKLQgBBwAAAQIBLQ4GBy0IAQYAAAECAS0OCAYtCAEIAAABAgEuDIBFAAgtCAEJAAABAgEuDIBEAAknAgoAEycCCwQMLQgADC0KBw0tCgYOLQoIDy0KCRAtCgoRAAgACwAlAAAI9S0CAAAnAgoECy0IAAstCgcMLQoGDS0KCA4tCgkPLQoBEAAIAAoAJQAACPUtAgAAJwILBAwtCAAMLQoHDS0KBg4tCggPLQoJEAAIAAsAJQAACh4tAgAALQoNCgsiAAqARgAGCyIABoBEAAckAgAHAAAC8SUAAAqSJwIJBAstCAALLQoDDC0KBA0tCgUOLQoKDy0KAhAACAAJACUAAAqkLQIAAC0KDAYtCg0HLQoOCCcCCQAYJwINBA4tCAAOLQoDDy0KBBAtCgURLQoJEgAIAA0AJQAADvQtAgAALQoPCi0KEAstChEMDCoLAg0kAgANAAADciMAAAgmJwILBAwtCAAMLQoDDS0KBA4tCgUPLQoJEC0KAhEACAALACUAAAqkLQIAAC0KDQctCg4ILQoPCi0LAwItCwQJLQsFCycCDAAUJwIOBA8tCAAPLQoCEC0KCREtCgsSLQoMEwAIAA4AJQAAD/otAgAALQoQDS0LDQIAIgICAi0OAg0nAgkEDi0IAA4tCg0PLgiASAAQAAgACQAlAAARDi0CAAAtCg8CLQsNCQAiCQIJLQ4JDScCCwQOLQgADi0KDQ8uCIBJABAACAALACUAABEOLQIAAC0KDwkBIgACgEgADi0LDgsBIgAJgEgADi0LDgIBIgANgEgADi0LDgkcCgkOBBwKDg0AHAoNCQQvCgAMAA0nAhMEFC0IABQtCg0VAAgAEwAlAAARji0CAAAtChUOLQoWDy0KFxAtChgRLQoZEh4CAA0FHAoNFAQcChQTABwKEw0EDCoNEhMkAgATAAAE+CMAAATXFgoQBxwKEAgEHAoHCgQEKggRBwAqBwoILQoIBiMAAAUZFgoOBxwKDggEHAoHCgQEKggPBwAqBwoILQoIBiMAAAUZACoNBggOKg0ICiQCAAoAAAUwJQAAEpEMKg0JBhYKBgkcCgYKABwKCQYABCoKCwkEKgYCCgAqCQoCHAoIBgAcChIIACcCCgQSLQgAEi4IgEoAEy4IgEwAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoGCggcChAGACcCCgQSLQgAEi4IgEoAEy4IgE0AFAAIAAoAJQAAEqMtAgAALQoTCQQqBgkKACoICgYcChEIACcCCgQQLQgAEC4IgEoAES4IgE4AEgAIAAoAJQAAEqMtAgAALQoRCQQqCAkKACoGCggcCg4GACcCCgQQLQgAEC4IgEoAES4IgE8AEgAIAAoAJQAAEqMtAgAALQoRCQQqBgkKACoICgYcCg8IACcCCgQNLQgADS4IgEoADi4IgFAADwAIAAoAJQAAEqMtAgAALQoOCQQqCAkKACoGCggtCAEGJwIJBAQACAEJAScDBgQBACIGAgktCgkKLQ4ICgAiCgIKLQ4CCgAiCgIKLQ4BCi0LBgkAIgkCCS0OCQYtCAEJJwIKBAQACAEKAScDCQQBACIJAgotCgoLLgyARgALACILAgsuDIBGAAsAIgsCCy4MgEYACy0IAQonAgsEBQAIAQsBJwMKBAEAIgoCCy0KCw0uDIBGAA0AIg0CDS4MgEYADQAiDQINLgyARgANACINAg0uDIBRAA0tCAELAAABAgEtDgkLLQgBCQAAAQIBLQ4KCS0IAQoAAAECAS4MgEUACi0IAQ0AAAECAS4MgEQADS0LBg4AIg4CDi0ODgYuCIBFAAcjAAAHbw0iAAeAQwAOJAIADgAACCcjAAAHhCcCBwQOLQgADi0KCw8tCgkQLQoKES0KDRIACAAHACUAAAoeLQIAAC0KDwYtCwMHLQsEAy0LBQQtCAEFJwIJBAUACAEJAScDBQQBACIFAgktCgkKLQ4ICgAiCgIKLQ4CCgAiCgIKLQ4BCgAiCgIKLQ4GCicCAQQNLQgADS0KBw4tCgMPLQoEEC0KDBEtCgUSAAgAAQAlAAAToy0CAAAjAAAIJiYkAgAOAAAINCMAAAhyACIGAg8AKg8HEC0LEA4nAg8EEC0IABAtCgsRLQoJEi0KChMtCg0ULQoOFQAIAA8AJQAACPUtAgAAIwAACHIBIgAHgEgADi0KDgcjAAAHbygAgAQEeAANAAAAgASAAyQAgAMAAAirKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW8GSwLkcVeAzwEAgEmJQAACIMBIgABgEgAAy0LAwIcCgIDBBwKAwEAHAoBAgQtCgIBJioBAAEFz5TqbdQBMuo8BAIBJiUAAAiDLQsEBgsiAAaARAAHJAIABwAACRcnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAJqiMAAAkwLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAACVUlAAAT+C4CAAeAAygAgAQEAAQlAAAUCi4IgAUACgAiCgILACoLBgwtDgUMASIABoBIAAUOKgYFByQCAAcAAAmVJQAAEpEtDgoBLQ4IAi0OBQMtDgkEIwAACh0nAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAUmC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAAFAouCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyASAADLQ4IBCMAAAodJiUAAAiDLQsEBQsiAAWARAAGJAIABgAACkAnAgcEADwGBwEnAgUEBi0IAAYtCgEHLQoCCC0KAwktCgQKAAgABQAlAAAUmC0CAAAtCwEFLQsCBi0LAwctDgUBLQ4GAi0OBwMuDIBHAAQBIgAGgEgAAi0LAgEmKgEAAQUC3G4ngHYSnTwEAgEmJQAACIMnAgoECy0IAAstCgEMLQoCDS0KAw4tCgQPAAgACgAlAAAO9C0CAAAtCgwHLQoNCC0KDgkvCgAEAAonAhAEES0IABEtCgoSAAgAEAAlAAARji0CAAAtChILLQoTDC0KFA0tChUOLQoWDx4CAAoFHAoKEQQcChEQABwKEAoEDCoKDxAkAgAQAAALWCMAAAs3FgoNEBwKDREEHAoQEgQEKhEOEAAqEBIRLQoRBiMAAAt5FgoLEBwKCxEEHAoQEgQEKhEMEAAqEBIRLQoRBiMAAAt5ACoKBhEOKgoREiQCABIAAAuQJQAAEpEMKgoJBhYKBgkcCgYKBBwKCQYEBCoKBwkEKgYIBwAqCQcGHAoRBwAcCg8IACcCCgQSLQgAEi4IgEoAEy4IgEwAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCg0HACcCCgQSLQgAEi4IgEoAEy4IgE0AFAAIAAoAJQAAEqMtAgAALQoTCQQqBwkKACoICgccCg4IACcCCgQSLQgAEi4IgEoAEy4IgE4AFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCgsHACcCCgQSLQgAEi4IgEoAEy4IgE8AFAAIAAoAJQAAEqMtAgAALQoTCQQqBwkKACoICgccCgwIACcCCgQSLQgAEi4IgEoAEy4IgFAAFAAIAAoAJQAAEqMtAgAALQoTCQQqCAkKACoHCggcCgYHABwKBQkALQgBCicCCwQEAAgBCwEnAwoEAQAiCgILLQoLDC0OCAwAIgwCDC0OBwwAIgwCDC0OCQwtCwoLACILAgstDgsKLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDS4MgEYADQAiDQINLgyARgANACINAg0uDIBGAA0tCAEMJwINBAUACAENAScDDAQBACIMAg0tCg0OLgyARgAOACIOAg4uDIBGAA4AIg4CDi4MgEYADgAiDgIOLgyAUQAOLQgBDQAAAQIBLQ4LDS0IAQsAAAECAS0ODAstCAEMAAABAgEuDIBFAAwtCAEOAAABAgEuDIBEAA4tCwoPACIPAg8tDg8KLgiARQAQIwAADdkNIgAQgEMADyQCAA8AAA6YIwAADe4nAg8EEi0IABItCg0TLQoLFC0KDBUtCg4WAAgADwAlAAAKHi0CAAAtChMKLQsBCy0LAgEtCwMCLQgBAycCDAQFAAgBDAEnAwMEAQAiAwIMLQoMDS0OCA0AIg0CDS0OBw0AIg0CDS0OCQ0AIg0CDS0OCg0nAgcEEi0IABItCgsTLQoBFC0KAhUtCgQWLQoDFwAIAAcAJQAAE6MtAgAALQoGAS0KEQMtCgUCJiQCAA8AAA6lIwAADuMAIgoCEgAqEhATLQsTDycCEgQTLQgAEy0KDRQtCgsVLQoMFi0KDhctCg8YAAgAEgAlAAAI9S0CAAAjAAAO4wEiABCASAAPLQoPECMAAA3ZJQAACIMtCwEFLQsCAS0LAwInAgYEBy0IAActCgUILQoBCS0KAgotCgQLAAgABgAlAAAP+i0CAAAtCggDLQsDAQAiAQIBLQ4BAycCAgQELQgABC0KAwUuCIBIAAYACAACACUAABEOLQIAAC0KBQEtCwMCACICAgItDgIDJwIEBAUtCAAFLQoDBi4IgEkABwAIAAQAJQAAEQ4tAgAALQoGAicCBQQGLQgABi0KAQcACAAFACUAAAi+LQIAAC0KBwQnAgUEBi0IAAYtCgIHAAgABQAlAAAIvi0CAAAtCgcBASIAA4BIAAUtCwUCHAoCBQQcCgUDABwKAwIELQoCAy0KAQItCgQBJiUAAAiDLQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC4MgEYACAAiCAIILgyARgAIACIIAgguDIBGAAgtCAEHAAABAgEtDgYHLgiARQAFIwAAEE8NIgAFgEMAASQCAAEAABC/IwAAEGQtCwcBASIAAYBIAAMtCwMCASIAAYBJAAQtCwQDASIAAYBDAAUtCwUELQgBAScCBQQEAAgBBQEnAwEEAQAiAQIFLQoFBi0OAgYAIgYCBi0OAwYAIgYCBi0OBAYmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAEJQAAFAouCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEgAAS0KAQUjAAAQTyUAAAiDASIAAoBIAAMOKgIDBCQCAAQAABEtJQAAEpENKIBDAAMABAsiAASARAADJAIAAwAAEUolAAAVpg0iAAKAQwADJAIAAwAAEV8lAAAT+AAiAQIEACoEAgUtCwUDLQgBAScCAgQCAAgBAgEnAwEEAQAiAQICLQoCBC0OAwQmJQAACIMcCgEDBBwKAwIAAioBAgMsAgABAC1eCYuCuje0O5mhMWEY/SDUL1FmyenxP7XqZaltHgptBCoDAQIcCgIEBBwKBAMAHAoDBAQCKgIDBQQqBQECHAoCBQEcCgUDABwKAwUBAioCAwYsAgACADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCoGAgccCgcIBBwKCAYAHAoGCAQCKgcGCQQqCQEGHAoGBwEcCgcBABwKAQcBAioGAQkEKgkCBhwKBgkEHAoJAgAcCgIGBBwKAQIEBCoCBgEcCgMCBAQqAggDLQoDBi0KAQItCgcBLQoFAy0KBAUtCgYEJioBAAEFRafKcRlB5BU8BAIBJiUAAAiDLQgBBAAAAQIBJwIFAAEtDgUEJwIHBAInAggBAS0IAQYnAgkEIQAIAQkBJwMGBAEAIgYCCScCCgQgQwOqAAIABwAKAAgACScCCwQgLgIACYADLgIAC4AEJQAAFbgnAgIEIScCBwQgLgiASAADIwAAExkMKgMCCCQCAAgAABMwIwAAEystCwQBJi0LBAgEKggICQIqBwMIDioDBwokAgAKAAATUCUAABY4DCoIBwokAgAKAAATYiUAABP4ACIGAgsAKgsIDC0LDAocCgoIAAQqCQEKBCoICgsCKgUICgQqCgkIACoLCAktDgkEASIAA4BIAAgtCggDIwAAExklAAAIgy4IgEUABiMAABOzDSIABoBLAAEkAgABAAATySMAABPIJhwKBgEAACoEAQIAIgUCAwAqAwYHLQsHATAKAAEAAgEiAAaASAABLQoBBiMAABOzKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAUJSMAABQwLgCAA4AFIwAAFJcuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAUgy4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAUUigBgAUEAAEDAIAGAAKABiMAABSXJiUAAAiDLgiARQAFIwAAFKgNIgAFgEMABiQCAAYAABUTIwAAFL0tCwIFLQsFBgAiBgIGLQ4GBS0IAQYnAgcEBQAIAQcBJwMGBAEAIgUCBycCCAQEACIGAgk/DwAHAAktCwEFLQsDBy0LBAgtDgUBLQ4GAi0OBwMtDggEJi0LAwYMKgUGByQCAAcAABUpIwAAFZUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAABQKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAAFZUBIgAFgEgABi0KBgUjAAAUqCoBAAEF9C7lhLv0IdE8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAABY3AwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAFdQmKgEAAQUohpKwR9z9QzwEAgEm",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim"
      ]
    },
    {
      "name": "end_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "end_game"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "claim",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "spend_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "block_number",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Yh8s9sFiHyz2wcJXha8KXxW+KvbBYr4q5qtivirmq2IfLPbBYh8s9sFiHyz2wcJXha8KXxW+KvbBYr4q5qtivirmq2IfLPbBYh8s9sFiHyz2wcJXha8KXxW+KvbBYr4q5qtivirmq2IfLPbBYh8s9sFiHyz2wcJXha8KXxW+KvbBYr4q5qtivirmq2IfLPbBYh8s9sFiHyz2wcJXxXxVzFfFfFXsg4WvCl8Vvirmq8V8tfDVwlfr9Xv/eX18dX89+Jj5fO3r46v768XHcF18tT7z1f1159fBxye/HnwM121cF18tfLWYr1bnup3r4quFrxa+Wp3rdq7LfLWYrxb74AquG1wXXy18tZivVnDd4Lr4auGrha9Wct3kusxXi/lqsQ+u5LrJdfHVwleL+WoNrju4Lr5a+GrhqzW47uC6zFeL+WqxD67JdSfXxVcLXy3mqzW57uS6+Grhq4WvVnHd4rrMV4v5arEPruK6xXXx1cJXi/nq+/72+2uui694f/te+Or7/vb7a67LfLWYrxb74Npcd3Nd5ive374X89X3/e3311yXfXDhq839q/1q/Lrz6+Djk18PPmby6+LXi4/nuvhq46uNr3h/+974auOrja82vtr4auOrja82vtr4ive3b97fvje+2vhq4yve3743vtr4auOrja82vtr4auOrja82vuL97Zv3t++Nrza+2viK97fvja/2x1f9/Hry69/ndJvng5vng5vng5vng5vng5vng5vng5vng5vng5vng3tw3cF1J9edXHdy3cl1J9edXHdy3cl1J9edXLe4bnHd4rrFdYvrFtctrltct7hucd3FddkHN/vgZh/k/e2b97dv3t++eX/75v3te+OrzT7I+9s372/fvL998/72vbl/xfvbN+9v37y/ffP+9vbiDe7v0AzdEN/v73d4Lv4OwzANZVgGCZoETYImwa+93iENwzANZVh8Cb/34H/C7034d2iGbgiDBF2CLkGX4Fdm72ANwhqENQhrEHYh7ELYhbALYRfCLoQEKUFKkBKkXUhrkNYgrUFag7QLaReGXRh2YdiFYReGBEOCIcGQYNiFYQ2mNZjWYFqDaRemXZh2YdqFaRemXZgSlAQlQUlQdqGsQVmDsgZlDcoulF1YdmHZhWUXll1YEiwJlgRLgmUXljXY1mBbg20Ntl3YdmHbhW0Xtl3YdkEnNp3YdGLTibyP/h3SMAzTUAa60F50gbfTv0MzdEMYJNCJTSc2ncjb6t/BGnRr0K1BtwadLrROF3h3/TtMQxmWQQKd2HRi04m8y/4drEFYg7AGYQ3CLoRdSLuQdiHtQtoFndh0YtOJTSfypvt3sAbDGgxrMKzBsAvDLgy7MOzCsAvDLujEphObTmw6kffgv4M1mNZgWoNpDaZdmHah7ELZhbILZRd0YtOJTSc2nchb8t/BGixrsKzBsgbLLiy7sOzCsgvLLiy7oBObTmw6selE3qH/DtZgW4NtDbY12HZh0wXeqP8OzdANYYCg68SuE7tO5A3770ANunNid07szonfd+23G+gC79t/h2kowzJIoBO7Tuw6kffvv4M1cE7szondOfH7Jv77JXS7EHYh7ELYhbALOrHrxK4Tu07k7fzvYA2cE7tzYndO/L6n/34JaRfSLqRdSLuQdkEndp3YdWLXiby7/x2sgXNid07szonft/jfL2HYhWkXpl2YdmHaBZ3YdWLXiV0n8mb/d7AGzondObE7J37f8X+/hLILZRfKLpRdKLugE7tO7Dqx60Te+/8O1sA5sTsndufE7wGA+yUsu7DtwrYL2y5su6ATu07sOrHrRI4CvAM1COfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiaETQyeGTgx353BODOfEcE4M58Rwdw5353B3DnfncHcOd+fQiakTUyemTkx353ROTOfEdE5M58R0d05353R3TnfndHdOd+fUiemcmM6J6ZyY7s6pE1Mnpk5M58R0TkydmDox+/Oo4B3KcAnGDbcL64TrxHY/wXXiNxyCdj/BdeI3HIJ2P9udE79hGg7B+6dwv8MyHIL3v/X3E64Tv6EZDkG/oNeJ33AI4uJcJ8bnd6ahDIcgbnnvnPgJd078hkPw/nmB79ANhyDvF3ed+A2HYFyc68T3D3h9hzIswyEY9yu9TvyG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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "storage_read",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\n5iNYa21VdtY3uxBEsskiA7JJ/wR5mH1uGbJH"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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+yuP3l939P6q4xLPdePaW37tvdm+wHO91HO9zHO93HP9red6hef6O8/1957rle71Knr9geRHktUka0h+IvmZ5Jfm627yF+Wtvz+9ofgLf0uuMv8mv1oRtr3lujkthW3q2x6/Ei6/kfxO8kfmmwnqHxtk6H7T6H7X6P5wdd5VFwtWWlD9NohfUYNgUsjfgG+Q/A7Zax1ef4A/chVU8f6QK15t8f5JuPxFspbk78zi/VNTlH9pdGs1ur8DKN4fgMX7J7B4/wIW71pg8f5tafH+mCtebfGqEXIrkloktVPjZKoA1T9mFuVWGl0tja52C/7i/RFYvMpXv3ulinerFrjirdUCV7y1W9hZvKtzxast3joUz7ok9UjqZxZvHU1R1tXo6ml09QMo3tXA4q0DLN66wOKtByze+pYW75pc8WqLtwHFsyHJ1iTbZBZvA01RNtTottbotgmgeNcAi7cBsHgbAot3a2DxbmNp8f6UK15t8W5L8WxE0pikSWbxbqspykYaXWONrkkAxfsTsHi3BRZvI2DxNgYWbxNLi/fnXPFqi7cpxbMZSXOSFpnF21RTlM00uuYaXYsAivdnYPE2BRZvM2DxNgcWbwtLi/eXXPFqi7clxTOfpBVJQWbxttQUZb5G10qjKwigeH8BFm9LYPHmA4u3FbB4C4DFm0qmR/LAiUqrQW6/3H65/XL75fbL7ZfbL7dfbj+T9wunZv9XGqznAS97rod7rl/yXL/ouX7Bc/285/o5z/Uwz/WznutnPNdPe66f8lw/6bl+wnP9uOf6Mc/1o57rRzzXD3uuH/JcP+i5fsBzfb/n+j7P9VDP9b2e63s813d7ru/yXN/pub7Dc/1Tw/XXazzXqz3XP3quf/Bcr/Jcr/Rcf++5/s5zvcJz/a3nernnepnneqnneonnerHnepHneqHn+hvP9QLP9dee6/me66881/M813M913M817M917M81zM91zM819M919M819Ft1l9Xeq4rPNflnuuI5zrsuQ55rqXnWniue3que3iuu3uut/dcd/Ncd/Vcb+e57uK57uy57uS57ui57uC5bu+5LvNcl3quHc91O891W891iee6jee6tee62HNd5Lm+YNv11+d7rs/zXA/xXJ/ruR7suT7Hc3225/osz/WZnuszPNene65P81wP8lyf6rke6Lk+xXM9wHN9sue6v+f6JM91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CqC2uxKo7a4CarurgdruGqC2uxao7a4DarvrgdruBqC2uxGo7W4CarubgdruFqC2uxWo7W4DarvbgdruDqC2uxOo7e4Caru7gdruHqC2uxeo7e4Darv7gdruAaC2exCo7R4CaruHgdruEUu03U1AbfcoUNs9BtR2jwO13RNAbfckUNs9BdR2TwO13TNAbfcsUNs9B9R2zwO13QtAbfciUNu9BNR2LwO13StAbfcqUNu9BtR2rwO13RtAbfcmUNu9BdR2bwO13TtAbfcuUNu9B9R27wO13QdAbfchUNt9BNR2H1ui7W4GartPgNruU6C2+wyo7T4HarsvgNruS6C2+wqo7b4GartvgNruW6C2+w6o7b4HarsfgNruR6C2+wmo7X4GartfgNruV6C2+w2o7X4Hars/gNruT6C2+wuo7f4Gart/gNou0B2n7Rp0R2io/3w17I7RY+yrUXectmsM8FXQdk2626HtbgFqu6bdcdpune44bdesO07bNe+O03Zl3XHarkV3nLZr2R2n7Vp1x2m7dbvjtN163XHarnV3nLZbvztO27XpjtN2bbvjtF277jht1747Ttt16I7Tdh2747Rdp+44bde5O07bdemO03Zdu+O0XbfuOG3XvTtO2/XojtN2PYHarhdQ2/UGarsNgNquHKjtKizRdrcCtd2GQG3XB6jt+gK1XSVQ21UBtV0/oLbrD9R2A4DabiOgttsYqO02AWo7B6jtXKC2CwK1XQio7cJAbRcBarsoUNvFgNouDtR2CaC22xSo7TYDarvNgdpuC6C22xKo7bYCaruBQG23NVDbbQPUdttaou1uA2q77YDabnugttsBqO12BGq7nYDabmegttsFqO12BWq73YDabnegttsDqO32BGq7vYDabm+gttsHqO32BWq7QUBttx9Q2w0GarshQG23P1DbDQVqu2FAbXcAUNsNB2q7EUBtNxKo7Q4EartRQG2XBGq7lCXa7nagtksDtV0GqO2yQG2XA2q70UBtNwao7cYCtd1BQG03DqjtxgO13cFAbTcBqO0mArXdJKC2OwSo7SYDtd2hQG13GFDbHQ7UdkcAtd2RQG13FFDbHQ3UdscAtd2xQG13HFDbTQFqu+OB2u4EoLabCtR2J1qi7e4AaruTgNruZKC2OwWo7U4FarvTgNpuGlDbnQ7UdtOB2m4GUNvNBGq7WUBt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",
      "debug_symbols": "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8ev/8X/8n//v//v/8//6P/4f/9//8//6f/1/nv/HJuOp/vh/Nb2UXcovFefT/6HyUjVo/ChPP8Yz4tFEvV2qD/WoUpdLDY/nElu3S/mlhseTSn14PJcuer2VHJdqJ/keql9KLjU8nrgRu5Rfang87wnJS9Vb6fB4bsjo06M/1yC0X0qGepRU9VJPj7EaoX6puNTToz8fqVpvZcdQj3g2PJ4jchsez6U1k0vppexSfqnh8ZyNWV6q3sqPS7VL9UvJpfRSdim/1OXhl4dfHnF5xOURw+OJrJBLDY/nmCPsUsPj+dyO4fEcwsfweH6uMobHE4t5vHGc7VLD43mNUi41POoRL+1STw95rmBkDPX8u7xUvVUdl2pDPTyqX0oupZd6esjzZL3ySw2P515LDY/nwlLVWz1mKe8L95ikTHna9KeUKYfR86y7x3TmKfv422E1uuIRU+aUw23EbceUo0465HB78q6NXi/PPtdGt39Jm9KnHG7PK9lG13/J4fbM2mqj849ckTZ6vzyPBmij+7/kcHsemtcGAF5yuD17XRsIeMnh9rymbUDgJeuSAwMv2absU8qUOqVN6VNONzndng0ldUk9pmxT9illSp3SpvQpn24jgaQNMLzk002fq19toOEl25R9yGf7Djq8pA45cG1T+pTDbVz5gYiXrEv66fa8H7xN2accbs8xaxug0CfW2yDFS/qUw+25xtQGLNTH/60uOXAxlrza4MVLDrfno6ENYui4jQYyXtKm9CljypyyLjnA8ZJtyj7ldMvpltMtp1tOt5xuOd1qutV0q+lW062mW023mm413Wq61eXWj2PKNmWfUqbUKW1KnzKmzCmnW5tubbq16damW5tu7XR7PvObTznccsicsi45WPKSbco+pUypU9qUPuV069OtTzeZbjLdZLrJdJPpJtNNpptMN5luMt10uul00+mm002nm043nW463XS66XSz6WbTzaabTTebbjbdbLrZdLPpZtPNp5tPN59uPt18uvl08+nm082nm0+3mG4x3WK6xXSL6RbTLaZbTLeYbjHdcrrldMvpltMtp1tOt5xuOd1yuuV0q+lW062mW023mm413Wq61XSr6VaXmxzHlG3KPqVMqVPalD5lTJlTTrc23dp0a9OtTbc23dp0a9NtskQmS2SyRCZLZLJEJktkskQmS2SyRCZLZLJEJktkskQm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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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K49WHq08uDy4PLg8uDy4PLg8uDy4PLg8uDx6efTy6OXRy6OXRy+PXh69PHp59PKQ8pDyiDj3IC7qRVKkRaPIijwp4nwSFZWHloeWh5aHloeWh5aHlscoj1EeozxGeYzyGOUxymOUxyiPUR5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHp4eUbh0ERW1Ii7qRVKkRaPIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqOVRyuPVh6tPFp5tPJo5XHG+eAgK/KkM86HBlFRK+KiXiRFWjSKrMiTenn08ujl0cujl0cvj14evTx6efTykPKQ8pDykPKQ8pDykPKQ8pDykPLQ8tDy0PLQ8tDy0PLQ8tDy0PLQ8hjlMcpjlMcoj1EeozxGeYzyGOUxysPKw8rDysPKw8rDysPKw8rDysPKw8vDy8PLw8vDy8PLw8vDy8PLw9MjiqMuoqJWxEW9SIq0aBRZUXlQeVB5UHlQeVB5UHlQeVB5UHlQebTyaOXRyqOVRyuPVh6tPFp5tPJo5VFxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4j9qv4UG9SIq0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Xy34asFXC75a8NWCrxZ8teCrBV8t+GrBVwu+WvDVgq8WfLXgqwVfLfhqwVcLvlrw1YKvFny1Pr7aJx+u2cmH+36mFre//ZsP1+/3NvIgH+77s11x+9vn/bv34/a3f/PhxvP7r9/+8x/+9ud/+Me//Onffvt///368p/+41/++O9//uu/fL789//61+//+ce//fkvf/nzP//9v/7tr3/80///j7/96e//8tc/vv/fb8/nP38367W1M2v3H3799qL93fsP465f7z+DG68j8X5Fe/56PdrP9yve35Lvp8cvV9j7wPt7Xs+X/dfrP/mH389J/vu+zuqX2/uQf2HvPzXwkufnxO8/cvD6Z+fntM/rf9rPSet1zrqnjJ9T7n69NX8fy59jr3fn+31o6VD/ivOq0qH1K573odb727/8nH/eh97v6DXSMT/vJ3/lOe/+399hP+P32gf49VoPf0p6beH1zwn8PQD+U9Brd+L1ZZ9vt59vfz3Ifi29Pt/+2l2t5+fbX8/c/X55vr3s9WWcb/8Z0Ndu6q/XruLn2197yb9MA/q6hK8v53uC1+7sr9dO7DlB/F9PkCrgVeS9e84FmtcFip/3/PrytSA836GrY/0ah3OsvgMf7zvhe45lv1ad/69r5e/i//D777//4ff/AQ==",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "user_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "user_score"
      ]
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAULQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZhRbuM4DIbv4uc8iBQlUbnKoCjSNh0ECNIikyywKHL3JW1RTmYgIXV2XqrPjPVbpEjK9dfwtn05/3zeHd4/fg3rH1/Dy3G33+9+Pu8/Xjen3cdBrF+D0z+chzWshuyngccBnC9jGtYkI+CwDjqmacRyjXINeqNHA1XwAuQNzBLUomoJBFghCmQBBgOzZLGgzsphAnTOwCxgFqiWXAC9ARfQFU6QChAY2PRggkmny1Ixk0BQEB3vVoN3sYA+fYJQAM2CVEAfOoHOkvh4cgahQDBLMEs0SyQDLqALmyAVYDTQR8jifXYGwUDC4sUdcmTABXRnJzCLhm4Cs3i7Z/RCYfRihGCgj5BAUSADLhDRIBbQBJjALOwMdLrkBmU0kHtIHAy6+AlEmVAAvIFZdPFEClzAF52g+z4CmYXMEswSNJ9lGUGXOkISB0lBV0hRQS16s6YoJYUwJUl0YMAFdIUT5AJIBmbxds+YmQJJU52yAhcYPVVAMJAVBkmt5MkgFyCzqF8TaN1K6FIMBZIz4AIsjwiowAWyWbJOl0RidXCCWADMAmZBs6A+y18uq8HazvPpuN1q17nqQ9KdPjfH7eE0rA/n/X41/LPZn8ebfn1uDuN42hzlV/Fje3iTUQTfd/ut0mU1z3btqSmAzU7BzwLhGwpxVuCmArYVZJuhKEQp/qoQbxV8W4ETmwKzw5bC3V7kJXGI2rgnBXGjpRDbCj5qio8K0ta4KkD0NxKpLSHHTi4SgHl2A/KtBHf8YF8jwQFascy9SGCukYjcUoBOMAEoe3MEAsaWSNcRnB2JTQXA3jJyqOGEORZyaN2fFg7ntIiLEmtOzZixpaA9uZ1Z4Gtm+evMuvUD4sNVCunhMr3bE0ptT7oaIVWNlJsa2NkUimA5TpGorQEPVxp2EjRRrqUWnFskIdVVJTAtkogANUOhLQEPFyv22idmk5BUpWaxYq9/ulTbjrs6Bnz4TaPTd7hmBl8dA38odBporGfydcf4Q6HrR4TqR3JtjW6K11iQvG41U9zj39WQ4886KMRwtScQvqHBVvLyPxYv00ihnq2Jqa3RyVF0YOtAR3MHxIi3Gr29jbVgJTShrdH1JZNpSOW1fcmP+0LuL/syt1Fgik1f7j4ScmzmKXVeQiG76kumq5cF8N/opHUdcuwvbMaED0vc9QJH6X94geslB9dXJ/kMclW0wS+SwLxIIod5W2NcKIGzRFomQX5Ort8ceZLLzevuePMR66Jix93mZb8tl+/nw+vVr6d/P+0X+wj2efx43b6dj1tVmr+EyZ8fUp4rKa8n/fSll1KR4JNegl4yryT/ny66mP8A",
      "brillig_names": [
        "winner"
      ]
    },
    {
      "name": "winner_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAuQtCAEBAAABAgEnAgIEAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFLQgBBCcCBgQCAAgBBgEnAwQEAQAiBAIGLQoGBy0OBQcnAgYEBy0IAActCgQIAAgABgAlAAADDS0CAAAtCggFDCoFAwQkAgAEAAAA2yMAAAKMHgIABAUcCgQGBBwKBgUAHAoFBAQnAgUAAC0IAQYnAgcEBAAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIIAggtDgUIACIIAggtDgUILQgBBQAAAQIBLQ4GBScCBgAYLQoCAyMAAAFBDSIAA4BDAAIkAgACAAAClSMAAAFWLQsFAgEiAAKARAAFLQsFAycCBQQCACoCBQctCwcGASIAAoBDAAgtCwgHLQgBAicCCAQEAAgBCAEnAwIEAQAiAgIILQoICS0OAwkAIgkCCS0OBgkAIgkCCS0OBwktCwIGACIGAgYtDgYCJwIHBAgtCAAILQoCCS4IgEQACgAIAAcAJQAAAzItAgAALQoJBi0LAgcAIgcCBy0OBwInAggECS0IAAktCgIKLQoFCwAIAAgAJQAAAzItAgAALQoKBycCBQQILQgACC0KBgkACAAFACUAAAMNLQIAAC0KCQInAgYECC0IAAgtCgcJAAgABgAlAAADDS0CAAAtCgkFHAoDBwQcCgcGABwKBgMEDCoEAwYWCgYDHAoGBAQcCgMGBAQqBAIDBCoGBQIAKgMCBC0OBAEjAAACjC0LAQItCgIBJhwKAwIAACoGAgcvCgAHAAItCwUHLgIAB4ADKACABAQABCUAAAO5LgiABQAIACIIAgkAKgkDCi0OAgotDggFASIAA4BEAAItCgIDIwAAAUEoAIAEBHgADQAAAIAEgAMkAIADAAADDCoBAAEF96Hzr6Wt1Mo8BAIBJiUAAALkASIAAYBEAAMtCwMCHAoCAwQcCgMBABwKAQIELQoCASYlAAAC5AEiAAKARAADDioCAwQkAgAEAAADUSUAAARHDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAA3AlAAAEWQ0iAAKAQwADJwIEAQEkAgADAAADiiUAAARrACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAAPUIwAAA98uAIADgAUjAAAERi4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAQyLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAQBKAGABQQAAQMAgAYAAoAGIwAABEYmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjRbispDIbfZa5zgTEY6KtUVZW26VGkKK1ykpVWVd59bbBJcrSM0unuTfnGGf4xtvHQ+ZreNi+nX8/b/fvH7+nh8Wt6OWx3u+2v593H6/q4/diz9Wty8ieX6QFWU8E25DqAQx3T9BB4BD89RBlTG71ee74GuRG9gSh4huANkkI0SzQLmYVIIbFTgALRoChkNMgKxSwlNfAOGNhhDzIrM/jAUASKApoF2eJlVggGWSGigVnILGSW5A1IIYNBVCjOwB5RdDo6FUQvs9hnlIj5KMCC6BhiMMgK4kYDs4gbFbIzkFkgkBUkUA3UEhwamEVS3IAUxLEGUQGdgTwCBbJCQAPOBfJygqS7ASmQMzBLAgOzZLunrqJCVqirqCCP4EBF5w1IAZxBMCgK3iw+K0jRIgkkhQAGUSE6g24pCjUXSSAr1FxUIAUpiQZmkZJoIP5kgdKAXDBgS+BUkqyiQW4PJY8GZkGzoFkkF8ALpLrjBIjdCCDAbgTeaCSRD0FAtjgnjmr1ys05KdSirVAaJBcVJM4NusXuEQ8ryJIjO59EpwF7GNmNLOXXwCwyK/CsjGBACrI9G0hYeIFZGkgFaSANzCJ9o4IUUkgCWUHqR6BIl2ggj+CAFwADs3iZXgSCQVFAs6BZglmkgYRyPq8m67TPx8NmI432qvVyQ/5cHzb74/SwP+12q+mv9e5Ub/r9ud7X8bg+8K8cs83+jUcWfN/uNkLn1WW2G09N2ZHOZkxdIH5DQcpUFeJQwY8VuDRBFQhD7Ap0q4BjhZyyKXBC/Ujh3lUQLYpDiabAhTJSoLECkjcF7tu5KwDhjUQaS/CbtqgE+FIuEuVWIs9Gwl3yCaNYlhkF8uZEIsojBZgJJgC3cVsInwhokRsA3Q1II4XZUHj3b0XxnbLq+eCiwCVlVQJ2hTwsK2nf47oC7HWF13VFtxr04z0K6ceb9O6VhDReyaxGTF0jlaGGn0lKILC0BgphrAE/3md+pnGmUHp1RecWSfDe6hI+LZK4b5/Nx+Kujebnmicfoi2tCJeUIP6Rkrnu6VJvOi5fSgPjHxozPSP3ysgYxgozfYvA9Z1GY4XZdRD0dSQ31pgt8R6LkNy4aaD/fzX45edtLRSvcgLxGxrZtjwkyMs0Uuxv1pTDQo0STIMrfpnGpW1ADjTUuLsFFhrnZaZKofSDI5QAV37gNzpH94MPCgubT/A/lrjruBLwPziuzB15+J3YE3tdpBEXSfiySKLES1qJFkr4i0RaJtEPPYzLFgL9OA7ejd8H90pcneirxBNfrl+3h5tvZWcRO2zXL7uNXr6f9q9Xvx7//rRf7Fvb5+HjdfN2OmxE6fLBjf88QvErD/gkX9jkMuIKYpZL/j/00fNhiz9gPZ3FmX8A",
      "brillig_names": [
        "winner_score"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000003"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "spend_limit",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        },
        {
          "fields": [
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "tally",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::TallyEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::end_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::end_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "claim",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "spend_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "block_number",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::user_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::user_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_score_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "134": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "219": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "402": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n    use token::Token;\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        claim: PublicImmutable<u32, Context>,\n        spend_limit: PublicImmutable<u128, Context>,\n        challenge_fee: PublicImmutable<u128, Context>,\n        deposit_size: PublicImmutable<u128, Context>,\n        token: PublicImmutable<AztecAddress, Context>,\n\n        pot: PublicMutable<u128, Context>,\n        deposits: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct TallyEvent {\n        address: AztecAddress,\n        tally: u32,\n    }\n\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        claim: u32,\n        spend_limit: u128,\n        challenge_fee: u128,\n        deposit_size: u128,\n        token: AztecAddress,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.claim.initialize(claim);\n        storage.spend_limit.initialize(spend_limit);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.token.initialize(token);\n    }\n\n    #[private]\n    fn join(want_flag: bool, block_number: u32) {\n        let token = storage.token.read();\n        let deposit_size = storage.deposit_size.read();\n        Token::at(token)\n            .transfer_to_public(\n                context.msg_sender(),\n                context.this_address(),\n                deposit_size,\n                0\n            )\n            .call(&mut context);  \n\n        if(want_flag) {\n            let capture_note = CaptureNote::new(context.msg_sender(), block_number);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        } else {\n            let capture_note = CaptureNote::new(context.msg_sender(), 0);\n            let tally_note = TallyNote::new(context.msg_sender(), 0);\n            storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n            storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n                &mut context,\n                context.msg_sender(),\n                context.msg_sender(),\n            ));\n        }\n        CTF::at(context.this_address())\n            ._join(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _join(sender: AztecAddress) {\n        // assert(context.block_number() as u32 < storage.start.read(), \"Game has already started\");\n        storage.deposits.at(sender).write(storage.deposit_size.read());\n    }\n\n    #[public]\n    fn claim() {\n        assert(context.block_number() as u32 > storage.claim.read(), \"Claim period has not started yet\");\n        let mut refund = storage.deposits.at(context.msg_sender()).read();\n        if context.msg_sender() == storage.winner.get_current_value() {\n            refund += storage.pot.read();\n        }\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                refund,\n                0\n            )\n            .call(&mut context);\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn end_game() {\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[public]\n    fn winner_score() -> u32 {\n        let mut winner_score = 0;\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner_score = storage.winner_score.get_current_value();\n        }\n\n        winner_score \n    }\n\n    #[public]\n    fn user_score(address: AztecAddress) -> u32 {\n        let score = storage.final_score.at(address).get_current_value();\n        score\n    }\n\n    #[private]\n    fn submit_score() {\n        let capture_note = storage.capture_note.at(context.msg_sender()).get_note();\n        let mut score  = storage.tally_note.at(context.msg_sender()).get_note().note.tally;\n        if capture_note.note.capture_block != 0 {\n            score += storage.end.read() - capture_note.note.capture_block;\n        }\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game is not over yet\");\n\n        storage.final_score.at(sender).schedule_value_change(score);\n        let (winner_score, _) = storage.winner_score.get_scheduled_value();\n        if(winner_score < score) {\n            storage.winner_score.schedule_value_change(score);\n            storage.winner.schedule_value_change(sender);\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n\n        let event0 = TallyEvent { address: context.msg_sender(), tally: note.note.tally };\n\n        // context.emit_event_in_private_log(\n        //     event0,\n        //     &mut context,\n        //     context.msg_sender(),\n        //     context.msg_sender(),\n        //     PrivateLogContent.CONSTRAINED_ENCRYPTION,\n        // );\n\n\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        assert(context.block_number() as u32 < storage.end.read(), \"Game has ended\");\n        assert(context.block_number() as u32 > storage.start.read(), \"Game has not started\");\n\n        let challenge_fee = storage.challenge_fee.read();\n        Token::at(storage.token.read())\n            .transfer_in_public(\n                context.this_address(),\n                context.msg_sender(),\n                challenge_fee,\n                0\n            )\n            .call(&mut context);\n        storage.pot.write(storage.pot.read() + challenge_fee);\n\n        // Ensure the game is initialized\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[private]\n    fn slash(address: AztecAddress) {\n        // Set their tally back to 0.\n        let slot = storage.tally_note.at(address);\n        let note = TallyNote::new(address, 0);\n        slot.replace(note).emit(encode_and_encrypt_note(\n            &mut context,\n            address,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._slash(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn _slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero() , \"Challenge is no longer open\");\n\n        storage.deposits.at(address).write(0);\n        storage.pot.write(storage.pot.read() + storage.deposit_size.read());\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "61": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "91": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "99": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_utility(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"utility\")\n}\n\npub(crate) comptime fn is_fn_contract_library_method(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"contract_library_method\")\n}\n\npub(crate) comptime fn is_fn_test(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"test\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_tuple().is_some() {\n        let tuple_len = typ.as_tuple().unwrap().len();\n        let mut tuple_quotes: [Quoted] = [];\n        for i in 0..tuple_len {\n            let element_quote = quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name.$i)); };\n            tuple_quotes = tuple_quotes.push_back(element_quote);\n        }\n        tuple_quotes.join(quote {})\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Type does not implement trait\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n"
    }
  }
}
