{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "CTF",
  "functions": [
    {
      "name": "_join",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAARSUAAABiKAIAAQSASCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACJx4CAAIBHgIAAwAKKgIDBCQCAAQAAACDJQAAAlAnAgIAAC0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUtDgIFACIFAgUtDgIFACIFAgUtDgIFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAgcAIgcCBy0OAgcAIgcCBy0OAgcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwAQJwIIBAktCAAJLQoECi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAJiLQIAACcCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAACYi0CAAAtCwYBCyIAAYBEAAckAgAHAAABuicCCAQAPAYIAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAOQLQIAAC0LAwEBIgABgEYABC0LBAMKKgMCAQsiAAGARAACJAIAAgAAAgslAAAEoycCAQALLwoAAQACHAoCBAYcCgQBADAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAACTyoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF2rtV/+xXZjk8BAIBJiUAAAInLQsEBgsiAAaARAAHJAIABwAAAoQnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAADHCMAAAKdLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJwILAQEkAgAKAAACxyUAAAS1LgIAB4ADKACABAQABCUAAATHLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEYABQ4qBgUHJAIABwAAAwclAAAFVS0OCgEtDggCLQ4FAy0OCQQjAAADjycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAOQLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAExy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBGAAMtDggEIwAAA48mJQAAAicuCIBFAAUjAAADoA0iAAWAQwAGJAIABgAABBAjAAADtS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEJiMAAASSLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAExy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAASSASIABYBGAAYtCgYFIwAAA6AqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAATiIwAABO0uAIADgAUjAAAFVC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVALgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUPKAGABQQAAQMAgAYAAoAGIwAABVQmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjRbuMqEIbfxde5YAYYoK+yqqq0TVeRorTKtkc6qvruZwbz46SS0Vmv9ib+MobfDDMw2J/T8+Hx4+fD8fzy+mu6+/E5PV6Op9Px58Pp9Wn/fnw9q/VzcvZDzk93fqfXPN2JXkn/J7vm+coyXz1NdxQMpEFwgNggwhJhEVgkAHKD5AGpQWaAPSLuJnapAREAtxgWhsXD4iOgNAgBkBtED8AjhAEmqFPCyQEioDTIHpAbFAa07t4RIDUgWAht2HqJQWrgYanzbFDnuUIA5AYRjSMaCwFgSehevahQGlQvKuDpBd0LGpfWOLgAgMVShbKBdS8KHBt4D8gNgg6VnUFqEAkQAaWBeAAaJ3RPsGR0z9adFIoHWBtNpOi4ATlAbsCW984gN/DqoGeD0sAm3GvyC+kjfDawW+qOWLwqWLJVsDDNEACqHFRZRHsFHZhYzs+QGpgXM8QGBW1KniE5aWD5E9ggNeAAKA1sPBVsPDN0i7XRrEuW8xUs5ytYkswQAWhsSTIDelmGB53DbBk+QwSUBpYbM6QGjMaM7h4Wj+4e3QO6W7YEXZXZFmwF21JmiA0SAaRBDoA2h9mW5wxtMotrlmIJEDSfS50fDXepz6qQGtSJqiBzJhR76AwtN0p2AFgKLKVZyDnXqduIOi22AqqJOlMC+d7D9x413lLJvK+2OuyZZHaAXJ2tmbrNht7I+pZKBVS6zVIyOqsOVjYaJRBBmSiBaoLOVEA13JWC67TYejuEQanrSX9GTdn09bWbUNUe3i+HgxW1qzKnxe9tfzmc36e788fptJv+2Z8+aqNfb/tzvb7vL3pXPTicn/Wqgi/H08Hoa7f0dutdiclCULsrR+kSJd5o0LpG1Bg0CcXcFeR2FLyukKNVr6qgi8WtKYz9EF78yLzmR1jXCMWlJhEKydoo4sCPEDCZOUjY5sd1PHJY82OgEYsriIfuEF0h3o4iD0bhJWAQgZYx6OHoRqIMJKI0BXZLMDzl26wauJFSgBu6oy/h4HzrBw1SU08ZiOhVQNl9UxikJlMhOMKurGv4QUC4x+MquX9LoSAztZ5v84MzBsH+KiK/pZGoBzWNPEl/V4NEsOGQpLxNIyUPjVR4m8ay0KjwusZopYUeFopBVlcaD8IiySFFE4tfdozbtcaD/ErSFa7mU998/v+eE3zfc2R1z+HB5umFUQS85OtR+FsNGW2fqU8nl2W1UvmmMYiqnhqRXUkL02o5y6Pp7Cs+iaxXxNH+qYeJnqAUebUcjV3hxRVZlfA0WmuU+lrzSynQd7xN9SjwWm54P1omPcUpcFrNUD8o75kzioFGeLU4+1F9d7mfU7RGrkqMMlS/K/SDig7fbzkkOO4STtbrwUiCepJrpuVtEsuJi/K2Ufhe1xS3jSL2FNcNNG2TkGUPzmWbI0sl8LzNER/6mcvHTY6kgICkIFsESkB6l7jJieUEXXjbCHpO6cvpH7rwXeBe/+6fjpebT4lfJnU57h9Ph/b35eP8dHX3/d833MGnyLfL69Ph+eNyMKXle6T+/GD9aMJC9/bGqX/1tXOn68v+kt1V71jC/ZcN5j8=",
      "brillig_names": [
        "_join"
      ]
    },
    {
      "name": "_respond",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_respond"
      ]
    },
    {
      "name": "_slash",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcEAAEmJQAAAXgnAgIAEScCBAQFLQgABS0KAgYtCgEHAAgABAAlAAABoS0CAAAtCgYDCyIAA4BGAAILIgACgEQABCQCAAQAAACzJQAAAxsvCgADAAILIgACgEYAAwsiAAOARAACJAIAAgAAANYlAAADLScCAgAQJwIEBAUtCAAFLQoCBi0KAQcACAAEACUAAAGhLQIAAC0KBgMLIgADgEYAAQsiAAGARAACJAIAAgAAARslAAADGzAIgEYAAycCAQAPLwoAAQACHAoCBAYcCgQDABwKAwIGJwIDAAsvCgADAAQcCgQFBhwKBQMAHAoDBAYAKgIEAw4qAgMFJAIABQAAAWwlAAADPxwKAwIAMAoAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAGgKgEAAQX3ofOvpa3UyjwEAgEmJQAAAXgtCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLgyARgAFACIFAgUuDIBGAAUAIgUCBS4MgEYABSsCAAQAAAAAAAAAAAIAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHACIHAgctDgQHLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS0OBQMtCAEFAAABAgEuDIBFAAUtCAEGAAABAgEuDIBEAAYnAgcECC0IAAgtCgQJLQoDCi0KBQstCgYMLQoBDQAIAAcAJQAAA1EtAgAAJwIBBActCAAHLQoECC0KAwktCgUKLQoGCy0KAgwACAABACUAAANRLQIAAC0LBgELIgABgEQAAiQCAAIAAALfJwIHBAA8BgcBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAABH8tAgAALQsDAQEiAAGARwADLQsDAi0KAgEmKgEAAQUC3G4ngHYSnTwEAgEmKgEAAQVHcc4LT428GzwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmJQAAAXgtCwQGCyIABoBEAAckAgAHAAADcycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAQLIwAAA4wtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAO2JQAABZIuAgAHgAMoAIAEBAAEJQAABaQuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARwAFDioGBQckAgAHAAAD9iUAAAM/LQ4KAS0OCAItDgUDLQ4JBCMAAAR+JwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAABH8tAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAAWkLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEcAAy0OCAQjAAAEfiYlAAABeC4IgEUABSMAAASPDSIABYBDAAYkAgAGAAAE/yMAAASkLQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAUVIwAABYEtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAAWkLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABYEBIgAFgEcABi0KBgUjAAAEjyoBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABb8jAAAFyi4AgAOABSMAAAYxLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABh0uAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABewoAYAFBAABAwCABgACgAYjAAAGMSY=",
      "debug_symbols": "tZnRbts6DIbfJde9kEiJkvYqwzBkXTYECNIiaw9wMPTdR0oknRawsDrrTfSZsX5LJEUpzu/d98O3559fj+cfD792nz7/3n27HE+n48+vp4f7/dPx4czW37sgHzFyA3fc5tGCXkPSto4WQdsy2qTXiUabuV+Wto6WaLQladt2n2JgqPygKD0aMsS7HYRo0BQid4pJoCmAWWQ8HWRAA0ghRQOzyKAGSPfCQKBQgkFVqDweAAF+KIilpQEYxClNICtEs4jfkCeI4rgB/HSUXhgNzCIjxCpACtksuSkQPzSBAFsSCybgMecgQAqiPMAsySzJLD0gHcxCdg8VhWLK4oTMnk+tDcgBDfSrHM0SzQJmgaKAZkG7JyUDU85ZgYKBTLkJVIWCBkWhRgNSaMHAusvgBUjCNMAsUe8hCVMGgWzQFPrgOxSF7tUOdnOymyWjBpiFrLvMokN3bwdSqPb0at2r3dzs5qZPLwEMpDuncZGsy1mgKvSUEOgp0UGGSgwpGCSDqpDBgBTIbibrXsxSrHtPEk7jIiEQqN0JVUC+YvfWvuwFeq8OTUHW1wCeIHHWNUkt4gRoEQxIQcI0ICmg3SPR6SBB6SCpTiBAChKLAVVBxjOgKVSzSAgIGRoNiEFKklIzkhRSqkayNJW8rwSAkpBEQCk5VSMJghIZkfcgVyluK65SXKW6ikSFpNQGSSWlpsQPNpIkUspGspKV1LsxSkYpZaPkNqkhRELdfUWoP3cQKfXirpRHskToaTwoOTUjcBu4Dd2Gbktuy66XF1s1kpKvREbFexTv0ROD+pYn3hAb9tEPyjqPXvqVFlsz6p5snaoRuk1yt8guiLJ/KpFRduVs/sOeyYPMz9jzYJA/t7rN44EeD/R4pBCcet+Xl7udHQu+Pl0OBzkVXJ0T+PTwuL8czk+7T+fn0+lu99/+9Nxv+vW4P/f2aX/hb3kGh/N3blnwx/F0EHq5W3qH9a6yKqJ259UQwCXya4040UBZBUMixeQKMee/lki1mUROtCqB6xJUgk2ESzO6RKuvFNK6QiEXKHUZAqWNzoy05kyaaEQ5eAyJWMLqMMpkHhUtI0rN0SXo9SDqzBNg4Si8p64ptOk0Gvo8MtCaxtSdFIK7kzCt5uYks5rsn12itcUVXJneMYpSl1G0sjoK/AdLBG9fIzHfvEgifegquXZoieslp86c4RPh30NldRxxkqMVKqgGr5i0lqEwmUsN1VZr5RivSsxKX6QAvlIo4aaVUhIuLs1tzaWAt1ceSDeXHsg31x6gf1B85lOBZSq0LjFLUpJft2MY1+WLf5W+I7JL5eCz52pkcSKCBBZZPspcL1p8rTFLUz6k2TigLcPgdwmvNeDm7EC8OTsw/YPsmE/lr7ID6aOz43rdX21w+T21w7ND9FbLMbbby3Ga1VKMzcsxtDWXplmSZrjaImHVpdNh/N2ukPDmXSGlD94V/OgDV+d6jG8OxLO9viRfbaUtE4H6ZiaT0yhmm0e6OhBDeKMwKaP8A9WSC/hF5brGJEGXxMgYtik0W60U87Z5gB/gAK8i8i6NEj2oZTKTjB+rwS+Z/WhOV+fAd2mU4sWrNNim0YKv+AbrGtMCCLCc7/MmiegbG+8udZsELeu9bhsFeooybhtF9m2NC2jZJkFLDa5t20SWoPK7nG0SyY9NmDdNpCQLSEm0RaD5ebrlTZNoweLZYNsIPKdayTdO4a3AF77c3x8vr/7ZehGpy3H/7XTQyx/P5/urb5/+f7Rv7J+xx8vD/eH78+UgSsvfY/zxWc6c/A/QF3mfypf8OrCgXPCrwc+RX4PH3L68yFD+AA==",
      "brillig_names": [
        "_slash"
      ]
    },
    {
      "name": "_submit_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "score",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_submit_score"
      ]
    },
    {
      "name": "challenge",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "challenge"
      ]
    },
    {
      "name": "claim",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim"
      ]
    },
    {
      "name": "has_flag",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3druxMbmD5LnVdF2L8MBh+lcbAqHZ7GgUUyo1qe4CB0e8+KUrk0t7HGUc7M7+58Vn1+RwuSSlSUgQV+s8//Y9//e//8T//+a9//7//7X//6Z/+23/+6b//469/+9tf/+c//+3f/uUv//7Xf/v747/+55+2/f9IkT/9k/z58Wc5/6znn+38s59/6vnnOP+08895/Fm3888zXj3j1TNePePVM14949UzXj3j1TNeO+O1M14747UzXjvjtTNeO+O1M14747UzXj/j9TNeP+P1M14/4/UzXj/j9TNeP+P1M56e8fSMp2c8PePpGU/PeHrG0zOenvH0jDfOeOOMN85444w3znjjjDfOeOOMN85444xnZzw749kZzx7xyv5nO//s5596/jnOP+388xGvP/6cj3hj/1POP8v5Zz3/bOef/fxTzz/H+aedf07/s2zb+ee+fWWHElADWkAP0IARYAHzBNkCIrJEZInIEpElIktElogsEVkiconIJSKXiFwiconIJSKXiFwiconInjuPg1s8eRwkoATUgBbQAzRgBFhARG4RuUXkFpFbRG4RuUXkFpFbRG4RuUXkHpF7RO4RuUfkHpF7RO4RuUfkHpF7RNaIrBFZI7JGZI3IGpE1ImtE1oisEXlE5BGRR0QeEXlE5BGRR0QeEXlE5BGRLSJbRLaIbBHZIrJFZIvIFpEtIu95J/aAPfEOkIASUANaQA/QgBFgAWfkum0BElAC9ipRdmgBPUADRoAFzBP2HDxAAkpARJaILBFZIvKeg6XvYAHzhD0HD5CAElADWkAP0ICIXCJyicg1Iu85WOYOJaAGtIAeoAEjwALmCXsOHhCRW0RuEblF5BaRW0RuEblF5BaRe0TuEblH5B6Re0TuEblH5B6Re0TuEVkjskZkjcgakTUia0TWiKwRWSOyRuQRkUdEHhF5ROQRkUdEHhF5ROQRkUdEtohsEdkiskVki8gWkS0iW0S2iGwReUbkGZFnRJ4ReUbkGZFnRJ4ReUbkeUZu2xYgASWgBrSAHqABI8ACIrJEZInIEpElIktElogsEVkiskRkicglIpeIXCJyicglIpeIXCJyicglIpeIXCNy5GCLHGyRg23PwSo79AANGAEWME/Yc/AACSgBNSAit4jcInKLyC0it4jcI3KPyD0i94jcI3KPyD0i94jcI3KPyBqRNSJrRNaIrBFZ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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "initialize",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "start",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "end",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "claim",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "spend_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "challenge_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "deposit_size",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize"
      ]
    },
    {
      "name": "join",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "want_flag",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7L3Bji29bqX5LnfsQVASKdKv0oOCu9tdMGDYhSpXT4x6995BiVzKzJtK5d77FNDAP/H5zvV/1lLEFhkREiX959/+73/+P//nf/0v//Jv/8+//4+//eP/8Z9/+z//+7/867/+y3/9L//67//XP/3Hv/z7vz3+1//823X/Hyr9b/9I//D4U+efNv6s1/yT5p9l/lnnn23+yfNPmX9OvTr16tRrU69NvTb12tRrU69NvTb12tRrU69NPZ56PPV46vHU46nHU4+nHk89nno89WTqydSTqSdTT6aeTD2ZejL1ZOrJ1OtTr0+9PvX61OtTr0+9PvX61OtTr089nXo69XTq6dTTqadTT6eeTj2devrQK48/7Zp/0vyzzD/r/LPNPx96fP/50Ov3n33+qfNP8z/Ldc0/af5Z5p91/tnmnzz/lPnn3b5ygwbYBLoCKKAE1IAWwAESEMoUyhTKJZRLKJdQLqFcQrmEcgnlEsollEso11CuoVxDuYZyDWWPHb5BAnqABtgEDyAHCigBNaAFhHIL5RbKLZRbKHMocyhzKHMocyhzKHMocyhzKHMoSyhLKEsoSyhLKEsoSyhLKEsoSyj3UO6h3EO5h3IP5R7KPZR7KPdQ7qGsoayhrKGsoayhrKGsoayhrKGsoWyhbKFsoWyhbKF8xx3pDRLQAzTABtQ7+AZQQAmoAS2AAySgB2jAnSUeXbTeMTiAAkpADWgBHCABPUADQrmEcgnlEsp3DBa+oQVwgAT0AA2wCXcMDqCAEhDKNZRrKNdQvmOw2A0aYBPuGBxAASWgBrQADpCAUG6h3EKZQ5lDmUOZQ5lDmUOZQ5lDmUOZQ1lCWUJZQllCWUJZQllCWUJZQllCuYdyD+Ueyj2Ueyj3UO6h3EO5h3IPZQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlC2ULZQtlm8rtugIooATUgBbAARLQAzQglCmUKZQplCmUKZQplCmUKZQplCmUSyiXUC6hXEK5hHIJ5RLKJZRLKJdQrqFcQ7mGcg3lGso1lGsoRwy2iMEWMdjuGKx0AwWUgBrQAjhAAnqABtgEDmUOZQ5lDmUOZQ5lDmUOZQ5lDmUJZQllCWUJZQllCWUJZQllCWUJ5R7KPZR7KPdQ7qHcQ7mHcg/lHso9lDWUNZQ1lDWUNZQ1lDWUNZQ1lDWULZQtlC2ULZQtlC2ULZQtlC2UbSrzdQVQQAmoAS2AAySgB2hAKFMoUyhTKFMoUyhTKFMoUyhTKFMol1AuoVxCuYRyCeUSyiWUSyiXUC6hXEO5hnIN5RrKNZRrKNdQrqFcQ7mGcsQgRwxyxCBHDHLEIEcMcsQgRwxyxCBHDHLEIEcMcsQgRwxyxCBHDHLEIEcMcsQgRwxyxCBHDHLEIEcMcsQgRwxyxCB7DPINGmATPAYdKKAE1IAWwAESEMo9lHsoayjfMdiuG0pADWgBHCABPUADbMIdgwNC2ULZQtlC+Y7Bdt+EOwYH9AANsAFyx+AACigBNaAFcIAE9AANuJXbA+4YHEABt7LcUANaAAdIQA/QAJtwx+AACgjlEsollEso3zHY7IYeoAE24Y7BARRQAmpAC+CAUK6hXEO5hvIdg3zdQAEloAa0AA6QgB6gATaBQ5lDmUOZQ5lDmUOZQ5lDmUOZQ1lCWUJZQllCWUJZQllCWUJZQllCuYdyD+Ueyj2Ueyj3UO6h3EO5h3IPZQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlC2ULZQtlm8r9ugIooATUgBbAARLQAzQglCmUKZQplCmUKZQplCmUKZQplCmUSyiXUC6hXEK5hHIJ5RLKJZRLKJdQrqFcQ7mGcg3lOwa53MABEtADNMAmeAw6UEAJqAGh3EK5hXIL5RbKLZQ5lDmUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCWUeyj3UO6h3EO5h3IP5R7KPZR7KPdQ1lDWUNZQ1lDWUNZQ1lDWUNZQ1lC2ULZQtlC2ULZQtlC2ULZQtlC2qazXFUABJaAGtAAOkIAeoAGhTKFMoUyhTKFMoUyhTKFMoUyhTKFcQrmEcgnlEsollEsol1AuoVxCuYRyDeUayjWUayhHDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgxqxKBGDGrEoEYMasSgRgyqx+Djtdk8Bh0ooATUgBbAARLQAzQglCmUKZQplD0G5YYWwAES0AM0wCZ4DDpQQAkI5RLKJZRLKJdQLqFcQrmGcg3lGso1lGso11CuoVxDuYZyDeUWyi2UWyi3UG6h3EK5hXIL5RbKLZQ5lDmUOZQ5lDmUOZQ5lDmUOZQ5lCWUJZQllCWUJZQllCWUJZQllCWUeyj3UL5jUK4bakAL4AAJ6AEaYBPuGBxAAaGsoXzHoNQbOEACeoAG2IQ7BgdQQAmoAaFsoWyhbKFsoWxTma7rSqKkklSTWhInSVJP0qT0oPSg9KD0oPSg9KD0oPSg9KD0oPQo6VHSo6RHSY+SHiU9SnqU9CjpUdKjpkdNj5oeNT1qetT0qOlR06OmR02Plh4tPVp6tPRo6dHSo6VHS4+WHi09OD04PTg9OD04PTg9OD04PTg9OD0kPSQ9JD0kPSQ9JD0kPSQ9JD0kPXp69PTo6dHTo6dHT4+eHj09enr09ND00PTQ9ND00PTQ9ND00PTQ9ND0sPSw9LD0sPSw9LD0sPSw9LD0yDinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4p4xzyjinjHPKOKeMc8o4LxnnJeO8ZJyXjPOScV4yzkvGeck4LxnnJeO8ZJyXjPOScV4yzkvGeck4LxnnJeO8ZJyXjPOScV4yzkvGeck4LxnnJeO8ZJyXjPOScV4yzkvGeck4LxnnJeO8ZJyXjPOScV4yzkvGeck4LxnnJeO8ZJyXjPOScV4yzkvGeck49wIhEScL8jgfREklqSa1JE6SpJ6UHpwekh6SHh7n6lSTWhInSVJP0iQL8jgfREnp0dOjp0dPj54ePT16evT00PTQ9ND00PTQ9ND00PTQ9ND00PSw9LD0sPSw9LD0sPSw9LD0sPSw8PCiokmUVJJqUkviJEnqSZqUHpQelB6UHpQelB6UHpQelB6UHpQeJT1KepT0KOlR0qOkR0mPkh4lPUp61PSo6VHTo6ZHTY+aHjU9anrU9Kjp0dKjpUdLj5YeLT1aerT0aOnR0qOlB6cHpwenh8e5ObUkTpKknqRJFuRxPoiSSlJ6SHpIekh6SHpIekh69PTo6dHTo6dHT4+eHj09enr09Ojpoemh6aHpoemh6aHpoemh6aHpoelh6WHpYelh6WHpYelh6WHpYelh4eGFS5MoqSTVpJbESZLUkzQpPSg9KD0oPSg9KD0oPSg9KD0oPSg9SnqU9CjpUdKjpEdJj5IeJT3uOO/VyYLuOJ901zmLU0mqSS2JkySpJ2mSBd1xPik9Wnq09Gjp0dKjpUdLj5YeLT04PTg9OD04PTg9OD04PTg9OD04PSQ9JD0kPSQ9JD0kPSQ9JD0kPSQ9enr09Ojp0dOjp0dPj54ePT16evT00PTQ9ND00PTQ9ND00PTQ9ND00PSw9LD0sPSw9LD0sPSw9LD0sPSw8PDiqEmUVJJqUkviJEnqSZqUHpQelB6UHpQelB6UHpQelB6UHpQeJT1KepT0KOlR0qOkR0mPkh4lPUp61PTIOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc84454xzzjjnjHPOOOeMc844l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOJeMc8k4l4xzyTiXjHPJOO8Z5z3jvGec94zznnHeM857xnnPOO8Z5z3jvGec94zznnHeM857xnnPOO8Z5z3jvGec94zznnHeM857xnnPOPfir25OnCRJPUmTLMjjfBAllaSalB41PWp61PS441wvJwu643wSJZWkmtSSOEmSelJ6tPTg9OD04PTg9OD04PTg9OD04PTg9JD0kPSQ9JD0kPSQ9JD0kPSQ9JD06OnR06OnR0+Pnh49PXp69PTo6dHTQ9ND00PTQ9ND00PTQ9ND00PTQ9PD0sPSw9LD0sPSw9LD0sPSw9LjjnOlf7gX/l5JlFSSalJL4iRJ6kmalB6UHpQelB6UHpQelB6UHpQelB6UHiU9SnqU9CjpUdKjpEdJj5IeJT1KetT0qOlR06OmR02Pmh41PWp61PSo6dHSo6VHS4+WHi09Wnq09Gjp0dKjpQeHh9f8+Dprvy3F6f6nzUmTLMhvwSBKKkk1qSVxkiSlR02Pmh4tPVp6tPRo6dHSo6VHS4+WHi09WnpwenB6cHpwenB6cHpwenB6cHpwekh6SHpIekh6SHpIekh6SHpIekh69PTo6dHTo6dHT4+eHj09enr09Ojp4anOV+l7qhtUkmpSS+IkSepJt4c43R73I88rhCZRUkmqSS2JkySpJ2nS9CheKjSJkkrSw8Mup5bESZLUkzTp4WHF9ye4kiipJNWklsRJktSTNCk9SirfCc6qkyTd/7Y5aZIF3fE7iZJuFXGqSS2JkySpJ2mSBd3xa2NXBkoqSbeH33HfT+DyG+g7Clx+Tb6nwMQOVKAl+t4CE+uN7NiAnOg7AVzqyEABdqACLdF3BZhIwAKsQLh1uHW4dbh1uHW4KdwUbgo3hZvCTeGmcFO4KdwUbgY3g5vBzeBmcDO4GdwMbgY3Szcv5gkkYAFWYAMyUIAdqEC4EdwIbgQ3ghvBjeBGcCO4EdwIbgVuBW4FbgVuBW4Fbr6DB12ODBTg3Ya5U4kCLdF385hIwAKswAZkoADh1uDmUUh3/hib5UwkYAFWYAMyUIAdqEC4+a4fVB0JWIAV2IAMdLfu2IEKtESP+YkELMAKbEAGwq3DrcOtw82j2zffGDvvTGxABgqwAxVoiR7dEwkIN4Obwc3gZnAzuBncLN28hCeQgAVYgQ3IQAF2oALhRnAjuBHcCG4EN4IbwY3gRnAjuBW4FbgVuBW4FbgVuBW4FbgVuBW4VbhVuFW4VbhVuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDHcGG4MN4Ybw43hxnBjuDHcGG4CN4GbwE3gJnATuAncBG4CN4Fbh1uHW4dbh1uHW4dbh1uHW4dbh5vCTeGGXFKQSwpySUEuKcglBbmkIJcU5JKCXFKQSwpyydhtiMyxARkowA7UwLHh0NifaiSQgQVYgQ3IQAF2oAItkeBGcCO4EdwIbgQ3ghvBjeBGcCtwK3ArcCtwK3ArcCtwK3ArcCtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BrcGO4MdwYbgw3hhvDjeHGcGO4MdwEbgI3gZvATeAmcBO4CdwEbgK3DrcOtw63DrcOtw63DrcOtw63DjeFm8JN4aZwU7gp3BRuCjeFm8LN4GZwM7gZ3AxuBjeDm8HN4Gbp1pBLGnJJQy7xEiS6NwYrXoMUyMDbrVTHDlSgJY5NBQcS8HYr7ja2FhzYgO7WHAXYge7WHS1xbDQ40N3MsQBvt3o5NiADb7fql+m5ZKICb7fqbfBcMpGABViBDei6fpmeH6o4uoI33fPDxApsQG+vX5Dnh4kdqEBL9Pxw765SvAwpsABvt+aX6flhIgNvtzb+2w5UoCV6fphIwNuteSfw/DCxARkowA5UoCV6fpjobn6rPT9MrMAGZKAAO1CBluj5YSLcPD8070aeHyY2IAMF2IEKtETPD807jOeHiQVYgQ3IQAF2oAIt0OuWAglYgBXYgAwUYAcqEG4EN4IbwY3gRnAjuBHcCG4EN4JbgVuBW4FbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW4VbhVuFW4VbhVuFW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Mbw43hxnBjuDHcGG4MN4Ybw43hJnATuAncBG4CN4GbwE3gJnATuHW4dbh1uHW4dbh1uHW4dbh1uHW4KdwUbgo3hZvCTeGmcFO4KdwUbsgljFzCyCWMXMLIJYxcwsgljFzCyCWMXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCUycok4ups5VmADMlCAHahASxy5ZCAB4VbgVuBW4FbgVuDmueTeJKd44dREzyUTCViAFXjr3jszFBnbGd9PXhkbGg90heZYgBXYgAwUYAcq0N38BxibHA8koLv5zzK2Oh7YgAx0t+7ouve3tIwtjgcSsABvXfH74JlA/Io9E4jfEs8E4u31TCDeMs8E4saeCQZ6JphIwNtNvGWeCSY2IAPdzX9YD//uzfHw794cD/+7xr14fdRjoNTxtuh+QR7+ExuQgQLsQAW6m7fBw39iyV4ytkMe2IAMRI/ymJ+oQAv0OqlAAhZgBd5u98R76WOb5IECvN10/LcKtESP+YkELMAKbEAGChBuBDeP+XuitnjtVKC7NccCdLfq6Lri2IEKtESPbu2OBCzACvTvgPHPGCjADlSgJeKro4+vjoEFyKP2oXih1GMI3bEDFWiJHvIT/SLMsQArsAEZKMAOVODt5jPMXjYVSMDbzaeCvXKKfAbYS6fIp3a9dipQgB2oQEv0kHdZj/hBLYmTJKkHefj5VK/XLwUSsAArsAEZKMAOVGC6eSVTIAELsAIbkIEC7EAFwo3gRnAjuBHcCG4EN4IbwY3gRnArcCtwK3ArcCtwK3ArcCtwK3ArcKtwq3CrcKtwq3CrcKtwq3CrcKtwa3BrcGtwa3BrcGtwa3BrcGtwa3BjuDHcGG4MN4Ybw43hxnBjuDHcBG4CN4GbwE3gJnATuAncBG4Ctw63DrcOtw63DrcOtw63DrcOtw43hZvCTeGmcFO4KdwUbgo3hRtyiSKXKHKJIpcocokilyhyiSKXKHKJIpcocokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXGHKJIZcYcokhlxhyiSGXWOaSemUuqVfmknplLqlX5pJ6ZS6pV+aSemUuqVfmknplLqnXBTeCG8GN4EZwI7gR3AhuBDeCG8GtwK3ArcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3CrcKtwq3CrcKtwq3CrcGtwa3BrcGtwa3BrcGtwa3BrcGN4cZwY7gx3BhuDDeGG8ON4cZwE7gJ3ARuAjeBm8BN4CZwE7gJ3DrcOtw63DrcOtw63DrcOtw63DrcFG4KN4Wbwk3hpnBTuCncFG4KN4Obwc3gZnAzuBncDG4GN4MbcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZeMusi7hLqOusiBI6QHPizKXVhdvS4ysAIbkIEC9GEvJ02yID+a6S67rl4UGViAbtUcG9Ct/BL8mKaJHahAS/TjmiYSsAArsAHhpnBTuCnc/ACnu/i2jpMLJxKwACuwAX1Yx0mSepIm2aSSp6p5OWS5zPFu6V3kW73wsRA5KtAS/eCmiXdL7+LW6oWPgRXYgAx0t+bYgQp0N7nRD3OaSEB386vwI50muptfkB/rNFGAt1tx0iQL8tOdBlFSSboVi98iP76p+B3wA5zGf+DHqE0kYAHeLS1+gX6c2kQGCrADbzd2siA/WG3QbeX/nR+tNqgmtSROkiQ3GTIKtESP4oneTL/5Hq8TbwX/Tf0gtUEW5PFa/KfxeJ1YgHdDq99Tj9eJt1X12+vxOrED3cvvqcdrdTeP1+oX5vF6F3FUL0cMrMAGZKAAO1CB7uZN93it3qs8Xps33SOzeSP9mLXmjfSD1iZ2oAIt0GsQAwnoYtVRgB2oQEv0UJ1IQP9nzVGBlugxN9H/GTt6/xLHOs4PqjXOcKo1DnGqNU5xqjWOcao1znGqNQ5yqjVOcqo1jnKqNc5yqrWmR02Pmh41PWp61PSo6dHSo6VHS4+WHi09Wnq09PBwa93xviHmVJJqUkviJEnqSZpkQXmkIc40xKGGONUQxxriXEMcbIiTDXG0Ic42xOGGON0QxxvifEMccDiOMWwDLdFjbeItxN5ZPNbuydE6DjRk7zceVez9xiPlnkCs44BC8f/Wn2wTG/C+OPEO6/EzsQMVaIHjwMKJBCxAdyPHBmSgu5njrdvv5ozjCifeut3/W3/qTazABmT8MwF2oALhVuDmETixABuQx3Fa1avqJvUkTbIgD7xBLl4cC7ACBejN83voj7reHAlYgBXYgAwUYAf6zfCW+bNuoEffRHcTxwKsQHfrjgwUYAcq0BI9DCcSsAAr0N3UkYECdDfvSx6OEy3RA3Li7ab+k3pITqzA2039t/BH5EQBduDtpv5jedgO9LCdSEB38x/Aw3ZiA7qbX7EH88QOVKAl+iNyIgEL0N38Ro3TSf0yx9mjd/TwOH10IAEL0DNgdRRgByrQde8L4nH26EACuq44ukJ3VKAljjNGBxKwACuwAb296ijADtTEccaoORZgBTbgnQP8E2qcdDixAxVoif50nEjA+/l4+f31h+FEAXag6xZHS/TzDicSsAArsAEZ6GL+u/kRhxMJWIAC7EAFQqxDrEPMTzb0j8VxtuHEBmSgADtQgZboJx1OdDd2LMA6DiOseeBhzRMPax55WPPMw5qHHtY89bDmsYc1zz2sXmv2eFd0rMAGZKAAO1CBFui1ZoGu2x1dQR37OOGw5lmHdRx26OSnHQ6ipJLkiubYgAwUYAdq4jhu9HL0VzrXHe+mA2+F4tSTNMmC/Bk5iJL8xbE6VmADMlCAPXG8jjZHV2DHNk5+rF4GNkmS7hs6/rUmWdAdapMoqSS5if9E43zRgQzUxHGCqP+G4wzRgRV4N9NvxP2wmyRJPUmTLGic6Os/0TjTd2ABVmADMlCAHahAS1S4Kdw87vyz3au9AhvwdvNPV6/2CvR+4j+Fn/rr38Ne7VWL3zg/+XciAd3NjT0AJ95u/pnrhV/Vvy+88Mu/rLzua5Im2SQv+ppESa5YHO+W+sewl3FVf8fzMq6Jft7vxLul1RX8zN+JFdiADHTd+wK9NKv6x7CXZlX/GPbSrMAGZKAAO1CBluhBOPF289TmBVuBFXi7eRrxgq1AAXbg7eYd0wu2JnpwTqRxHmn1eq1JNekOBL9wj9dBktSTNMmC/NHowenlW4EFWIEC9GbendBLsgJdwX9PD9mJFdjG4WE1zzyseehhzVMPax57WPPcw5oHH9Y8+bDm0Yc1zz6sefhhzdMPax5/WPP8w5oHINY8AbHmEYg1z0CseQhizVMQax6DWPMcxJoHIVbfzaqOaPAInWiJHqHj/nuETizA+5b5l6sXhAX6l5Xff39ETuxABVqgF4RV/yL2grDA282/iL0grPoXsReE1bv8tnpBWKAA3U0dFWiJcWZb1Ti0rWqc2lbH0YmDWhInueLdp728q/qXt5d3Vf8W9vKuwAZk4N1S/7D28q5ABVqiR/NEGmeIVa/j8o/tsT+VNyD2oqq5F1XNvaiql2VV8X/sozYTGSjADlSgJXo4TiRgAcKN4cZwY7j5Od3iP5s/VydaoofuRAIWYIt7ELvPVY3d56oXYlXxX93fbidaoj9lJxKwAO+r8WEDL8QKZOB9NT504YVYgRY/UmwPXzW2h69eeuXjAl55NakluXhxFGAHKtASPWQn3pcyxDxkJ1ZgG7spVo39JqvGfpNVY7/JqrHfZNXYb7Ja7DdZLfabrBb7TVaL/SarxX6T1WK/yWqx32S12G+yWuw3We1KD0oPSg9KD0oPSg9KD3/j9dERr7AKVKDfszucvcIqkIAFWIENyEABdqAC4Vbh5g/n0V5/OE+swAZkoAA7UIGW6A9nH3XxCqvAAqxjG8vqBVaTOEmSepIGeej7iI3XS9X5v94t9cjzeqnADlTg3VIfevF6qUACFmAF3m4+yOL1UoEC7EAFWqKH/EQCupvfOA95H2/xeqnqgyxeLxUowA5UoCX6i/VEAhZgBcJN4aZwU7gp3BRuBjeDm8HN4GZwM7gZ3AxuBjcLt+b1UoEELMAKbEAGCrADFQg3ghvBjeBGcCO4EdwIbgQ3ghvBrcCtwK3ArcCtwK3ArcCtwK3ArcCtwq3CrcKtws0zwz2Y17xeKtDdimMHKtASPTMYOxKwACuwARkowA50N3G0RE8V92Be8yKpwApsQLdQRwF2oAJt5p3mRVKBBCzACmxABgqwJ8YJru2KI1ybF0NNeoiK/yRximu74hjXdo0kMWQ6UIGWOJLEQALeTn5b/LV+UEvyQS+3GqNeAzvwYXW/O7Y8/7Hl+Y8tz39sef5jy/MfW57/2PL8x5bnP7Y8/7Hl+Y8tz39sef5jy/MfW57/2PL8x5bnP7Y8/7Hl+Y8tz39sef5jy/Mfm9c7tXs8tXm9U2AB+jBhcWxABgqwAxVoieUCEtDdvDmlAhvwvixxkqSepEkW5MdHDXLF5ugtZUdv6fgPFGiJ7QJ6S9WxACuwARnobubYgQq0cQxUozgkqlEcEtUoDolq49DHQS2JkySpJ2lSekh6SHpIekh6SHpIekh6SHr4SNs92tm8SqqR/1L9AhKwACuwARkowA5UINwUbgo3hZuPcZP/+D7IPZGBAuxATfRRbfJ+MFZIO0mS/yO/IT5oNtECveQpkIAFWIEN6E00RwF2oA90Xo6W6NE8kYC32z3M2LwSqt0lQc0roQI7UIGue1+mV0K1e/CxeSVUuytwmldCteLt9bgt3jKP2+rGd9wGCrADfVTZW1YssV5AAvrIcnV0C29OdQtvjof3PT7YfN+3Vr05Ht7NL8jDe6CH90QCFmAFNqCPkXsbxiD5QI0+4mVSE310fKJbeHt9fHxiBbrF+G8ZKMAOVKAlygUkYAFWINwEbj6c3vye+Xj6RHfz39jDfKCHefNb7QHN/mt6QE9koABvXfZf0wN6oiV6QE+kSNZeRxVYgQ3IQAF2oCZ6QLP/mvfzOrACG9Cvwn9jHyaf2IEK9KGQ+zK9jiqQgAVYgQ3IQAH63bmj0EuqAglYgBXYgH4V7CjADlSgJXp0+/uZ11c1f1nyAqt2j/41r7AKVKAr3H3Hi6wCfc7AL8jjeGIF3u29x/WaV1oFCrADFWiJHtIT3a04FmAFNiADBejDun77PI7HffA4noi743Hsb1NegxXIQAH6Vfj99TieaIkex+K32uN4YgG6m99qj+OJDHQ3b7rHsfgP4HHc/VZ7HHe/UR7HEwl463a/Dx7HEwXYga7r1+YRO3qJR+zECmxAAfqci6N/dE8koM/w+LX5R/fEBmSgADtQgRbo5VqBdyPvMa3mhVmBDBSgXzw7KtASPUwn+lVUxwKswAZkoAA7UIGW6B/S9yxqa6UC/SrEkYEC7EC/ivHPLNGDdyIBC7ACfdbU7+SYhh4owA5UoCWOyemBBCzACvSrGNiBCrRED17/BPX6rcACrEC/Cv/dxiz1QAF2oAIt0b+eJxLQp+wuRwYKsAN92o4cLdHDdCIBC7ACG5CB7lYcO1CBlugPYfXO5SE9sQArMAodmldqBQqwAxVoiR7zEwlYgF6C4f3MH8LqUegP4YkK9Ku477rXb7W7wKt5/VZgAVZgAzJQgB3obneH8fqt5kNJPEpG/D/wB6sPJXn9VqAl+sv0RFcojgVYgQ3IQAF2oGYbfEBsoA+ITSRgAVYgrmJUdQ0UoF/F/ct7/VYgAQuwzprNxqMOcyADBdiBCrTEUYc5kIC+lMF/bq+4nChAvzsDFehXcfcoL/AKJKBfhV+xP24nNuA9jemDQ14BFtiBCrREHwXzIQ2vAAsswApsQAYKsCf6VLaPcXhVly+QaF7Cxf7S6zVcgQr0lvl/axfQW+b3wQqwAr1lfh+MgQLsQAVaoBdyBbqbORZgBTYgAwXY44q9wot9TMJLvAILsAJvXc8wXuQVKMAOjEU3zbcHm+h1mBMJWIAV2IAMvO/OvYVM8+qvifUCEtCvojpWYAMy8I6AcZm1AxVoiV5PPZGABVgT/Yyg0Rw/JGgiAwXYgQq0RD8qaCIBCxBuAjefnB6X6bPTEztQgZbohwZNdF12bEAGCrADFei63vv8oKCJBCzA283HYbzcK5CBlrp+ItBEAhYgmm5ouh8LNNz8XKCJHahAC2Ov6AqkxHHYh4+ojC2ygg08zvvwt/OxS9blr9Fjm6zgunBbmJ3NWRbuCyvYV6pezdvmi1Kvu46qjZ2xgmVhXf57b7MP3YwtsYJp4bJwXbgtzAsPr+bcF9aFh+/944w9s4Jp4eFbnevCbWFeeLlG7gvrwgaWa2FauCxcF17urSz31mPIBwTHGYMTCViAFdiADBRgByoQbgo3hZvCTeGmcFO4KdwUbgo3Dz1PxePcwYkELMAKbEAGCrADFZhu4wTCiQQswApsQAYKsAMVCDeCG8GN4EZwI7gR3AhuBDeCG8GtwK3ArcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3CrcKtwq3CrcKtwq3CrcGtwa3BrcGtwa3BrcGtwa3BrcGN4cZwY7gx3BhuDDeGG8ON4cZwE7gJ3ARuAjeBm8BN4CZwE7gJ3DrcOtw63DrcOtw63DrcOtw63DrcFG4KN4Wbwk3hpnBTuCncFG7IJYpcosglilyiyCWKXKLIJYpcosglilyiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsgl41jQe8lFG+eC+ufkOBh0oiWOXDKQgAVYgQ3IQAHCTeGmcDO4GdwMbgY3g9vIJd1RgB2oQJvI47jQie5mjgVYgbfbvfiDvQ5N7+Fo9jq0wA5UoCV6LplIwAKswAaEG8GN4EZwI7gVuBW4FbgVuBW4FbgVuBW4FbgVuFW4VbhVuFW4VbhVuFW4VbhVuFW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbgx3BhuDDeGG8ON4cZwY7gx3BhuAjeBm8BN4CZwE7gJ3ARuAjeBW4dbh1uHW4dbh1uHW4dbh1uHW4ebwk3hpnBTuCncFG4KN4Wbwk3hZnAzuBncDG4GN4Obwc3gZnCzdPPqtUACFmAFNiADBdiBCoQbcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcU5JKCXFKQSwpySUEuKcglZeSS4tiB7kaOljhyyUACFmAFNiADBdiBcCO4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW4VbhVuFW4VbhVuDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MdwYbgw3hhvDjeHGcGO4MdwYbgI3gZvATeAmcBO4CdwEbgI3gVuHW4dbh1uHW4dbh1uHW4dbh1uHm8JN4aZwU7gp3BRuCjeFm8JN4WZwM7gZ3AxuBjeDm8HN4GZws3Sr1wUkYAFWYAMyUIAdqEC4IZdU5JKKXFKRSypySUUuqcglFbmkIpdU5JKKXFKRSypySUUuqcglFbmkIpdU5JKKXFJHLuEbRy4ZSMACrMAGZKC7mWMHKtDd7lzt9X3aBhKwACuwARkowA6E28gljiOXDKRsw8glA+HGcGO4Ma6NcW0MN88l478VXJvg2sYYiP+3Y7RDbxyjHQMJWIAV2IAMFGAHKhBuCjeFm8JN4aZwU7gp3BRuCjeFm8HN4GZwM7gZ3AxuBjeDm8HN0q1dF5CABViBDchAAXagAuFGcCO4EdwIbgQ3ghvBjeBGcCO4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW4VbhVuFW4VbhVuDW4jUxQHT0TiGMFNiADBdiBCrREzwQTCQg3hhvDjeHmmeCulmcvIQxUoCWOTDCQgO7WHCuwATVSRRupwnGkioEELMAKdLGBDBTg3fS7jp+9bjDQEj1V3IXz7HWDgQVYgQ3IQAF2oAIt0VMF+8V7qphYgBXYgAwUoLuxowIt0KsJAwlYgBXYgO5mjgLsQAVaoqeKiQQswApsQLgR3AhuBDeCW4FbgVuBW4FbgVuBW4Gbp4q7pJ+9HjHQEj0pTLwV7op99hrDwA5UoCV6+E8kYAFWYAO6W3MUYAcq0BI9/CcS0N26YwU24O3W/TI9/Cd2oAIt0cN/IgHhJnATuPlHxV0TyV6PGNiB7jb+W0v0/DCR8r/1/DCxAhv+WwYK8HZTb6/nh4mW6LGp/lt4bE5swPxcZwwOMAYHGIMDjMEBweCAYHBAMDggGBwQDA4IBgcEA42CgUbBQKNgoFEw0CgYaBQMNAoGGgUDjYKBRsFAo2CgUTDQKBhoFAw0eo2h3hXa7DWGgRXYgAwUYAcq0H+hu1d75WEgAQuwAhuQgQLsQAXCzeP4LtZmrzwMLMAKbEAGChBuDW4ex/cGFOyb1eldws2+W11gAVZgAzJQgB2oQEsUuEl+Go3ixokV6G7myEABdqACLdHjeCIBbzfz39jjeGIDMlCAHahAS/Tn/EQCwk3hpnBTuCncFG4KN4WbZw3zCPD8YP7Den4wv7+eHyYq0AJHneNEAhZgBTYgAwXYgQqEG8GN4EZwI7gR3AhuBDeCm+eHezsD9lLMiZ4fJlbgQ8HuknP2sspABVriHfOBBCzACmxABrpbdexABVpiu4AELMAKbEB3a44C7MD8rO74iO/4iPfSS7vL3tkrLwMrsAEZKMAOVKBfm/9CcgEJWIAV2IAMFGAHKhBuHW4dbh1uHW4dbh1uHW7ddf1G3XFs5D/sHcdGfn/vOA5koAA7UIGWeL+vBxKwAOFmcDO4GdwMbgY3SzcvsAwkYAFWYAO6GzsKsCfSBXQFcWxABgqwAxVoieUCErAA3U0dXcEcLdHjeCIBC7ACG5CBArzbe9eDsxdCBlqix/FEAhZgBTbg7Vb8VnscT+xABVoiX0ACFmAFNiDcGG4MN4Ybw03gJnATuAncBG4CN4Gbx3HxDuNxPNESPWInuoL/3B6bEztQgZaoF5CABViBDehu3qM8jid2oALdzbuGx/FEAhZgBTYgAwXYgbdb9V7icezoxY2BBCzACmxABt5u99Es7MWNgQq0RI/uiQQswApsQAbCjeBGcCO4FbgVuBW4FbgVuBW4FbgVuHl+8FdLL26c6PlhYgW6gjh2oAIt0WN+IgELsAIbkIGue/coLzc0fzR7uWEgAwXYgQq0RI/YiQS8W9a8E3jETmxABgqwAxVoif7k9WE3LzcMLMAKbEAGCrADFWiJCjeFm8JN4aZwU7gp3BRuCjeFm8HN4ObR3bzDeHRPbMA+UbyE0O5xT/ESwsACrMAGZKAAO1CBlugRe+9JIl5CGFiAFehu5shAAXagAi3RI3YiAQvwdrtHQ8VLCAMZKMAOVKAlesROvN3uoUrxEsLACmxABgqwAxVoiR7dE+HW4Nbg1uDW4Nbg1uDW4NbgxnBjuDHcPD+w9yjPDxMZqIke8+z9wWN+YgU2IAMF2IEKtESP+Ymu2x0bkIEC7EAFWqJH90QCFiDcFG4KN4Wbwk3hpnAzuHl0s3daj+6JFdiADBRgByrQAr0A0O7tVMQLAO0e9BUvAAyswAZkoAA7UIGWSDGFKqMAcGIBult1bEAGCrADFWiJngkm+rV1xwKswAZkoAA7UIGW6JlgItwq3CrcKtwq3CrcKtwq3CrcGtwa3BrcPBPcm82IFwAGMlATPbrF+4NH98QKbEAGCrADFWiJ/vQf6M/j7v3Bn8cTK/B2u3e5ES+zCxRgByrQEj1iJxKwACsQFh563Tuih97EAvR/5j3KQ28iAwXYgQq0QK+XCyRgATag/7M76XrhWyAB/Z+xYwU2IAMF2IEKtESPoYkEhIUHw71HjXgF20QPhon+z7pjAVZgAzJQgB2oQEv0YJgIC3++3TvMiJeiBVqiP9/ubWXES9ECC7ACG5CBAuxABVqiwMIfdfd8i3ilWaAAb7F7vkW80izQEv1RN5GABViBDchAAcLNA+eechCvKTP13ueBM7ECG5CBAuxAHw7xaxvDTY5juGkgAQuwAhuQgX53PAI8shy9eizQr4IdC7ACG5CBAuxABVqiB+REuHno3Ttsi9eJ2T3BIV4nFtiBCrRED72JBCxzfF1GndjEBmSgADtQgZZYY+JPRkXYxAaMyTGpWakuNSvVpWalutSsVJealepSs1JdalaqS81KdalZqS61wa3BrcGtwa3BjeHGcGO4MdwYbgw3hhvDjeHGcBO4CdwEbgI3iYk/qcJAAXagAi1xTCANJGBM/MmoKZvYgAwUYAfG5JiMmrKBegEJWIAV2IAMFGAHwk2jSlFGTdlEArqbOVZgAzJQgB2owJiKk1FTds9cyagpm1iAFdiADBRgByrQEgluBDeCG8GN4EZwI7gR3Ma0UnXMTDDqxO7ZKBl1YhMF2IEKtMR6AQlYgBUItwq3CrcKtwq3CrcGtwa3BrcGtwa3BjfPD+Y/rOeHiZromWBiTI5JYwYKsAMVaIlyAQlYgBUYk2PSxgTSQAF2oAItsV9AAhagu/kvPyaQBjIwKlxlFIdNVKC73fHmxWGBBCzACmxABgowJsfEi8MCLdEuIAELsAIbkIEChJvBzdLNi8MCCViAFdiArnvfKKZ8W/GCL5+NEi/4CqzABmSgADtQgZZYLiDcCtwK3ArcCtwK3ArcCtwK3CrcKtwq3MbEFDs2IAM1scXkmHjBV2AFNiADBdiBCrREvoDu5j8Wx+SYeBFXoAItUS4gAQuwAhvQp0i8E4wJpIEdqEBL7BeQgAUY01XiRVyBDBRgByrQEvUCErAA4aZwU7gp3BRuCjeFm8HN4GZwM7gZ3MZkk3eYMdk0MKbixEvGAmNyTLw4LJCBAuxABVoiXUACFqC7qWMDMlCAMTkmXhwWaInlAhKwACuwARnokyyXYwcq0BLrBSRgAVZgTFeJF4cFCrADFWiJ7QISsAArEG4Nbg1uDW4Nbg1uDDeGG8ON4cZwY7iN6SrvUWO6aqAmjompgTE5Jl7wFSjADlSgJfYLSMACrEDX9R6lMTkmXq4VWIENyEABdqACLXFMIHknGBNIAwuwAhuQgQLswJiuEi/tGtivC0jAAqzABmSgADtQgXAjuBHcCG4EN4IbwY3gRnAjuBHcxmQTOxKwABmYk2OjtGtgvYAELMAKbEAGCrAD3U0dLbFdQALm5Ngo7ZrYgAwUYAcqMKfivLQr0KcyLscCrMAGZKAAO1CBOV01SrsmErAAK7ABGSjADlQg3DrcOtw63DrcOtw63DrcOtw63DrcFG5jCsp71JiCGliBAszJsVHaNZGABViBDchAAXZgTsWNIi6fuRpFXBMrsAEZKMAOVGBOjo3SrolwI7gR3AhuBDeCG8GN4EY5OTYKviYSsAArsAEZKMAO9CmS4piTY6M4bCIBC7ACG5CBAuxAX8Pkbv7dPTBXasooDvN5slEcNrECG5CBAuxABeZ01SgOm0jAAqzABmSgADtQgXATuAncBG4CN4GbwE3gJnATuAncOtw8E/ic2igZm1iBAszJsVEcNpGABViBDchAAXZgTsWNci2fXhvlWhMJmJNjo1xrYgMyUIAdqMCcihvlWhMJCIsx71QcLbFcwJwcG3VXEyuwARkowA5UYE7FjbqribAY807NUYE5FTeKrXwabBRbTSzACmxABgqwAxWYU3HGsBjzTuLYgQrMybFRdzWRgAVYgQ3IQAF2YE7FjWKrif7P1FGAHZiTY6OAaqBeQAIWYAU2IAMF2IGw8EedT6+N+qiJDZiTY74dW2AHKjCm4vqopZpIwAKswAZkoOsWR9etN45ppYEELMAKbEAG+nDI5diBCrTEcgEJWIAV6HenOXagAmNyrI/6qIkELMAKbEAGCrADFQg3D7170q2PSqh7yqyPSqiJDBRgByrQEn1ayfzaxmDywAKswAZkoAB74liB5J3AJ5AmFmBMIHVsm9axbVrHtmkd26Z1bJvWsW1ax7ZpHdumdWyb1rFtWse2aR3bpnVsm9axbVrHtmkd26Z1bJvWsW1ax7ZpHdumdWyb1rFtWse2aR3bpnVsm9axbVrHtmkd26b1sW3aiKwxgTSwARkowA5UYEzF9bFtmvf1sW3axAKswAZkoAA7UIGWSHDzCSTv66NqamIFNiADBdiBcCO4+bSSd/uxbdo9V9fHtmkTK7ABGSjADlSgJdYLCLfcnqRTbk/SKbcn6WPbtHsyr49t0yZ2oAItcaxmHEjAAoypuD62TZvIQAF2oAItkS8gAQsQbgw3hhvDjeHGcGO4Cdw8a9wzg31shebJZmyFZn5/RYGW2C8gAQuwAhuQgQKEW4dbh5vCTeGmcFO4KdwUbgo3hZvCbaxQ9B/W88NEAjZgTPz1Ua41MSb++ijXmkjAAqzABmSgAGPir/v2ZoGWSBeQgAVYgQ3IQHdrjh2oQM+e98XP7c0GEjAm/voo+JrYgAwUYAcq0BJrTMX1URw2sQArsAEZKMAOVKAlNrg1uDW4Nbg1uDW4Nbg1uPkn7eU3ivPdaNSJkd9fZqAAO1CBligXkIAFWIFwE7gJ3ARuAjeBW4dbh1uHW4dbh1uHW481eH0Ukk3URH+hnxgTf32UjE0UYAcq0BLtAhKwACvQ3fzHspj466M4bCIBC7ACG5CBAuzAmPjrozhsIF1AAhZgBTYgA2Mqro+SsYkKtMRyAQlYgBXYgAyEW4FbgVuBW4VbhVuFW4VbhVuFW4VbhdtYzciOltguYAXGxF+vrQMVaIl8AQlYgBXYgAyMib9exwrFgQq0RImJv16FgAVYgQ3IQAF2oAJj4q/XfgEJWIAV2IAMFGBMxXUvDgu0RL2ABCzACmxABgoQbgo3hZvBzeBmcDO4GdwMbgY3g5vBbaxmvHtUG6sZBxKwAWPir7dLgZZIF5CABViBDchAAbru3aNaiYm/3goDBdiBCrTEMT08kIAFGBN/vdUGZKAAO1CBltguYEzF9dYKsAIbkIEC7EAFWiJfQLgx3BhuDDeGG8ON4cZwY7gJ3ARuArexmtE7zFjNOJCBmthj4q+P0q6JFdiADBRgByrQEvUCxsRfH6VdEyuwAWPir4/SrokdqEBLtAtIwAKswJj466O0a6IAO1CBFjhKuyYSMKbi+ijtmtiADBRgByrQEukCEhBuBDeCG8GN4EZwI7gR3ArcCtwK3ArcxhQUOzJQgJZYY+Kvj9KuiQ3IQAF2oAItsV1AAsZUXB8FXxMF2IEKtES+gAQswAqEG8ON4cZwY7gx3ARuAjeJib8+isMmNiADBdiBCrTEfgF9+qc4xsRfH8VhExuQgQLsQAVaol7A+1uvuZsWYAXGxF8fxWETBdiBCrREzwQTCRhTcX0Uh01sQAYKsAMVGFNxfZSMTSRgAVZgAzJQgB2oQLgR3AhuBDeC21jNqI4MFKAllpj466M4bGIDMlCAHahAS6wXkBLHdNXlWIENGBN/fZRrTexABVoiX0ACFmAFNiAsxnRVcSzACoyJvz5qtCYKsAMVaIn9AhKwACsQFmO6qjkSsABj4q+Pcq2JDBRgByrQEu0CErAAYTHmee+kO+quJhIwJv76qLua2IAMFGAHKtAS6QISEBZjnlcdLXHM8w6Mib8+CqgmVmADMlCAHahAS6wXEBZjsulyFGAHxsRfH7VUA9sFJGABVmADMlCAHQg3DxyfchhVUz6vN6qmJjYgAwXYgQrMib9RNTWRgAVYgQ3IQAH63bkjYNRHTSRgTvyN+qiJDchAAXagAnPib9RHTSQg3MYKRY8AzYm/sSHWRAXmxN+omppIwALMib9x4uhEBgqwAxVogePE0Yk+yUKODcjAnBzT3A6za26H2TW3w+ya22F2ze0wu+Z2mF1zO8yuuR1m19wOsyvBjeBGcCO4FbgVuBW4FbgVuBW4FbgVuBW4FbhVuFW4VbhVuFW41Zz4G2eLTuxABebE36iamkjAAsyJv3G26EQGCrADFei9786Io2pqIgH92vy/HasZBzYgAwXYgQq0xLGacSABc8phVE1NbEAGCrADFZgTHJorm/o4W9SHOMbZohMrsAEZKMAOVKAljsnogbFepI+zRf3pNM4WndiA/rtdjgLsiZbDxmNLrYkNyEABdqACc5DaMEg9zgv1l8hxXujECsxh41GjNVGAHajAHKQ2DFIbBqnHllo+IjvKtSY2IAMF2IEKzGFjwyC1YZDaMEhtGKQ2DFIbBqkNg9SGQWrDILVhkNowSG0YpDYMUhsGqW0MUrMjAwWYw9GjystHhUeV18QGZKAAO1CBOUhtGKQ2DFLbGKRWxwpsQAbmsPEoDpuoQEvEILVhkNowSG0YpDYMUltuZd0tt7LulltZ91Ec5oPJhkFqwyC1YZDaMEhtGKQ2DFIbBqlHTZknJsMgtWGQ2jBIbRikNgxSGwapDYPUhkFqwyC1YZDaMEhtGKQ2DFIbBqkNg9SGQWrDILVhkNowSG0YpDYMUo+iMx94thyk1isHqXWUl02MYWO9cpBarxyk1isHqfXKQWq9cpBarxyk1isHqfXKQWq9cpBaRyHZnVN1FIfdI8h65SC1XjlIrVcOUuuVg9R65SC1XjlIrVcOUuuVg9Q6SsbuwWS9cpBarxyk1isHqfXKQWq9cpBarxyk1isHqXVsqXUP2eqVg9R65SC1XjlIrVcOUuuVg9R65SC1XjlIrVcOUuuVg9R6MdwYbgw3hhvDjeHGcGO4MdwYbgI3gdsYpPYOk4PUeuUgtY6Ntgb2GDbWKwep9cpBar1ykFqvHKTWKwep9cpBar1ykFqvHKTWKwepdWy01bxH5SC1XjlIrVcOUuvYaKt518hBar1ykFqvHKTWKwep9cpBar1ykFqvHKTWKwepdW605b0kB6n1ykFqvXKQWq8cpNYrB6n1ykFqpRyk1rHR1j1kq5SD1Eo5SK2Ug9RKOUitlIPUSjlIrZSD1Eo5SK2Ug9RKBDeCG8GN4EZwI7gR3AhuBLcCtwK3ArcxSM2ODchATawxbKyUg9RKOUitlIPUSjlIrZSD1Eo5SK2Ug9RKOUitlIPUOrbJumu/dGyTNZGBAuxABVrieF8fSMAChBvDjeHGcGO4MdwYbgI3j24jxwKswAZkoAA7UIGW6JnA/Nf0THBXmunYwGtiBTYgAwXYgQq0RM8E5r+QZ4KJBehu3bEBGSjADlSgJXommPhwe8SqX/KdCpLrwm1hXlgW7gvrwpbsFWXJtHBZuC7cFuaFZeG+sC68+NLiS4svLb40fItzW5gXVnAZOtW5LFwXbgvzwrJwX1gXNnC9Fh467CwL94V1YQO3a2FauCxcF24LL75t8W2Lb1t82+LLiy8vvrz48uLLiy8vvjx8xbkvrAsbWK6FaeGycF24LTx8u7Ms3BfWhQ3cr4Vp4bKw+5L3vd4W5oVl4b6wLmxgvRamhcvCi68uvrr46uKri68uvrr42uJri68tvrb42uI78gl5TI18Mrkn15E3Jg+d6twW5oVl4b6wLmzgkR8m08Jl4eHbnNvCvLAs3BfWhQ1croVp4eHLznXhtjAvLAv3hXVhA498co+2qBeyJZeF68JtYV5YFu4L68IGbotvW3zb4tsW37b4tsW3Lb5t8W2Lb1t8efHlxXfkn3vwR+vIP5Pbwh088kkhZ1q4LFwXbgvzwrJwX1gXNvDIJ8X7/8gbxfvJyBuTh77/viNvTO4LD31xNvDIG5Np4bJwXbgtzAvLwn3hxVcXX1t8bfG1xdcWX1t8bfG1xdcWX1t8Db7tuhamhYdvd64Lt4V5YVm4L+zjsHeXaSNV3ONU2kaqmCwLj39qzrqwgUeqmEwLl4Xrwm1hXlgWXrxGuI82j3CfzAv7v70P3NU2wn2yLmzgEe6TaeGycF24LcwLL14jZO/DbrWNkJ3cFh7/tjrLwn1hXdjAI8Qn08Jl4bpwW3jx6jGVr6PCbWIFxlS+tpxn11HhNrEDFWiJegEJWIAVCAuLqXwdpWoTCzCm8rXlPLuOUrWJAuxABcZUvo5StYkELMAGjKl8HTVnEwkYU/nKOc+uo+ZsIgMF2IEKtMRyAQkIixJT+TpKygbWCxhT+co5z66j0GxiAzJQgB2oQEtsFxAWMzaasy5s4PH48xFTHo+/yWXhunBbmBeWhfvCurCBZfEa6fc+plJlpN/JtLC3R8S5LtwW5oVl4b6wLmzg8Zo3mRZefGnxpcV35OJ7/kll5Ny7dEll5Nn5v4+2mbO37a4nUhmvZJN1YQOPV7LJtHBZ2Nt2lwqpjBw9mRcevsV5+Fbn4ev3eeRojzkZOXpcy8jRk5drHK9bPpQno79N1oUNPPrbZFq4LFwXbgvzwsPXr2v0N/brGv1tsoFH7p48fP3aR+6eXBduC/PCsnBfWMHjs84H+2S8hvlgnoxXLx9qk/Hqxd43xqvXZAOPV6/JdeGh4/d/vEpNHjrex8Yrk/i9Gq9A4vdqvAJN1oVHH77vT58xOJgWLguPWKjObWFe/htZuC+sC1venz5icDItXBbmvA+dcB869YUVfPdnbt60uzsHErAAK7ABGSjADlQg3BhuDDeGG8ON4cZwY3drjq7rN0AuIAEL0HXF0Vvm90ossV9AAvp/6/esW6JeQAK6mzlWYAMy8L4Kj1kvJWIPWS8lCiRgAVbgLeaR65VCA31/JfZ485og9nDzmqBAAd4/lvcfrwkKtES6gAR0XXF0he6oQEssF5CAJRtZKrABGSjADlSgJdYL6Lrq2IAMFKDr3j+LV+mwpwev0glsQAYKsAMVeLfM84hX6QQS0HX9d/MO7s90r8dh8VvNuL+M+8u4v4L7K7i/3u0Hdr8g/7F6BTYgAwXYgX5BQ8wSPQImEtDd/KZ6X/cHu5fFsD+PvSwmUIGW6BEwkYAFeF+FP7i9hCaQge7mN9U6UIHudt9fL6EJJGABVmADMlCA7iaO7nbfBy+LYX/x9LKYQAYK8G7ZXTSkXgATSMACrMAGZKAA75bdJYHqBTCBluiBM5GAblEcG9DF7iDzvY34rkhT39sosAArsAEZKMAO9Eb6TfUYUr+THkMTCViAFdiADBSg6/pd92gxv1H36w37XJaXr7BPNHn5SmAHKvAWM78l/hSZSEC38GvzKJzYgAwUYAcq0N387ngUTiSgu3lH9OfQxAZkoAA7UIHudke3l68EEtDd/KZ6bE5sQAYKsAMV6G6Pn8W8fCWQgA83uaefzIta5J7hMd8zSe4dC8z3TJJ77sO81CWwAxVoN/Yb70ed3Iv2zUtd5HI3KsAKbMDbjbw5dxzLPeBuvpOSkLfsfiwGWuId3YHudjkWYAU2IM+eal4sE9iBCrREj+6JBCzACvSr8DtZO1CBltj8KvxO3uEfWIAV2IAMFGAHauL4brlf2+wa3y2Dx3fLZH8nbv7bje+WyXVhfxdv/puN75bJAr7jqptL3nEVSDd6H7njKrACG5BvdMM7rgI7UIGWaBeQgAVYgQ0It/GZcicuo/GZMpkWLgvXhdvCvLAs3BfWhRff8ZlyJ0Sj8ZkyuSxcF24L88KycF9YFzZwWXzL4lsW3zFscOdiozFscKdSozFsMLksXBce7WRnXlgW7gvrwgYewwaTaeGycF148W2Lb1t82+LbFt+2+I6hBe/MNIYWJt8ReT8BzYtLAgXYgXdEeoLw4pKJdxAGEvCO/9El7ggMbEAGCrADFWiJ/QISEG4dbh1uHW7ddb1DqCt4f1D/Z/5TawMyUIAdqEBLNG+k33cjYAFWYMs2GAMF2IEKtEAvDgkkYAGOoS1x7guPoa3ubOARw5Nb5EAv6Ai8S3n92ec7BgUq0BLLFZnRSz8CM6954UdgAzJQgB2owMyiXvERSEC4VbhVuM1w9abN0BrcF17/GwPP0BpMC5eF68JtYV548eXFlxdfXnxl8ZXFVxZfWXxl8ZXFVxZfWXxl8ZXFty++ffHti29ffPvi2xffvvj2xbcvvn3x1cVXF19dfHXx1cVXF19dfHXx1cVXF19bfG3xtcXXFl9bfG3xtcXXFl9bfA2+s3hjMi1cFq4Lt4V5YVm4L6wLL760+NLiS4svLb60+NLiS4svLb60+NLiWxbfsviWxbcsvmXxLYtvWXzL4lsW37L41sW3Lr518a2Lb1186+JbF9+6+C65ZRZ1DG6Lb1t82+LbFt+2+LbFd8lXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXdclXbclXbclXbclXszjEP+JncchkXlgW7gvrwgae+WowLVwWXnxp8aXFlxZfWnxp8aXFtyy+ZfEti6/nGfLvdq/k6HVgAVZgAzJQgPfbz13OYb6zUeD99nMXcJjvbBTobtWxAN2tOTYgA92NHTvQ3cTREsXd/HcVArqbOlZgA7qb3x4R4O3W/DLvQA683Zpf5h3Ggbdb88u8gziwAm+35ld8R3Dg7db8MnsHuptfpn/7D/Rvfx9Z8BqRwAJ0N79i//afeLuxN9K//Sd2oAIt0b/9JxKwACuwAeFmcDO4Gdws3by0JJCABViBDchAAXagAuFGcCO4EdwIbv61cU9LmVekBAqwAxVoif61MZGABViBcCtwK3ArcCtwK3CrcKtw8++Ke5bMvDil37Nk5sUp/Z4SMi9OmXi/BAQSsAArsAEZKMAOhFuDG8ON4cZwY7gx3BhuDDeGG8ON4SZw8/wg/ht7fphYgQJ0hTuOfb+jQAIWYAU2IAMF2IEKdLc7P/h+R4EELMAKbEAGCrAD3c37g8f8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",
      "brillig_names": [
        "discover_new_messages",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "nothing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAABGJigAgAQEeAANAAAAgASAAyQAgAMAAABuKgEAAQX3ofOvpa3UyjwEAgEm",
      "debug_symbols": "XY7BCoRACIbfxfMcCvayvUpE2GQxIM5gM8ESvfs6sUHsRf391N8DZprKOgZZ4gZdf8CkgTmsI0ePOUSx7nE6uOWYlcha8OC2lVBJMnRSmB3syOUa2hLKlTOq0cYByWzZDi6BqVbnYAJ90H/HHTXgxPSTSxH/oPmTbnJ/nDR6motSvVQZNDW0Fvv25dr3cFa3Lw==",
      "brillig_names": [
        "nothing"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4083309509421719681": {
            "error_kind": "string",
            "string": "Game has ended"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5148122397035838491": {
            "error_kind": "string",
            "string": "Challenge is no longer open"
          },
          "9773529118643883723": {
            "error_kind": "string",
            "string": "Challenge already exists for this address"
          },
          "11711935425328865283": {
            "error_kind": "string",
            "string": "Claim period has not started yet"
          },
          "13553912981750111747": {
            "error_kind": "string",
            "string": "Function _submit_score can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14232976841600469909": {
            "error_kind": "string",
            "string": "Game has not started"
          },
          "14957838019833443050": {
            "error_kind": "string",
            "string": "Game is not over yet"
          },
          "15761285878583354937": {
            "error_kind": "string",
            "string": "Function _join can only be called internally"
          },
          "16111331527743337289": {
            "error_kind": "string",
            "string": "Function _respond can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AAUABCMAABilKQIABAA3ma6ECioBBAUkAgAFAAAYwCMAABpQLQgBBCcCBQQCAAgBBQEnAwQEAQAiBAIFHzCASYBJAAUtCAEFAAABAgEtDgQFLQgBBAAAAQIBLgyARgAEJwIHBAktCAAJLQoFCi0KBAsuCIBQAAwACAAHACUAACH0LQIAAC0KCgYtCAEEAAABAgEuDIBFAAQtCAEFAAABAgEuDIBHAAUtCAEHAAABAgEnAgkAOS0OCQceAgAJAR4CAAoACioJCgskAgALAAAZcSUAADOiJwINBA4tCAAOLQoEDy0KBRAtCgcRLQoDEi4IgFYAEy0KBhQACAANACUAADG/LQIAAC0KDwktChAKLQoRCy0KEgwwCIBHAAwnAg8EEC0IABAtCgQRLQoFEi0KBxMtCggULgiAVwAVLQoGFgAIAA8AJQAAKG4tAgAALQoRAy0KEgwtChMNLQoUDicCBwQPLQgADy0KAxAtCgwRLQoNEi0KDhMuCIBGABQACAAHACUAACrILQIAAC0KEAQtChEFLQoSBgAiAgIILQsIBycCDAQCACoIDAM7DgAHAAMjAAAaUCkCAAMApWsuTAoqAQMEJAIABAAAGmsjAAAaoCcCAwQELQgABAAIAAMAJQAAM7QtAgAAACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAABqgJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCyCARYBIAAIkAgACAAAcbCcCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQUnRkiy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IgAGgE0AASQCAAEAADFNIwAAMUwmHAoGAQAAKgQBAgAiBQIDACoDBgctCwcBMAoAAQACASIABoBJAAEtCgEGIwAAMTcqAQABBTiq1F1RDmCBPAQCASYqAQABBcWFsQcj9QuVPAQCASYlAAAcyS8KAAQABRwKBQYGHAoGBAAcCgQFBi0KBQEmJQAAHMknAgwEDS0IAA0tCgQOLQoGDwAIAAwAJQAANdktAgAALQoOCwsiAAWAVQAECyIAC4BHAAYkAgAEAAAzQyMAADIECyIABYBWAAQkAgAEAAAzGSMAADIZCyIABYBXAAQkAgAEAAAy7yMAADIuCyIABYBYAAQkAgAEAAAyxSMAADJDCyIABYBZAAQkAgAEAAAymyMAADJYCyIABYBaAAQkAgAEAAAycScCDAQAPAYMAQsiAAaARQAEJAIABAAAMoYlAAA21C0KAQctCgIILQoDCS0KCwojAAAzbQsiAAaARQAEJAIABAAAMrAlAAA21C0KAQctCgIILQoDCS0KCwojAAAzbQsiAAaARQAEJAIABAAAMtolAAA21C0KAQctCgIILQoDCS0KCwojAAAzbQsiAAaARQAEJAIABAAAMwQlAAA21C0KAQctCgIILQoDCS0KCwojAAAzbQsiAAaARQAEJAIABAAAMy4lAAA21C0KAQctCgIILQoDCS0KCwojAAAzbQsiAAaARQAEJAIABAAAM1glAAA21C0KAQctCgIILQoDCS0KCwojAAAzbS0KCgQtCgcBLQoIAi0KCQMmKgEAAQWHoozzdrSOyzwEAgEmKgEAAQVHcc4LT428GzwEAgEmKgEAAQXflvKpubFzSTwEAgEmJQAAHMkmAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAADP/LgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAADPOJioBAAEFxWvEWg4QAAI8BAIBJiUAABzJHAoBAgAtCAEBJwIDBAIACAEDAScDAQQBACIBAgMtCgMELQ4CBCYuAYADgAYLAIAGAAKAByQAgAcAADRYIwAANGMuAIADgAUjAAA0yi4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAADS2LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAADSFKAGABQQAAQMAgAYAAoAGIwAANMomJQAAHMkuCIBGAAUjAAA02w0iAAWARAAGJAIABgAANUYjAAA08C0LAgUtCwUGACIGAgYtDgYFLQgBBicCBwQFAAgBBwEnAwYEAQAiBQIHJwIIBAQAIgYCCT8PAAcACS0LAQUtCwMHLQsECC0OBQEtDgYCLQ4HAy0OCAQmLQsDBgwqBQYHJAIABwAANVwjAAA1yC0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAAND0uCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAA1yAEiAAWASQAGLQoGBSMAADTbJQAAHMkrAgADAAAAAAAAAAACAAAAAAAAAAAnAggECS0IAAktCgMKAAgACAAlAAAfxC0CAAAtCgoELQoLBS0KDAYtCg0HLQgBAwAAAQIBLQ4EAy0IAQQAAAECAS0OBQQtCAEFAAABAgEtDgYFLQgBBgAAAQIBLQ4HBicCBwQILQgACC0KAwktCgQKLQoFCy0KBgwtCgENAAgABwAlAAAgVy0CAAAnAgEEBy0IAActCgMILQoECS0KBQotCgYLLQoCDAAIAAEAJQAAIFctAgAAJwICBActCAAHLQoDCC0KBAktCgUKLQoGCwAIAAIAJQAAIYAtAgAALQoIASYqAQABBQLcbieAdhKdPAQCASYqAQABBaKJJzeDCmADPAQCASYlAAAcyQEiAAGASQADLQsDAhwKAgMEHAoDAQAcCgECBC0KAgEmJQAAHMktCAEGJwIHBAQACAEHAScDBgQBACIGAgctCgcILgyARwAIACIIAgguDIBHAAgAIggCCC4MgEcACC0IAQcAAAECAS0OBgcuCIBGAAUjAAA3cg0iAAWARAABJAIAAQAAN+IjAAA3hy0LBwEBIgABgEkAAy0LAwIBIgABgEsABC0LBAMBIgABgEQABS0LBQQtCAEBJwIFBAQACAEFAScDAQQBACIBAgUtCgUGLQ4CBgAiBgIGLQ4DBgAiBgIGLQ4EBiYcCgUBAAAqBAECLwoAAgABLQsHAi4CAAKAAygAgAQEAAQlAAA0PS4IgAUAAwAiAwIGACoGBQgtDgEILQ4DBwEiAAWASQABLQoBBSMAADdyJQAAHMkBIgACgEkAAw4qAgMEJAIABAAAOFAlAAAwFQ0ogEQAAwAECyIABIBFAAMkAgADAAA4bSUAADlDDSIAAoBEAAMkAgADAAA4giUAADQAACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAA5MAMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgSAB4ALAQCAA4AIgAsuBIAGgAsBAIAJAAKACSMAADjNJioBAAEFKIaSsEfc/UM8BAIBJioBAAEF9C7lhLv0IdE8BAIBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "respond",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "challenger",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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+yuP3l939P6q4xLPdePaW37tvdm+wHO91HO9zHO93HP9red6hef6O8/1957rle71Knr9geRHktUka0h+IvmZ5Jfm627yF+Wtvz+9ofgLf0uuMv8mv1oRtr3lujkthW3q2x6/Ei6/kfxO8kfmmwnqHxtk6H7T6H7X6P5wdd5VFwtWWlD9NohfUYNgUsjfgG+Q/A7Zax1ef4A/chVU8f6QK15t8f5JuPxFspbk78zi/VNTlH9pdGs1ur8DKN4fgMX7J7B4/wIW71pg8f5tafH+mCtebfGqEXIrkloktVPjZKoA1T9mFuVWGl0tja52C/7i/RFYvMpXv3ulinerFrjirdUCV7y1W9hZvKtzxast3joUz7ok9UjqZxZvHU1R1tXo6ml09QMo3tXA4q0DLN66wOKtByze+pYW75pc8WqLtwHFsyHJ1iTbZBZvA01RNtTottbotgmgeNcAi7cBsHgbAot3a2DxbmNp8f6UK15t8W5L8WxE0pikSWbxbqspykYaXWONrkkAxfsTsHi3BRZvI2DxNgYWbxNLi/fnXPFqi7cpxbMZSXOSFpnF21RTlM00uuYaXYsAivdnYPE2BRZvM2DxNgcWbwtLi/eXXPFqi7clxTOfpBVJQWbxttQUZb5G10qjKwigeH8BFm9LYPHmA4u3FbB4C4DFm0qmR/LAiUqrQW6/3H65/XL75fbL7ZfbL7dfbj+T9wunZv9XGqznAS97rod7rl/yXL/ouX7Bc/285/o5z/Uwz/WznutnPNdPe66f8lw/6bl+wnP9uOf6Mc/1o57rRzzXD3uuH/JcP+i5fsBzfb/n+j7P9VDP9b2e63s813d7ru/yXN/pub7Dc/1Tw/XXazzXqz3XP3quf/Bcr/Jcr/Rcf++5/s5zvcJz/a3nernnepnneqnneonnerHnepHneqHn+hvP9QLP9dee6/me66881/M813M913M817M917M81zM91zM819M919M819Ft1l9Xeq4rPNflnuuI5zrsuQ55rqXnWniue3que3iuu3uut/dcd/Ncd/Vcb+e57uK57uy57uS57ui57uC5bu+5LvNcl3quHc91O891W891iee6jee6tee62HNd5Lm+YNv11+d7rs/zXA/xXJ/ruR7suT7Hc3225/osz/WZnuszPNene65P81wP8lyf6rke6Lk+xXM9wHN9sue6v+f6JM91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CqC2uxKo7a4CarurgdruGqC2uxao7a4DarvrgdruBqC2uxGo7W4CarubgdruFqC2uxWo7W4DarvbgdruDqC2uxOo7e4Caru7gdruHqC2uxeo7e4Darv7gdruAaC2exCo7R4CaruHgdruEUu03U1AbfcoUNs9BtR2jwO13RNAbfckUNs9BdR2TwO13TNAbfcsUNs9B9R2zwO13QtAbfciUNu9BNR2LwO13StAbfcqUNu9BtR2rwO13RtAbfcmUNu9BdR2bwO13TtAbfcuUNu9B9R27wO13QdAbfchUNt9BNR2H1ui7W4GartPgNruU6C2+wyo7T4HarsvgNruS6C2+wqo7b4GartvgNruW6C2+w6o7b4HarsfgNruR6C2+wmo7X4GartfgNruV6C2+w2o7X4Hars/gNruT6C2+wuo7f4Gart/gNou0B2n7Rp0R2io/3w17I7RY+yrUXectmsM8FXQdk2626HtbgFqu6bdcdpune44bdesO07bNe+O03Zl3XHarkV3nLZr2R2n7Vp1x2m7dbvjtN163XHarnV3nLZbvztO27XpjtN2bbvjtF277jht1747Ttt16I7Tdh2747Rdp+44bde5O07bdemO03Zdu+O0XbfuOG3XvTtO2/XojtN2PYHarhdQ2/UGarsNgNquHKjtKizRdrcCtd2GQG3XB6jt+gK1XSVQ21UBtV0/oLbrD9R2A4DabiOgttsYqO02AWo7B6jtXKC2CwK1XQio7cJAbRcBarsoUNvFgNouDtR2CaC22xSo7TYDarvNgdpuC6C22xKo7bYCaruBQG23NVDbbQPUdttaou1uA2q77YDabnugttsBqO12BGq7nYDabmegttsFqO12BWq73YDabnegttsDqO32BGq7vYDabm+gttsHqO32BWq7QUBttx9Q2w0GarshQG23P1DbDQVqu2FAbXcAUNsNB2q7EUBtNxKo7Q4EartRQG2XBGq7lCXa7nagtksDtV0GqO2yQG2XA2q70UBtNwao7cYCtd1BQG03DqjtxgO13cFAbTcBqO0mArXdJKC2OwSo7SYDtd2hQG13GFDbHQ7UdkcAtd2RQG13FFDbHQ3UdscAtd2xQG13HFDbTQFqu+OB2u4EoLabCtR2J1qi7e4AaruTgNruZKC2OwWo7U4FarvTgNpuGlDbnQ7UdtOB2m4GUNvNBGq7WUBtNxuo7c4Aars5QG13JlDbzQVqu3lAbTcfqO0WALXdWUBttxCo7RYBtd1ioLY7G6jtlgC13TlAbXcuUNstBWq7ZUBtdx5Q2y0X0nYN8n9Bvt07G6Dil83p8BUbx2btA4FWZI3AvO+C8c7lGB+K7+0dZPKmMTh+d+Pil0XGr/vGOF/vbiIzFg3BY3FPAxznxAA7ON8L5PxuhR11+H0NavhynSKOnypwOnaXfjgdu2u/NRjXWnTsbv3WKEe0Onb3NfOl1bF79Fvj3F1Fx+7Zr4h54NGxe/Urak7V0LF79ytyfio6dp9+Rc/1ah27bz/EvvWfr0H9MHsg+9qvH2o/ddzBAF+FtXFIP9z1ut/74a7X/dEPd73uz36463V/9cNdr/u7H+563T/9cNfrAv1x1+sa9Mddr2vYf7V5X+frdY3612EO1fF6XeP+dZqPdbpe16Ruvup0va5pXX3V4XrdOnX3tdrrdc3q42s11+ua98fduwgoR6/834Jvp7jDvR94j2V/4Jo9FLhmDwOu2QcA1+zhwDV7BHDNHglcsw/sh1uzR/XDrdnJfrg1O9UPt2an++HW7Ew/3Jqd7Ydbs3P9cGv26H64NXtMffWrT206FlibHgSsTccBa9PxwNr0YGBtOgFYm04E1qaTgLXpIcDadDKwNj0UWJseBqxNDwfWpkf0s+O63QNAbXckUNsdBdR2RwO13TFAbXcsUNsdB9R2U4Da7nigtjsBqO2mArXdiUBtdxJQ250M1HanALXdqUBtdxpQ200DarvTgdpuOlDbzQBqu5lAbTcLqO1mA7XdGUBtNweo7c4Earu5QG03D6jt5gO13QKgtjvLEm33IFDbLQRqu0VAbbcYqO3OBmq7JUBtdw5Q250L1HZLgdpuGVDbnQfUdsuB2u58oLZbAdR2FwC13YVAbXcRUNtdDNR2lwC13aVAbXcZUNtdDtR2VwC13ZVAbXcVUNtdDdR21wC13bVAbXcdUNtdD9R2NwC13Y2WaLuHgNruJqC2uxmo7W4BartbgdruNqC2ux2o7e4Aars7gdruLqC2uxuo7e4Bart7gdruPqC2ux+o7R4AarsHgdruIaC2exio7R4BartHgdruMaC2exyo7Z4AarsngdruKaC2exqo7Z4BartngdruOaC2ex6o7V6wRNs9DNR2LwK13UtAbfcyUNu9AtR2rwK13WtAbfc6UNu9AdR2bwK13VtAbfc2UNu9A9R27wK13XtAbfc+UNt9ANR2HwK13UdAbfcxUNt9AtR2nwK13WdAbfc5UNt9AdR2XwK13VdAbfc1UNt9A9R23wK13XdAbfe9JdruEaC2+wGo7X4EarufgNruZ6C2+wWo7X4FarvfgNquDPj5txbAz7+1BH7+rRXw82/rAj//th7w82+tgZ9/Wx/4+bc2wM+/ta2fL19t166+vny0Xfv6+6pV23VYE1+1aLuO/XHartMa+tJpu85r7msVbdelGF8ebde1OF81tF23Yn0p2q57f4SG+s9Xj/4YPca+evbHabteAF8Fbde7vx3a7lGgttugP07blffHabuK/jhtt2F/nLbr0x+n7fr2x2m7yv44bVcF1Hb9gNquP1DbDQBqu42A2m5joLbbBKjtHKC2c4HaLgjUdiGgtgsDtV0EqO2iQG0XA2q7OFDbJYDablOgttsMqO02B2q7LYDabkugttsKqO0GWqLtHgNqu62B2m4boLbbFqjttgNqu+2B2m4HoLbbEajtdgJqu52B2m4XoLbbFajtdgNqu92B2m4PoLbbE6jt9gJqu72B2m4foLbbF6jtBgG13X5AbTcYqO2GALXd/kBtNxSo7YYBtd0BQG03HKjtRgC13UigtjvQEm33OFDbjQJquyRQ26WA2i4N1HYZoLbLArVdDqjtRgO13RigthsL1HYHAbXdOKC2Gw/UdgcDtd0EoLabCNR2k4Da7hCgtpsM1HaHArXdYUBtdzhQ2x0B1HZHArXdUUBtdzRQ2x0D1HbHArXdcUBtNwWo7Y63RNs9AdR2JwC13VSgtjsRqO1OAmq7k4Ha7hSgtjsVqO1OA2q7aUBtdzpQ200HarsZQG03E6jtZgG13WygtjsDqO3mALXdmUBtNxeo7eYBtd18oLZbANR2ZwG13UKgtlsE1HaLgdrubKC2WwLUducAtd25QG231BJt9yRQ2y0DarvzgNpuOVDbnQ/UdiuA2u4CoLa7EKjtLgJqu4uB2u4SoLa7FKjtLgNqu8uB2u4KoLa7EqjtrgJqu6uB2u4aoLa7FqjtrgNqu+uB2u4GoLa7EajtbgJqu5uB2u4WoLa7FajtbgNqu9uB2u4OoLa70xJt9xRQ290F1HZ3A7XdPUBtdy9Q290H1Hb3A7XdA0Bt9yBQ2z0E1HYPA7XdI0Bt9yhQ2z0G1HaPA7XdE0Bt9yRQ2z0F1HZPA7XdM0Bt9yxQ2z0H1HbPA7XdC0Bt9yJQ270E1HYvA7XdK0Bt9ypQ270G1HavA7XdG5Zou6eB2u5NoLZ7C6jt3gZqu3eA2u5doLZ7D6jt3gdquw+A2u5DoLb7CKjtPgZqu0+A2u5ToLb7DKjtPgdquy+A2u5LoLb7CqjtvgZqu2+A2u5boLb7Dqjtvgdqux+A2u5HoLb7CajtfgZqu1+A2u5XoLb7DajtfrdE2z0D1HZ/ALXdn0Bt9xdQ2/0N1Hb/ALVdYABO2zUYgNN2DQfgtF2jATht13hAAKbtmgwIwLRd07r4qqO2W6duvuqk7ZrV1VcdtF3zuvtarbYrq4+v1Wi7FvXz5avtWtbXl4+2a1V/X7Vqu3XXxFct2m69ATht13oNfem03fpr7msVbdemGF8ebde2OF81tF27Yn0p2q79AISG+s9XhwEYPca+Og7AabtOAF8Fbdd5gB3a7lmgtusyAKftug7AabtuA3DarvsAnLbrMQCn7XoCtV0voLbrDdR2GwC1XTlQ21UAtd2GQG3XB6jt+gK1XSVQ21UBtV0/oLbrD9R2A4DabiOgttsYqO02AWo7B6jtXKC2CwK1XQio7cJAbRcBarsoUNvFgNouLqTtGuT/gny7zzVAxS+b0+ErNo4rugcCV5I1AvN+HsY7l2N8KL7H9pTJm8bg+L2Ai18WGb9vNsH5KgvaMYdfbGAHzpcswfmyJThfsQTnq5bgfM0SnK9bgvMNS3C+aQnOtyzB+bYlON+xBOe7luB8zxKc71uC8wNLcH5oCc6PLMH5sSU4P7EE56eW4PzMEpyfW4LzC0twfmkJzq8swfm1JTi/sQTnt5bg/M4SnN9bgvMHS3D+aAnOnyzB+bMlOH+xBOevluD8zRKcv1uC8w9LcP5pCc6/LMH5tyU4/7EEZ6ChHTgbWIKzoSU4G1mCs7ElOJtYgrOpJTjXsQRnM0twNrcEZ5klOFtYgrOlJThbWYJzXUtwrmcJztaW4FzfEpxtLMHZ1hKc7SzB2d4SnB0swdnREpydLMHZ2RKcXSzB2dUSnN0swdndEpw9LMHZ0xKcvSzB2dsSnBtYgrPcEpwVluDc0BKcfSzB2dcSnJWW4KyyBGc/S3D2twTnAEtwbmQJzo0twbmJJTgdS3C6luAMWoIzZAnOsCU4I5bgjFqCM2YJzrglOBOW4NzUEpybWYJzc0twbmEJzi0twbmVJTgHWoJza0twbmMJzm0twbmdJTi3twTnDpbg3NESnDtZgnNnS3DuYgnOXS3BuZslOHe3BOceluDc0xKce1mCc29LcO5jCc59LcE5yBKc+1mCc7AlOIdYgnN/S3AOtQTnMEtwHmAJzuGW4BxhCc6RluA80BKcoyzBmbQEZ8oSnGlLcGYswZm1BGfOEpyjLcE5xhKcYy3BeZAlOMdZgnO8JTgPtgTnBEtwTrQE5yRLcB5iCc7JluA81BKch1mC83BLcB5hCc4jLcF5lCU4j7YE5zGW4DzWEpzHWYJziiU4j7cE5wmW4JxqCc4TLcF5kiU4T7YE5ymW4DzVEpynWYJzmiU4T7cE53RLcM6wBOdMS3DOsgTnbEtwnmEJzjmW4DzTEpxzLcE5zxKc8y3BucASnGdZgnOhJTgXWYJzsSU4z7YE5xJLcJ5jCc5zLcG51BKcyyzBeZ4lOJdbgvN8S3CusATnBZbgvNASnBdZgvNiS3BeYgnOSy3BeZklOC+3BOcVluC80hKcV1mC82pLcF5jCc5rLcF5nSU4r7cE5w2W4LzREpw3WYLzZktw3mIJzlstwXmbJThvtwTnHZbgvNMSnHdZgvNuS3DeYwnOey3BeZ8lOO+3BOcDluB80BKcD1mC82FLcD5iCc5HLcH5mCU4H7cE5xOW4HzSEpxPWYLzaUtwPmMJzmctwfmcJTiftwTnC5bgfNESnC9ZgvNlS3C+YgnOVy3B+ZolOF+3BOcbluB80xKcb1mC821LcL5jCc53LcH5niU437cE5weW4PzQEpwfWYLzY0twfiKEs6EHZ8iJhsPZWDDrhtykE0yk4hEnHElF427cjcQjmWA8FMrGw/FYIpWIOQk3HMq6uUgilMv77gvk/GmJODvFHe5nDXHxGzjAjnFuDIzf55bkdhMg5y8s4dwUyPlLSzivA+T8lSWcmwE5f20J5+ZAzt9YwrkMyPlbSzi3AHL+zhLOLYGcv7eEcysg5x8s4bwukPOPlnBeD8j5J0s4twZy/tkSzusDOf9iCec2QM6/WsK5LZDzb5Zwbgfk/LslnNsDOf9hCecOQM5/WsK5I5DzX5Zw7gTk/LclnDsDOf9jCecuQM6BRnZw7grk3MASzt2AnBtawrk7kHMjSzj3AHJubAnnnkDOTSzh3AvIuaklnHsDOa9jCecNgJybWcK5HMi5uSWcK4CcyyzhvCGQcwtLOPcBcm4J5Eyu/n2Pz4d5wlVk/cj6kw0g24hsY7JN+LXIXLIgx4MsTBYhi5LFyOJkCbJNyTYj25xsC7ItybbK89+abBuybcm2I9uebAeyHcl2ItuZbBeyXcl2I9udbA+yPcn2ItubbB+yfckGke1HNphsCNn+ZEPJhpEdQDacbATZSLIDyUaRJclSZGmyDFmWLEc2mmwM2Viyg8jGkY0nO5hsAtlEsklkh5BNJjuU7DCyw8mOIDuS7Ciyo8mOITuW7DiyKWTHk51ANpXsRLKTyE4mO4XsVLLTyKaRnU42nWwG2UyyWWSzyc4gm0N2Jtlcsnlk88kWkJ1FtpBsEdlisrPJlpCdQ3Yu2VKyZWTnkS0nO59sBdkFZBeSXUR2MdklZJeSXUZ2OdkVZFeSXUV2Ndk1ZNeSXUd2PdkNZDeS3UR2M9ktZLeS3UZ2O9kdZHeS3UV2N9k9ZPeS3Ud2P9kDZA+SPUT2MNkjZI+SPUb2ONkTZE+SPUX2NNkzZM+SPUf2PNkLZC+SvUT2MtkrZK+SvUb2OtkbZG+SvUX2Ntk7ZO+SvUf2PtkHZB+SfUT2MdknZJ+SfUb2OdkXZF+SfUX2Ndk3ZN+SfUf2PdkPZD+S/UT2M9kvZL+S/Ub2O9kfZH+S/UX2N9k/ZDzRGpA1JGtE1pisCVlTsnXImpE1Jysja0HWkqwV2bpk65G1JlufrA1ZW7J2ZO3JOpB1JOtE1pmsC1lXsm5k3cl6kPUk60XWm2wDsnKyCrINyfqQ9SWrJKsi60fWn2wA2UZkG5NtQuaQuWRBshBZmCxCFiWLkcXJEmSbkm1GtjnZFmRbkm1FNpBsa7JtyLYl245se7IdyHYk24lsZ7JdyHYl241sd7I9yPYk24tsb7J9yPYlG0S2H9lgsiFk+5MNJRtGdgDZcLIRZCPJDiQbRZYkS5GlyTJkWbIc2WiyMWRjyQ4iG0c2nuxgsglkE8kmkR1CNpnsULLDyA4nO4LsSLKjyI4mO4bsWLLjyKaQHU92AtlUshPJTiI7mewUslPJTiObRnY62XSyGWQzyWaRzSY7g2wO2Zlkc8nmkc0nW0B2FtlCskVki8nOJltCdg7ZuWRLyZaRnUe2nOx8shVkF5BdSHYR2cVkl5BdSnYZ2eVkV5BdSXYV2dVk15BdS3Yd2fVkN5DdSHYT2c1kt5DdSnYb2e1kd5DdSXYX2d1k95DdS3Yf2f1kD5A9SPYQ2cNkj5A9SvYY2eNkT5A9SfYU2dNkz5A9S/Yc2fNkL5C9SPYS2ctkr5C9SvYa2etkb5C9SfYW2dtk75C9S/Ye2ftkH5B9SPYR2cdkn5B9SvYZ2edkX5B9SfYV2ddk35B9S/Yd2fdkP5D9SPYT2c9kv5D9SvYb2e9kf5D9SfYX2d9k/5CxqGhA1pCsEVljsiZkTcnWIWtG1pysjKwFWUuyVmTrkq1H1ppsfbI2ZG3J2pG1J+tA1pGsE1lnsi5kXcm6kXUn60HWk6wXWW+yDcjKySrINiTrQ9aXrJKsiqwfWX+yAWQbkW1MtgmZQ+aSBclCZGGyCFmULEYWJ0uQbUq2GdnmZFuQbUm2FV8XJduabBuybcm2I9uebAeyHcl2ItuZbBeyXcl2I9udbA+yPcn2ItubbB+yfckGke1HNphsCNn+ZEPJhpEdQDacbATZSLIDyUaRJclSZGmyDFmWLEc2mmwM2Vgy/q16/h14/o11/v1y/m1w/t1t/k1r/r1o/i1m/p1j/g1h/n1e/u1b/l1Z/s1W/j1U/q1R/h1P/o1M/v1J/m1H/t3EqWT8e3/8W3r8O3X8G3D8+2r822X8u2D8m1v8e1b8W1H8O0z8G0f8+0H82zz8uzf8mzL8ey38Wyj8OyP8Gx78+xj82xP8uw78mwn8ewT8Xf/8Pfr8HfX8/e/83er8veXLyfj7tvm7rPl7ovk7mPn7jfm7g/l7efk7b/n7ZPm7Wvl7UPk7Rvn7O/m7Mfl7J/k7Hfn7Evm7CPl7/vg79Pj76fi73/h71fg7y/j7wPi7tvh7rPg7ovj7l/i7jfh7g+4l4++74e+S4e9p4e9A4e8X4e/u4O/F4O+c4O9z4O9K4O8h4M/48+fn+bPp/Llv/kw1f16ZPwvMn7Plz7Dy50P5s5f8uUb+zCB/Ho8/68afI+PPaPHnn/izRfy5nXfJ+PMm/FkO/pwEa15+fz+/d57fl87v0+b3QPP7ePl9rfw+T37fI78PkN8Xx+8T4/dN8fuI+H01/D4Tft8Fvw+B78vzfWq+b8v3Mfm+Ht/n4vs+fB+E7wvwdXK+bszXUfm6Il9n4+tOfB2Gr0twnc51K9dxXNewzm/4n2wI8PuU+agKrDzySwq7/bef39fL73Pl933y+yD5fYH8Pjl+3xi/j4rfV8Tvs+H3nfD7MPh9CXyfnu9b831cvq/J9/n4vhffB+L7InyfgK+b83Vkvq7K1xn5ulsvst5kG5Bx3c51LNd1XOfwe+crA6sevE8Vjjb5v+0/3LrzIY9fsr36uI75v0vbHDG17wQexZVH1/zfD9rvfc7xLSr/VvsG+PjcPf/3vMt63NT1w4bD1L49fPr29enbz6dvTP7v6GM+ajn0gocmq32T8n/P75Rc/vHfb7dQ+47w4XCMT9/x+b+6mJ2Xj/ux220Rmv/q5SeofZc1qJ3DFT59N/j03eTTd6tP3+0+fff79D3o0/eYT98TPn3P+PQ959P3mk/fGz59b/v0vevT96lP3+c+fd/49H3n0/eHT99fPn1NGtbet45PX5lPX0ufvnY+fR18+rr69HX36evt01fu09ffp28jnz7Hpy/o07epT9/mPn1b+/Rt69O3Y77v9oeO/eP81+4dp/btke+7I/7QLq9esl4Hte+AfN9T+5zz4uA2R7ZW+4b79I3w6TvQpy/p05fy6Rub79OtyePyfdv+9eaO1847rcaWeIjP8+b69M338bnI53lX5/t0+8P1+X/p9tS7fXy+6TPub/n0ve/T96FP3y/5Pt2eylqKD92e2jzf9/r7L+4zaeIxe6p9Zfm+hoHW6w57cNxDat/djWrnfr9P39M+fc/n+3Tj95rP897z6fsk36cbv598ntcpLyp1se7i07eBT1+FT98W+T7d+A3K9+nGb2i+Tzd+Dzaund+GTWrvq/Lp2zfft+3swUPnDLq1t9o3uGXt/Ib49A336Rvp05fz6Rvj0zfep2+CT98RPn1H+fRN8ek7wafvZJ++U336Zvv0zfHpm+vTN9+nb7FP3xKfvs/Xq73vS5++n3z6fvHp+82n7w+fvkDr2vsa+vQ19ulr6tNX5tPX0qevnU9fB5++rj593X36+uT7Tiv/vs21ly3eUO37ev3an/etT9+PPn0/+/T97dNXKKi12tunbx2fvhY+fa18+tr79HX06evs09fVp6+XT98GPn0V+T7dHrCPT9+gfN8TC555+NLTkxm1b7DP8/b3ed4wn+eN8Ok70Mdn0ud5aZ/nZX2eN8an7yAfn+N9njfB53mTfJ53qE/f4T4+j/R53tE+zzvW53nH+/RN9fF5ks/zTvF53mk+z5vu0zfTx+dsn+fN8XneXJ/nLfDpW+jjc7HP85b4PO9cn+ed59N3vo/PC3yed5HP8y7xed4zPs/bpV3tz9vLp2+IT9/IfJ+uRhjv87xD83067X2Sz/MezPfp1t2Hffqe9ul71qfvs3yfrrb4K9+nqy0atq+d38Hta+f3vU/fzz592+Svcuhqi4c6187vYZ++J3z6nvLpe8mn7xWfvjd8+t7y6fvIp+8Tn74vffq+9un73qfvR5++P336/vbp+/dmSS19DX361vHpa+7T1yLfp9OmL3St/Xkv+fS95tP3hk/fBz59H/n0fe7T96VP37c+fd/79P3u0/enT9/fPn3/3hyrpa+JT986Pn3N8326NSTm05fI9+n2lc18nreFz/O28nneNj592/n43MHneTv5PG8Xn+ft7tO3p4/PvX2et6/P8/bzed7+Pn3DfHwO93neSJ/njfJ5XtqnL+vjc7TP88b6PG+cz/Mm+PRN8vE52ed5h/k87wif5x3t03esj88pPs87wed5J/o87xSfvtN8fJ7u87wZPs+b5fO8G32e16dH7c+ryvfp7jFs4vO8mE/fZvk+nW7d2ed5e+b7dLruBJ/n3ZPv063J9/n0PebT94RP30f5Pp1u/S3fp9Ot/74JoxZ+E3rWzq9Fr9r71vPpG5Hv0+nWUX1r55f06cv59I3x6Zvk0zfZp+8In76jfPqm+vSd5NM3zadvuk/fbJ++OT59i3z6zvbpO8enb6lP3wqfvgt9+n7sV3vfzz59//j0Nehfe18jn74mPn1lPn0tffrW9elr7dPXzqevg09fD5++Xj59G/r09fXpc/J9urrj1wG1P+93n76/ffr+/RBKLX3NfPrKfPrW8+lb36evvU9fR5++nj59vX36yn36NvTp6+fTN8Cnb+N8n24PGO7TNzLfp9WmPs9L+Twv4/O80T59Y318jvN53sE+z5vo87zJPn2H+fg8wud5R/k87xif503x6TvBx+eJPs872ed5p/o873Sfvhk+Pmf5PO8Mn+ed6fO8+T59Z/n4XOTzvLN9nneOz/OW+fQt9/G5wud5F/o872Kf513m03eFj8+rfJ53jc/zrvN53ms+z9t1k9qft1ctfV3yfx/Pa5Hm+X8XChN+uyK/PWZg/t9OcYfbXPGL9h93ksHmgZoHGH+oueJTwH+w4L+xjP9/v++Yj+VTa/oPeF63Vf7fytvRq59T6FOL1/Pzfc3y/YXzwhupm3v8SYy7igkdt7Ya/A0VbnxsO1XitYPpgv/t8v4DNXy7oXg0FIxHg8FM1klmorFcIhRzQqlIKJFOuU4oEoxnYsmQ42RD2XTYyUQTkUw2mYiEcqlkIlrwvb3WdyibIleRZDSecnPJaM5JhWPxUDIXi2WSmUQ4G4s4GTcdddNBNxePJyORZDqScN1cNhHJxat97yASF6d6ru8o4j8UKfjfSQZ/9Vq4s4z/6vjvovgHfpe/U/C/qwj+YKrgfzcZ/NXx313Gf3V+7pH3HwjgY7+ngr2BQGz2kvFfHZu9ZfyHCv73mSqRmyv97yvi360e30Ey+MMF//vJ+M8V/A+WiU+s4H+IDP5Mwf/+Mvir59fQvP+A4tuNh4LBWIi/IyWecdxwJh2M0+6eCjtpJ5kOZhNhN5ELB8OhdCadiofjSTfn5JLpRC7+n/eC72Ei2EPVuXOABrtTzOGuxD5cwY5bF0LVe+IINHbHqdYLI2v3vcZDW/B9oMZ3MBlKO4mck4zEk7FsPEJSz6GTVDybiwaTKRJ9wYzrutkw/S+YzYQTqUzUTUWzsWAkRS9XHfNRUyXyxa3Wr0mw/2jSSWSj0eq1IAX2n0pFY0mKZ8F/Guw/lI5mc6FY9V6YAftPRsK5XCSULPjPgv1HXCcbCcaqczMH9p9IOZFoPF6dP6PB/qlmCWUSyWqdOQYdn1TWSWfcRKEeHpv3X3gNPgqvfRD4tfNHooHn9QKBmvV+wPP6ZR6s6Jqngef1VDxqfAq1dSF246auirW1pk9dY7x9jTRthdfR+UoBfaWBvjJAX1mgrxzQ12igr8K8lp1r4ep9dJyI/1C84H+8iH8nW/B/sIR/RdtNUPwHcPir/U9U/DcQ8D9JJv7V/g+RiU91zTE571/C96Eysa+uOQ6TiX21xjtcxn+1Rj1CJj7Va8ORMvir/R8l4z9R8H+0jP9qDXyMjP9qDXmsjP9qDXyciH+3Gv+UqRL5Gaxe244XwR+sXn9OEMEfqsY/VcZ/Nf4TRfyHq/2fJOO/en0+WcZ/9fp8ioz/6utCp8r4r9ZWp4n4j1TX4NNE/Eer8+d0Gf/V10Cmy/ivvl4/Q8Z/df7PlPFfnf+zZPxX5/9sGf/V+ucMGf/V+mSOjP9qfXKmjP/q/XeujP9q/TBPxn/1/ZL5Mv6r188FMv6r18+zRPzHqvXDQhn/1evnIhn/1evnYhn/1evn2TL+q9fPJTL+q9fPc2T8V69v58r4r17flsr4r17flsn4r15/zsv7D6y575C3gT9UxO9l65P/PgLdewCBWs4pvL+u8UoqNe4X8HkTpR1YB2bqcr9Aff0yD1aJ+wXq6xXweOOj3i/gvqYarK01fd4xbKp5naaa12mt6fNqv2J8LQT6mgX0tQDoC8lxHtDXHKCv+UBfs4G+pgB9IWOPnEOLDPU1DegLmRPI2CPzawbQF3JuI3NiOtAXco1eAvRl6v5Y0NSy2sqJttK8duEo9K2jvLaqqbxHI8+/VdysVQe0WenX+7jCwV/Jmf+6y0Aue1h6zKDk6NHZzG4TRx8a8HkaH9tN1bebFsIGnr5mdeAQCKw+vAPrEF6vjFextfL4VJ/bQONL95Ydb0qrMW9cCwbVR2GsvHJ4YP7fTlGHG6oLD/X1S1VK6JYKXSlRiM86MvEJNvD4V/Gso4mPN4e9Y9cgsPItLk0UX+rj11E4qo9XzwvPV9vezv9tHVh1HhU+3tBA09dI01aIL2N/1cNNHRtvnsqMQ9ita54WXr8sIDlvVuapLi90W1rzwKrjjHxbU13GVbe2Ndf0FXwV3mao5qn6+GYKR/Xx6nnh+Wrbl/m/rQOr5rQ3T5tr+Khtap5+nD9vXgufgfl/O0UdsZhun/LOAzVOyLdp13UeFF6/LCCZdyvngW6cdOtJIXZlGqytNX3eSz9lmtcp07xOa02fV44W42sB0Nd0oK+ZQF+LDPU1B+hrPtDXbKCvKUBfc4G+kHlvYrz89sH6+uIDmauLgb7OAPpC5iqS4zSgL1Pn9lKgrxOAvgq3EL06s+A/EFiplbz7/cD8v52ijv9qN/X1CjzUNvX1yzxYsXhWaiVdXHWathCfFjLxqcbTQoOnhSY+hbFsqekr+Cpca1FrBvXxLRSO6uPV88Lz1bZofsBae3zy4a0ZWmr4qG1qzeA0qMlNHRtvnkqOg/p6Bdxqm/r6ZQHJeeP45oVu/jcPrDrOwPg4dRlXFW9hLFtp+gq+1s3/W81T9fEtFY7q49XzwvPVtu08earmtDdPW2n4qG1qnm7pyVN1bLx5KjIObq7OeVp4/bKA5LxZmae6vGihiWPzwKrjDIyPU5dxVfEWxnJdTV/BV+HSv5qn6uNbKRzVx6vnheerbft48lTNae9Hs9bV8FHb1DzdLe+3eS18Bub/7RR1RMK6scT5j7mtNDy980yNNS6vQ3WeZ4XXLwusmhcS82w9D57a8qAQu9YarK01fd4caa15ndaa12mt6fPWNcX4mgn0NQXoazrQ11ygr2lAX3OAvuYBfSFzYgbQ12lAX4tAvnTrczG4FoJw8bEY6As5t5cCfSHXQuR8nA/0hRzHZUBfyJxAxh41twNgjsicWAD0Zeo6gcT1v6CZ1u5p/3exR87HWUBfSI7nGIoLqSeQHL33B9TaskH+b/PAqnMPWGdnG3her8BDbVNfv8yDFYtnZZ2ti+t6mrgWYre+BmtrTZ+3zl5f8zrra16ntabPu2cU42sm0NcUoC8kxzlAX/OBvhYDfSFjvxToa+041s/XMqAvZE7MAPpaAPSFXL8WAX0hY4/MVWTsTV2/kLmKzK95QF/IcUTmF3IOIfNrIdDXNKAvJEdTtRySI1JPmDqOpmq5c4C+TNU5SI25Vk/8/zGHkOsEEhcqv/jce121GFxng3DxgYw9UgMU9lrv+90K/vmQvYYWrPN7bL3X0ETeg7Waa2i699Y1D6yah8D4uHUZZxVvYSzbaPoKvtrm/62+J0x9/PoKR/Xx6nnh+WrbDvmgtPb45MP7nrA2Gj5qWyG+/J6wgQ1rclPHxpunkuOgvl4Bt9qmvn5ZQHLeOL55obuG3jyw6jgD4+PUZVxVvIWxbKvpK/hql/+3mqfq49soHNXHq+eF56ttgzx5qua0N0/baviobWqe7uHJU3VsvHkqMw51fy944fXLApLzZmWe6vJCt081D6w6zsD4OHUZVxVvYSzbafoKvtrn/63mqfr4tgpH9fHqeeH5alvKk6dqTnvztJ2Gj9qm5unw/D/WC9Q+P+u7Tuv0mDeG6vO880FkvN2sU9f5UHj9soDk/Fw5H9rWMa6F+LQTiU8mV5f8UfEWxrK9pq/gq0P+3+p8UB/fTuGoPl49LzxfbTvUMx/UueOdD+01fNQ2dT4c7Fm31bHx5qnIODhOrq55Wnj9soDkOrkyT3V5odv/mgdWHWcgnmxdxlXFWxjLDpq+gq+O+X+reao+vr3CUX28el54vtp2oidP1Zz2foang4aP2qbm6bH5fzSvhc/A/L+doo6sqxtLnP+k01wTa5z/YKK5Zrxw/lPxgv9OMv6jBf+dRfzHq8e3i4j/SHV8usr4zxT8d5PJn2r83UX8h0IF/z1E/Ger8fcU8R+u9t9LxH+qev72FvGfqM7/DWTiUz2+5SL+c5GC/wqZ+FTj31AGf/X631fxj7wWUfBfJeLfCRXiURlYeTTScCq8fkGL9FEe36CWvwVf3r7Ca5V5fEnpPh03Fb+37qtU8KgxqM1XZT19Ndf0SYxpXx/e6uu38sHq5cGH97sx1jQmfMwA+joV6GshyJdO2xaDayoQV3sQLp3+LcZXR6CvRiBffHh/KqwYXJ1AuPi8s6G+ugB9dQX66gb01R3oqwfQV0+QLz68P+FSDK5eQFxnTcXh6g3CxecbAH2h9g4+Lwf6qgD62hDkiw/vtVNTfO2Z9yV7vSuckL3eFUrKXu8KZ2Svd0VCste7wjHZ613hdEGrF/bDwmuouaXub7i6Ilznz4gVXr/MgxWLZ2V9182DxxufwrwsxK67BmtrTZ93jnbXvE53zeu01vR53+NXjK8lQF/TgL7mAn3NAfqaAfQ1BehrHtDXTKCvRYb6QubqbKAvVOx1+7YpuYqcj4uBvkydj2cDfSHnkKmxPwPoC7lOIPda5BqNjD0yXqbmF1KbIMcRGfv/hXViKcgXn3tr2GJwnQzE1RGEC+mLjxOn4nB1AuJCxZ6P04C+kDnhvZZejK9GIF98oHKCj1OBvk4C+kLmFxIXKldNXgtbAnEhcxU5jsh11dR4IXPVe23VlLmNXL+WAX0h9dcsoC/kNQWkJkfWCshrjwV9X7iO3UXpa5D/K3sPwFnjewBdZPD43gPooomr7v2wQDyZuoyzircwlj00fQVfhXv56nv71cd3Vziqj1fPC89X2+blB661xycf3vf299DwUdsK8eX39s9qVJObOjbePJUZh7r/NmTh9csCovPG9cuLbpo46vKi8NzWmj6vpq/reOnG3vvet2J8LQD6mg70NRPoa5GhvuYAfc0H+poN9DUF6OssoC/kHEKO4xKgr2lAX4uBvpBzG5lfyDmEXFf/F2I/D+gLuUYX1kLd56iA+sPRfc4J6L/6Mwc9fWKhvr73vTiFft3fgi9vX+G1yjy+wNxcP25+tZuqw73v7dX56llPX7rPxkmMaQ8f3urry34WMBKU/SxgJCr7WcBwrpDzvZV4NvDErlxkLON1/i6VwuuXebBKzalyDx5vfLz1UIUGa2tNn/e9exWa16nQvE5rTZ933y7G1xKgr2lAX3OBvuYAfc0A+poC9HUW0NdCoC9k7E3N1cVAXzOBvpD5hVxzFgB9/S/Efh7QF5LjIkN9Ief2bKAvVOz53Pu+XFNy1VQNgPS1dt9eu2/bsnes3bfX7ttr9+3/P2Nvaq6eDfSFjBdyzUHG/gygL+QcQu7bpq7RpuoJJEek9kWOIzL2/wvrxFKQrwaBVd+fU4yvHkBfqOvkfN4T5IsP73uPi8HVEojrZBAuPk4D+joV5IvPewVwvv5/jz2fez87UYyvjkBfnUC++EDGawMQLmSu8oGcQ6bmvakc/39fC5G4+Fi7d9i/d/BxCsgXnyPf84CKF593BuI6CYgLtdfygdwfkfEyce/gYxnQF7LmmwX0hbyng7wOgLw+gXx/jvfzbeVKX4P8X933xfPrDMz/2ynuyDTwvF6Bh9qmvn6ZBysYj+sX13JNXHXfdw/Ek27g8a/i2VATn8JY9tX0FXwVvidT/Xyb+vgNFY7q49XzwvPVtm8a//e3tccnH97Pt+m+K11tK8SXP9/2WeOa3NSx8eapzDgE6/z5tsLrlwVE543rlxe6+a/Li8JzdePl3ffrOl46X3OAvhYBfU0H+loA9LUE6Gsm0NdCQ3HNAPqaAvS1FOjrBKCvZUBfyHjNB/pCzsfFQF/IvEeuhchxnAX0hVxzkDkxD+gLGftphuI6C+gLmRNIbYLct5HjaOr6hcwv5Hw0dY1G+kLm12ygr0LsC/WKWt80yP8V/g24cAPP6xV4qG3q65d5sGLxrKz1dHHdUBPX+vy+WAFr4VztU1+n1L/jxccCoK/pQF8zgb4WGeprDtDXfKCv2UBfU4C+UL+NxMc0oC/kfFwM9IXML2S85gJ9IfMLOYeQ6yoyJ5DrqqlzGzkfkXNoCdAXcj7+L+TXPKAvpAYo7LXr5ftUva1+H4nap76On+ZXn194XCvN8xrk/8r+hm+izt/XUXj9Mk1MJDR/ZR3jWohdlQZra02f970rVZrXqdK8TmtNn3dvKsbXEqCvaUBfc4G+5gB9zQD6mgL0dRbQ10KgL2TsTc3VxUBfM4G+kPmFXHMWAH39L8R+HtAXkuMiQ30h5/ZsoC9U7Pnc+30dpuSqqRoA6cvUfRsZe6QGQK7RSD1haq6u3bf/7/a0tZq8fr7WavL/u/xaqwv/7/LLRF3IBzJepubq2UBfyHgh1xxk7M8A+kLOIeTeYeoabeqehuSI1L7IcUTG/n9hnVgK8tUgsOp7nIrBdSIQVw8QLj5vCfSFvD+EjFdnIK7TpuJ8nQryxee9AjhfqJzg4+SpOF+o2CPnNno+ouYQn/cE+eIDOR//F/LL+31DxfjqCPTVCeSLD2S8NgDhQq6FfCDXaFPz3lSO/7/vtUhcfKzVJvbvHXycAvLF50hNjooXnyM1+UlAXKi9lg/k/oiMl4l7Bx/LgL6Q1xRmAX0h71shrzMhr38h31/o/b6hlkpfg/zf5oFV1zp+nYH5fzvFHXX+HpfC65cFVt2rgHiq3+fbLrBqXFtq4lqIT3sZPKkGHv8qnvaa+BTGsoOmr+CrsA6r3zekPr69wtG7bndUcDTxtD3R9L+/rT0++fB+31AHDR+1rRBfdvlQ05rc1LHx5qnMOLh1/l6swuuXBUTnjeuXF+00cdTlReG5rTV93ms4dR0v3dh735tQjK8FQF/Tgb5mAn0tMtTXHKCv+UBfs4G+pgB9nQX0hZxDyHFcAvQ1DehrMdAXcm4j8wuJCzmOSFzIdQKZE8hxnAf0hVzvC+tqQVt5NcHA/L+doo5IpKBNVC1T0FTNA3ptgnltN97A83qBgF7XFV6/zIMVi2elrtONmxofr67rqMHaWtPnHcOOmtfpqHmd1po+79wsxteZQF9IXAtAvvh8nQDGF5rjFKCveUBfi4C+ZgN9IeO1GOjrXKCvs4C+ZgJ9IWM/B+hrBtAXkuNSoK8TgL4K16O92oKPgfm/tB2G4tFQMB4NBjNZJ5mJxnKJUMwJpSKhRDrlOqFIMJ6JJUOOkw1l02EnE01EMtlkIhLKpZKJmKx2iCSaB/T7K8a/Gyz47yTjP1Tw31nGf7jgv4eM/0jBf08Z/9GC/14y/uMF/zLfoeFW52eVjP9kwX8/Gf+Zgv/+Mv6zBf8DZPznCv43EvEfdAr+N5bxX73+bCLjv3r9cWT8V68/roz/6vUnKOO/ev0Jyfiv3h/DMv6r17eIjP/q9S0q4796fYvJ+K9e3+Iy/qvXt4SM/+r1bVMR/6Hq9W0zGf9uwf/mMv6r188tZPxXr59byvivXn+2kvFfvf4MlPFfvT5sLeO/en3YRsZ/quB/Wxn/6YL/7WT8V69v28v4r17fdpDxX72+7SjiP1y9/uwk4796/dlZxn/1+rOLjP9q/barjP9q/babjP/q9XN3Gf/V6+ceMv6r9dueMv6r1+e9ZPxXr897y/ivXp/3kfFfvT7vK+O/en0eJOO/en3eT8Z/9fo8WMR/pFp/DpHxX73+7y/jv3r9Hyrjv3r9Hybjv3r9P0DGf/X6P1zGf/X6P0LGf/X6P1LGf/X6f2Bg5bHSdyibokvxkWQ0nnJzyWjOSYVj8VAyF4tlkplEOBuLOBk3HXXTQTcXjycjkWQ6knDdXDYRycWrsY/S+i7mcKvnVVIiLm6uel1IKf4bwPDHq/2nRcZ1pf+MSHwy1etyVjO2wXAmmko6sVwsmYznaBMNZuhPlLImFwkmE6F0krIok8omU6F0IpjOBDOhbJzWmmwoEc1mwxl+K/DJ+Rvphe/Bzik8mnjGZHT+34X3OvMxaerKx+SUfvXxt5X995dfb1r+9VopsQoor8NHgXNjiZjStfwGntcLBPTvUym8fpkHKxbPyvepNPbg8cbH+z6VJhqsrT19fHjvWzbRvE4TzevofC0D+poC9HUW0NdMoK/5QF8zgL7mAH0hOc4G+jI1v6YBfS0E+loM9IXML2S85gJ9IfMLOYcWAH0hcwK5rhbez9Y8sOpeiNubo05hrx0VWPUo9CUDNXmpfSnl8dtPXfk479HI82+VUzOyvdqs9Ot9nBePqpuSiv/aNAMfhTg2VfqRGqfgv7mM/1Ah9s0CNWPq5dS8llgV+nV/C768fYXXKgusGncJfajjpuL3zpdmCh41BrX5alZPX801fRJj2tSHt/r6rXyw6nh46xvdeqTT34XHN/fBpT5+Pc1rF55biGGZ0geMYdAvhupcLLx+SwVnJps6fPRuE0cHPEcjTxwKcevkedxOU1fGwZuDzWrxFfD8u5OnrZHiTz1ka8b/232gwKm++4Aa26Snb03XPT68a4M35nzwWH/kubbQSMPJm0O1XVtopPSrj/98nZWv91n+vIXymq18XnNdD2718XzsNLXm49dTuDXSPKaVB2Ph8d/kcfH4jcqPny52BTzNPc///ymXC5zqm8vqOHqxFXyqn8FXx7a2cflDGZd0m5WYva+3bqB2HoV/H6h5vQL29T2P5aMwxm2UduA1rjr/5lvh9cs8WMH7ULWGaePB441PYW3hfahF/nz8xGRm2+SkQw8fn23oCWVr5Vx139rjrvAY9bHq0VqBFKjlcd5h52Pfqas+z3sUQtnEg7l1fg/k5aRJ/ny9wKpT3/tVUiqGRpo27/LcUoNfd/l1wtSafaoc2sPT19Snr5lPX3MNr0JfmfK8SZ7ntdD4ZAyDm630p8Y2ENCnV2G51sW5tlyqzdcOHl/q89t4fLVdja99PL7U57f1+Gq3Gl+DPL7U53u/vqT9anwd5vGlPt/7s0gdVuNrZ48v9fner6HsuBpfh3t8qc/3fjVWp9X4OtLjS32+92soO6/G11EeX+rzvV+N1WU1vo72+FKf38Xjq+tqfB3j8aU+v6vHV7fV+DrW40t9fjePr+6r8TXE40t9vvdnWHusxtd4jy/1+YXnttL48m7JMh+BqfvXMxVev8yDVWpL7hlYNa5qfLy3nXppsLbW9HnXrV6a1+mleR2dr3ZAX+2BvjoAfXUE+uoE9NUZ6KsL0FdXoK9uQF/edWt1+/V+U//767dfF56n5q76uEbKY3R7tOqjNj3QKFB3XbCvB7PuNXUa85CpNfvUS3BebapeLmrt6VMvpbXx9Kka07vuq5fZ2nr6Wih9BT6qxmzi4TM03y5brjuOqgVri5W3btH9DQTqdjlHd0muled1Ea+jxsu7x7QGvo5X16uvsz7wdVRf20+t+TptNa8j/HWQubrwUF+/LKBfVwZi8Ljer83TxULm49/hOl8O6eiJhczH3VdqL109oeaK95aDrmbQfQWRevlkdPYwuoi/zdGDkqPXUR6qLp1eOOt6Huf9lsj2tcAa6HlcR8+/C7LEi0P1pR5eHH6XZ3Svr1sWC+dNNO186Motr5TVDZva5l0a1Od39nmdDkW+TgfN6xSmliq9JO7sdpPxX30XUFfiqpwKr99KE6f6LO3qa5UFVh0jiWVAx81vnFXpW5dLAV3r6au5pk9iTLv48FZfv5UPVh0P9W6Sus79qVxyPa1ZTd+6tUL23SWhaF3zsfD6pXonal3vhOukeuG5rT19fJwydeXjvH2NNG0NfXwtAPo6G+hrPtDXDKCvKUBfSI7IcURynA70heQ4D+jrLKCvuUBfM4G+FgN9zQH6QuYEcj4i5xAyJ5Dxmg30tQjoCxn7WUBfyNgvBPpCxgu5Fk4D+kLGy9S1EBkv5Jrzv6CZkDmB3LdRsedz77cFm5L3yNifAfSFzHskR+Q6gdQAyHgtBfqqy6c1dXV94fG6d7jrrkv9r7zDPeJ5HOId7hFPW6OA/h3u7Psjz6enu3qey4fs9dhQsIHn9bwcA57XL/NgBY9/9TUr3duWdNc9C7HrrsHaWtO3gXKu9qmv013zOq01fd59uxhf84C+zgL6mgv0NRPoazHQ1xygL2ROzAf6mgL0hcwJZLxmA30h4zUL6AsZr7OBvpC5OgPo639hHBcCfSHjhdyHpgF9IeNl6j6EjBdyvUfmF3LNQc5HZE4gNRMq9nzuvQZjSt4jY38G0Bcy75EckeuEqfprKdBX4RqM7iMu3rfW62rYbj6voz6/Wx186erhwuN1HwPxu9ajfiyl8FzZX3lZea1HNx7qx3YKr78m13oKcXM9j/Ne61HXth61+Ap4/u162mq71uN939LE/IUs2V8Z0r/V3Pt+Rb+PJuo+Mqm2efNXfX6bWnzV9o0A7QL6WB2ejxWPe65NTZ+re7ut9+OhKibv+wk71/L66tg38Tz2GAXb2Da1v5ZEXHWv07LI12mpeZ1Wmuc1qOVv4XW8bd7X0WEuvI76HsJCfvC10lObr3yOd7waaZ5b+Iikd8wuVr698vS8T93HKGvL3wbK66nvo95has3HF9bmpoGVMVEf4833wuNnKzk1ypPv7TycVZ46zAWf6rdSqJgLHxH3YpjnWZ+E3gusXZ8Kr6X7KFLzgD4egYB+TLx511wTB93rlBf5OuWa12mleV6x80iH2e9ewpq+juqrMCdlc6P+32rijXNK6fO+7zit9Hm/QUz95l/1Hpf3aOT5txoLnrvj6/BtKLL30koXwy6ePjWG3jmuHroYFmJR1xiuF1g1ht653UbDQzfvvZ/XqO+87+CDQX2d9Tx93o8aqn3q/Czz4GukwdfIB1+Z5nVkPxtQ/xzs4OlTc7Cjp0/NwU6ePjUHvXmdVfq8H73MKX1NPX2jlT7vt9SNUfrKPH1jlb76zofCuPDrLQd9W5iqc1KevmYav7IfbQyF6rIvqa9f5sGKxbPyHrRu/uu+VVH3S/OF57b29PFx0tSVj/P2NdK0NfTxhfylZuSvik8H+loA9LUE6Av5690LDcW19te76+drGdAXMl7zgb6Q83Ex0Bcy75FrIXIcZwF9IccRuX4h43UW0Nc0oC9kvJBzCKknkPGaC/S1dl39v1tXUbHnc+89aFPyHhn7M4C+kHmP5IhcJ2YDfZmqV6cCfRX0qvf6Fp+r91MK1wDUr6JD3gv+v/zeEZWT93tH1Fg1qOVvwZe3z/u9Ix1luPl+74hfHqjX/LxfMVjM944UfJXqe0c6+fBWX7+VD1Ydj3bAmNTl1yl015bqO7a6r6otPFd4jlW/n6OdT5zU1y/msztBz+MK91YbBlYdu061+Ap4/h30tNX2fg7ddxKp96p3K9NjVu9V677+1/trCKco96r3zJ/r7gu0DtTsU3Ot8DV2sr/uUv/r/I08fSmlr7bv8goE9NfIC5zq+ysE6ue7VGyqz9p+haCp0q8+fnjZSiyH9db7bKD4VD/n5v2FisK9SfU9BOpjvBgKjx+lYPC+h6DwmMa18GpWi88jlFxMl+l9BjQ+dbzKPLy8GJp7MBQeP1rhdWTvlf7VxxT+ra6vk6fWxNZC81qBWtpU3+pzvX1+r7u65/K5+gsV3j5vrnjjpT6/tph6c6Xw+Ek+udJUg0Hl6x1XLwbvY8pqwXCYBoP6lYfpiZOOzv9iRMBzeH/4ppHn396h9A5BU42f2o6Cf37OEWV6P4V/+6Wf+jaUZprXaFYLRvW5HJ5C+DLZ8dnDsrUEqKGGgO7FGgb0h+4nIgprqfAvhtX5s6neX25rKoPH95fbdJ/h1n1NceG5unvy3vc31fV1WgZWvo/u0MMmTq4tF7xj7/13k1pev4Hm+QHPcxto2gKBmp9z1ukTL+f6/opkcw1+3euUFfk6ZXV8nbZFvk7bOr5OhyJfp4Pmdby+dHqVj4OmruxXHz9fWceP6a332bAWn4WfTCk8XldD6N7bUni87hpIOw1H3XcbdAys/rXVWHr3vU71xLq6axDe9w7patm6Yt2hxFib1BNrmea11b2fNrexR2Qn7zHxsKy6xHhhBDzn3n3f+03n3u2sWS1QW3oe530btPfyUBPPv9t7/t1Cg093FHCohxdLo8Dqj8IULcTqAmWKTuld87V0S4g6RQtp7y1/1efqyt//196bgEl2XGWiNysrq7uqurpL3VqspS11t1qyLMvOrTYb4/JTt2RLtixLsoQxCNeSJbXc7rZ6026nl/EiGxvjBWNsjAEbY1YbPAPDDA/eLDD4e/BgzGMZGGZ4MDAMMMx4mI2Bebqteyr//PO/ce/NjKjK7q74vvrq5o1zzzlx4sSJExEnIlSYPk4tpoVOp5kfuxmGw5a/6DA/avuM62RutSVFbfVRt+bspTyUE4bVn8Xd7sW5PkSDPI9uzEosn/a+Dh8sn0o7vyzixLJTN/vg9ho+6he3Hl1JeRgux1uisvSK9RXD3uxb3Fpg9fUWgOOu8WH4XSZ4pGnwJ4COGhLZtxWC/3kxJJoWPBk/4/S9X52Za5gMT0a9yfJORd1lx7zTAH+o3YHjpKZ3rEyxLBYLTO9gPTJvhhNtDNZtWr38CtQLXzKJ9B6O0sthv8uCHsvS8uNkdXyacCwmv6sDpZmlEtGLIj3cMvoTUa9sQwy3ThM/LB/lNjgumTwJz4j+9YTOYBAW0+uBpSgFTlX7peI7TibKCvH8xzAL9zWaEcamz3fjIg9l8Y5HB6OCf0VnbEA6Y4IOR2LHiS+zfECUlSOx48QXTx6BPL7M8qGot1yW9yYHzqMOnG925B1z5B0XeTFP9+7o8MjmWDUN3gGJdZfWDtJw3UK48PvThOtMBi6+IBO/P0O4HsnAdQ/hwu8fIVyPZuA6Rbjw+0cJ12MZuPiCTPz+McL1eAYuviATv3+ccD2RgYsvyMTvnyBcT2bg4gsy8fsnCddTGbgeI1z4/VOE660ZuPiCTPz+rYTrbRm4+IJM/P5thKudgYsvyMTv24Tr7Rm4+IJM/P7thOsdGbj40jr8/h2E650ZuO4mXPj9OwnXuzJwfRPhwu/fRbj+ngNX/GxD9V3ie/t2SuAqJf/N/Xo3vPfn7tRy74Ix+hPEq19+Ou7Xu6NeuaJ8eLb7PYLXaZGHfRHmIZ33CDoK10mPuE57xHXGI65HPOJ61COuxzzietwjric84nrSI66nPOJ6q0dcb/OIq+0R19s94nqHR1zv9IiL+zKXXx8/23Suy6+379Ce8fRQmb5BeMSRNm4oA8+nM3jmKdN+xw/x83MJV7/jh/j5asI1yPjh3nY3rn7HD/HzNcRXv+OH+Pl5hKvf8UP8fAPhGmT88GS7G9cg44c3Eq5+xw/x8/Ojblz9jh/i5xsJV7/jh/j5BYSr3/FD/HwT4cLv2eZmjR/e2u7Ghd8XGT/Ezy8kvvodP8TPLyJcrvHDuzNwVQkXfv9uwvWeDFw1woXfv4dwvTcDV51w4ffvJVzvy8DVIFz4/fsI19MZuJqEC79/mnC9PwPXDOHC799PuD6QgWuWcOH3HyBc3+7AFafb29248PtvJ1wfzMB1M+HC7z9IuD4Uucs4F3Xjwu8/RLi+IwPXPOHC77+DcH04A9cC4cLvP0y4vjMD14sJF37/nYTrIxm4XkK48PuPEK6PZuD6BsKF33+UcH0sA9dLCRd+/zHC9XEHrjh9c7sbF37/ccL1XRm4biVc+P13Ea5PRO4yfmPUjQu//wTh+u4MXC8jXPj9dxOuTzpwxelN7W5c+P0nCdf3ZPC1SHzh999DuD6VgevlhAu//xTh+nQGrv+DcOH3nyZc35uB62bChd9/L+H6TAauQ4QLv/8M4fq+DFyHCRd+/32E67MZuG4hXPj9ZwnX9ztwxcmi6HaJ77+fcP1ABl+3El/4/Q8Qrh/MwPUKwoXf/yDh+lwGrlcSLvz+c4Tr8xm4biNc+P3nCdcPZeC6nXDh9z9EuL6QgetVhAu//wLh+uEMXK8mXPj9DxOuL2bguoNw4fdfJFw/koHrNYQLv/8RwvWjGbjuJFz4/Y8Srh/LwPVawoXf/xjh+vEMXHcRLvz+xwnXT2Tguptw4fc/Qbh+MgPXPYQLv/9JwvWlDFyvI1z4/ZcI15czcN1LuPD7LxOun8rAdR/hwu9/inD9dAaubyJc+P1PE66vZOB6PeHC779CuP5+Bq5vJlz4vX07JXCVkv+2/vQP4L2/9Z5mrUT0rBz4DulPEK9++emsP/2DqFeuKB9ef/oZweu0yOM5x58RdH5G0FG4znjE9YhHXI96xPWYR1yPe8T1hEdcT3rE9ZRHXG/1iOttHnG1PeJ6u0dc7/CI650ecb3LI653e8T1Ho+43usR1/s84nraI673e8T1AY+4vt0jrg96xPUhj7i+wyOuD3vE9Z0ecX3EI66PesT1MY+4Pu4R13d5xPUJj7i+2yOuT3rE9T0ecX3KI65Pe8T1vR5xfcYjru/ziOuzHnF9v0dcP+AR1w96xPU5j7g+7xHXD3nE9QWPuH7YI64vesT1Ix5x/ahHXD/mEdePe8T1Ex5x/aRHXF/yiOvLHnH9lEdcP+0RF885ZsXJvSF5dsXJ2Xc478RbDMv0DcIjjrQ4vDLwnBWP9y3Ec7/xePHztxKuQeLx7idc+H3ReLxLCZeKx1P74B5ud+c9AN/xHga8kYT31uGNJCcpD/fB8bz0myDvNOUdhbwzlPdmyHuE8o5B3qOUdxzyTEa4D872R5qMXp+8H6eymQ4uJr+rAyZ1cxnLEeutlPI/inrn2OPENgBvpSkRnZMe6SCuQ+1n/5uOov7ycRmniA6/Yzr4/akUXGk3RT4I+QjfSupe3RSpYpPxqMlXOMpq35pOsV1bTH5XB0s1w/9oGPwNl/3FMnEbRNkV0S+kNRFFsl9Z9CQ7V9mQf9ZD7A/yxI0/UhDXuMgLUadnHOVWNlfxqsqR1jaRjuvU2kcdfCG8q382GWIf6VGGdZcMVR/fz6m1JrcrCY5vIVa+DuOK6Dff9FiO9Km1yraNp/BpdLPsOH5vcK4jLPLYDUVH8Wx08HwB6ydiH+GdtFfe9A6P/MBvba9pheAv3t3B+e4Ep9p3k9ZWSkAPzybgo2KMXtpRMdzvGfz7od/jEzwfpDJjORXPhhPPf0Ce+cZYg/8O8rsC9ZHS7zJau4hfrh8ui6oT1rsTQg4u2aKfgn4Mwn+8oJ+COsp+CvJk36qxHstB0XH1kydy0pkYkM6EoDOoH6LoKJ55TBUntCc/QPbE9A7tCX5r++ArBD8C9uTzDnvC8SnsO7GNZXti9NLsCeunwf+Iw54o3/zudjrPhhPtCfLM9sTgf5LsSSD/SdoTo6X6y8lIyyOK8vWXk0IOofvLSaJzxiMdxGVtRflybH+K+tb4Pfuyae3153domqq9sn+A8L9yUQfnL1J7RX03mSu94T7qjKDLbSaKesdncXLZsjMpuPL2UQb/Lxx9lGusESfXWNo154hwCOOa/ys7aKDedtnfqLfvfJBgHyHYMw7YtHFj/PzG5Dns2H5uwdoCzmFasrzHBc+Wh3t+X9/uwHEq028sU6wrH9/XwctwzA/K6fEUnMpe8Kn6VuYRgfdRwos2gOVl52xx+//3SVuI2/+/3qHxsZ7E6VsTfGHHr3NLXL+YuH5ZPpxU/Rrfcf3+swL1i3X4BOWhzeaz3dDWG45Y9l8nn2DY2lI/7aWIPFV7UfLkNQLVd6I8K4Tj0qkOzF+TvhsM9xdxsvZjbdbkNyq+jxP7fgb/P6DvuWi/pu9qb1Gk7QLKgc9kfDzSvKgyG+yeRE6mj9jG/Oljs2b1+CTxjLSfCkS7RPSiSM/zGv0pwY/xPSHyRgfgdaY2N1efba7OrC3Pzs/MtEqE33jldzxHqc6C2CXgTdZvCyLrxqo6EvqtINc4jULeU5RXgTzjMW5DF+/v5v+tgfjPI3+kPy3gb2l34IrU5bSgw2OOQXCd6RPX7qi7Dai+EH0b7gvRf8FzQOvQYSi76LJ1ZtvY7mM52Q6+iGwd9n8edaip/FG2dU8Gop3X1hn9qSi9bidE3iC2bnWmWWuuLcwsr641Wqtza6Wot08oi3ds65Te7hTwgW1FVdk6tmejkPck5aGtMx6VrQvTLzaqeeSP9KcFPNu6vHU5LeiwrRsE15k+cZmtQz+I/VS0deynPirKg7aOx2UzZJPCHH2v5wjZpiK/ccIx9KMgJ5Yv48F36DfjNzxnY/AvBb/9xVOaPyvDHYI/FVOE5XrZVDrcowIuduPNj3qgderuB5dOtFbvbq2caJ0qR5o9LiIXn4dTEcHFiW+EezP95ukbXru1LjjvjXD2H3GpqkPc3PXenIgsNmFXkwl7kGgtJv+rAyY1dOSuNswyXj33sMLoT0S9KhcifERNbaJ8uHsMsyxRr8Yzzjz1Hac3t3tlw3yYvqjj8Esp/628/I67CdRF1huXCUwzWW8Ek/XaqQ4824A8IVt5luLxHcIvUx4unZUc+Hka5D5ox3ZBqXJ1rBxhb/qp19RNP6hP6Eal6b+6vsHgXaFkcbKlBldokdIt1CXTEVXP9o1aDp8iXosu/U8JOqHb1BSVB/WYXbyiS49Kf7OW0I6mtMm0JbSbIB/hfw6W0I7nqE/VZgwucJupqzaDcs3TZlQ95GkzKMNpAf8t7e481B1eflR5/bYF/D6tzcXpSLt/Ovy9wYX1Rebm1NDEkhqacNvBZQI7BlUtyeCyKye1TGDljfVx//4OXoZjXrHe2bXHtmZ8K1vDoU5FbY1L904BHtXH3NPuhldhNkg7LczmQ9AX822Aqg0qvTR4Fcaq+jK1vM9hrIHCu5vG62PAJ8uX6aOOjgD8Yw549nkZ/+MpsjP4OGEd85I+bvNQoSH2LU9RfhLq+410M9vjjvKoMvP0piscuER/vOwUpzPtXvpq2Sj+W0x+VwdMXL+jQOMJIQ9e3voc9f02lVUWZVVyfVLQxelHk0mF4D8H9fjZ/d04jbfJSPedXCc8nc1t+WS7O389BA7GJT+cMu0RJ/SVvjSlaU9EWg+Z10cFr9i3PNXuzjf4nwB5/eB+zSvyo3hVbRQvZC7aRu8iXg3+K4426tIlZXM5nEK1UeabbVhevTD4fwx68XOkF2rcE8N9lWTNISNxctkHtqeLye/qgInrEtupspdcl/+MymXttyzKqur0CUEXp5XZPjxBdJV9MBrY5laAbpoeVwTPceI2Z/D/wtHmVN+v9EBtN1XtletkLAWey2Lwv5ZzTgL97TiNQp4/P6Um5yTQplba3eXOOyfHckJ4NX0+HWXbZA7xj9+hr2pHRHOI/5+AnfgdGu+qOTSmh7y7xmX4fZ45isBLJQslomflwHdIf0LIJMS8rrqW1KVDpwT/NjZV8EpHVb3F0yA87zENuIzudnh3ht6pcDCue+zLsC/6S7JBSt/UdhOWy1ikff+0rbn/IcUGsb01Gatx94NRbznUHBLb+KJX0qqwdUXngQHpqGU2a5+8dWwx+V0dKBUPbXyA8tS4QYWn2TxISdBRcx2o9z9UYK5DjTtd61p57FOceFsq1ge2V2Ur+B3Xu2rvobeATFN5XCH1RbcfqK3Erq0mgedBcvdB6CuyTEL0QWoOybW2ovzDRxzwLr8H4bEPMp5QJzHcOyLc2wGebRjXvbqGO7bde3Z2820yQB8Lv7Xrinnt8EOwpnBpgtM1961s+EWR5iWK8tlw/J6PWOGYBvXf6PA719rNRVSeU47yFLVN+P1G2aaLiE7a/MpB0pt+t1++BfTmeQ69cfX9rq1eIebOXceS9Esn79a181mn5j3p1P2gUy8hnVJjz/NVzo94pIO4eGsp+g48T6L62UcddFxH36TpzW07Nc28emPwt4DevDqH3qg6SDu+BeluVDzBZq0lIi7l8xi8Wvdz+WBKl9S4Xo2rTLfDhszXcsfSGf0J4tUvPx1/V10j+5iQ3Y6oM9Zbap2s1ecPtVZOPPaWU1wZhnA66hby44TQ4CP6zd/FTI0SzClBI054xgEqEg8G2aFm/Hl4yoLNyleN8LGUckZRvkaI36c1wrQ95ry3zuBbicHLu8cclafIHvMzKbyXRRkmIm1IcIEG87DMr3CU2eCPOsr8SEaZb6Eyp50Vhb8ZrizKsD3q1QHEoWS8O+rmvag+4fcb5azsJjppnfuj1LlnnRuxCvkI34DO/Qnq3JXzHbr8aefJYLlWASbtXINRgTNOHNxu8O9Kyh544kfu03DtbcAF8XfvzJaNq84N/iDU+fty1Lmr/ahzkly24px2ZGqtah4dR/rnvCPzB6VuIed1ZPg7lyPDsGmNelBHRvGUBlvUkcERQNoKbRTlWzHF7znCNMyqaL3KdYLRKtiY0g5pw8g81wiOV1EZP3cAuNFMyc46RZ55/TQ4MW848Oyzqqs9KfxFUb66wu83KgJ/D9EJMYsbJ57R2GhnPU0Hb0qes5ykHy3YYeIgAeF/c7qD8yeow8wTdY5yzbMTqOgMv6u95W0/LKNRgTNOaYdrfpUcqDArVTNV1yxeWOdtJnfnzw6divabEHkDHTQyt1arzs7ONdbqS/OtmVnuI41XfpdnRe9KAR92xqgpDxp5DOQap1HIe5TyKpCHK4O8+T6MY9ZczSN/pD8t4DmypeissQ9ctmFeDdY3y5blPXTf4H/dMaGhDn/Ffsu1g/M0facOs40T28Q4LSb/szRpLSMZPaufbYIXjjA32N8Gudx/oLss6gAAs1FlB41IvCtF6bJjGuoAglbUzdsjOXhTE0+I40QKnzEOdTgo63XRw0Fdk1ZI54oB6Vwh6IRc+UKaWf7YnxVckbqv3clH+H8C/thfkD+G/hxHDamJVddh53gQnZpAZXtj8P8Z2lWew87vA5xpepb3sHOD/29DMKHFZR6NOpH0aB9va3eXweD/XXIyRyz//7mzGM5XpeC8HnD+bUGcr07B+RzAaaeJKH28JOqmh7qu9J/bHH6Pu/ORF8/1u37hy0Nh8K9fDnJEyALLZPQHjZxEWht1Yocqm6ue8eIrXplWuI4UxDUu8kLU6YOOciP9KQevqhzsVyg6lwiZGPybHHwhvLVh1H371mSIF4p5lGHdVd94wZnR7+fCF5PbZQTHF76g7B9KwRXR78voXTnSF77ENnMl6c/VvMnFKTwbD/yO9R+/Z/0PYzPnZlVksSW1MwJ55FSm38h3XN8v2N3By3CIg/U47fJEZXPTcKi53Kx2HydcjLCynzx1/ETrzhNHziydah0+0zp2Sujv9qi7fKx3b6bfDxEsn9xhebyYeYR+H6PfxwU/nFgmmKYEXFpS7QPb40F47qd/wO8NTtHZOyCdvYKOC9dBgcvgjwr4vQLeyqHspdkAvNgxhP1WbQj7DKPfj/02uR0gOBtzjUTp/VeW/T5A79Lst9KVB1L4NLpZuqJ8BMaF4ycLOsG2XCH4VyV+eVh/dqFh9h19DJNZWJ9hoVEieiZvfIf0pwQ/xveEyBtkfro+36jV5p9ZQm9Vm9Wl1aqrLeM7bvvHBPz1At5kfTyMrOXhsMdArnEahbyjlFeBPOxPeH46jH1ayCV/pD8t4Hm+JG9dKly39InL5qfRxlvb3ijbFNamFPcneUdk3pOhcC6dk/JDrbyx3i4d6OBlOOYV64PnQh8S5XD1pfjOVVcGZ3WF+nIu1hW2PU6qrqy8ResK64Pr6k2iHCXKM374nauu3uSgs2NAOjsEHVefnadPVXQUz1m7Do/v6nyD9i5t1+Hj7U4+wv9LmI884ZiPRB4RdynSa2Fso+17nB93+WIG/0jCk5offxOVGcvJPGKZR0W54sTz4wb/JPmDgcYBcn7caIX1B4vbohLl4Xrw4XYHjpOyN1amuI7vzDFHwW0QeVN+yZsELh6nf5vgx8p5POrmH9tGnHjdF78/TriyTu7goHj8Ps8OJ8R1F+Fyrb1nnUpzD+FSGxQM1yMZuE4RLtfu/UczcL2ScLlOaHosA9dpwuU6He/xDFyPEK600/jivycycD1KuPB7Pm3vyQxcjxEu/P5JwvVUBq7HCZe6KELN5WO/lOd0nzCXXtQKXwa1Uaf7KLm7gtvfKnidFnk8x6kuinqroKNwHfGI67RHXEc94jruEdcJj7hOecR1xiOuRzzietQjrsc84nrcI64nPOJ60iOuBzziejPhUnEMyrbtiDpjobPrPTcvveXk6aOtiBL6k0YDfx9LoT8tvo8cuPAbV1nQ1+Q5LzzxS63P8sWMBv/LMAay08bUGhzy44p9CLymX8/brw5rbIWaz7Bvp0UejzOLrGkOquNxOtzW9Evi+ygDl/3GtUSDU/OsWFYe81vbwzkJxMExewb/W6DvfNJ51liM1wDUeAv7deNnV9RrL3gfhhpTqrl9XDeM0yjkedTrFXXyKMqn0s4vizix7Fy3p2Ddq5NHeC0A7Rz7VVl6ZXaUxwr4Lc6Jqbq8imiqtSF8x33aVaJsis7eAensFXRcuK4SuFz151r7VnHOYW+G6qx9q3at5gX6Wfs2uV1JcLz2reZaGFdEv6+kd1lr31inD6XwaXSzdAW/d+nkAwPSeUDQSbPxcUK/h+d1DX5n0reEXXudb7j2PYbdfzafe4097ZRJ5Fud6jjIGvvafL260lhrVWcay8sr1VWXzSh6AtE+AR82tnxerrHjnoY4jULeGcrDvhIvtOc19jB2cL6aR/5If1rA83ij6MmnPnDZGjv2Jda2N8o2hbUpw7vGjrEhRdZtsT543fa4KIerz1b+pKqr4w46Bwakc0DQUf5xKeW/0eF3TEfxnLVue5DGVFmnxT7R7uQj/JdgX9PzHDHR7Gtzm0AdjBO3e7y5ME//bvA3JTypdVu1N/OJdjrPRiPvPnODr5OPEehEZLlu69r3yvMFRfe9qrMChu1WOd6Dg3OwHEuBc6ocb4hzpDw/w3OemIdrRscoT609WN7bII/P6GhDHuooJ2Wb8XCy7yuwxq1uOuODtVC+KjbqWnjGPOOV37G+4fcPpXzHdiTwnpda4Da9vi9J7fnGMrHv3m9cENKaIFy+ZecqmyseCtfpeJ1N4TpdENe4yAtRp0cd5VY2QfGqysHjedXOrhUyMfgzDr4QXh3AttHzNUqGvuZrTG43EhzvNUMdPJ2CK6LfN9K7tPmarP3p3zatec57XpDBfwL8uGV45n08iGst6s5bg7yTyXPYNZ65uppXYdmdBNo8BjolypO3L7UyxXq1WKAvRb8JeUOcWH8PAwzv3zf4t4Cfe2qfxlmK3PParEN5zxAw+FMOX9tgRlPKdSQF59Ogi4+k6HokcKpycewn8/AQ8WDwT0C5bN0ziiLZz67B7xPtbt6OClpRyjvuC46m5LnoZn0bP78FnlVfz/r6MMHbunqaTFlXDP5dDl1RMb2u9WzmgWHelMLDewUPcT8xmeSvHH/LYylLoaPwzOZZVSVXwYMCT1oyMcTFe3pa47HfLvVTy8hRyjuuBvsWz+JcbR1tnUpbKx4hZA+kEBuJdMoTjzdscQOh4/Fc502gLFVcMscNqL1HRen0GzfAurCWQr8kvo/o25J4F6e4sbxz27PPaizKcx9Fx6KqcTCutDOCHmp38hH+e8EecbzBQ8CHwmkx1gav/GLXQcZZ40ven6bGKS7aKMs8c/ouXtVaD/r8HEuB/D1SkNdbNpjXhwrymtYurQ97xkgfOdM6ccfxUy1sKsxGRM/j9I5heNvCm1JY3UFwPO3NR6pxv8l90psFfyop08C8lKPsxPcM/Dg00af2ddNSJkRtz+AhHX6rhnRqWtblvqvLlhAHhzsZ/Fcc5idrKwWrvdou4boAVF0WpLZS4DLKWdztTp7BBQ53WlXhTljeSrtbFmq7h+s4U7WlQx2vPU3wKEe1NMTTtmr6Xi0NZW19eUVKeSsp5T3a7uQj/C859E/JRB3VbPBqK4u6fF1ti3mC8vA7XspH/TO4wPrXUvqH5WX9U1txEJ5lp7Z94BIHhi4jPMpRHbloNJX9wwvd7chFtbxdSvlvvPI7V2jBHe1uOqEuWbNlQW5PypWLn2+KuuGfBLrcnhS8yRmnWlT9VQj+30D7+2wSbsJTz3HC6cc/nNa0se2fFrwy7b+DaZ4/pilH5b7xUd5/Cry/+UD697wciv0OH4WedmQryh/LiXXONs7g/xL4fAuFRqAtwWn0OI1Cnkdbsla0L1N21dWXuWwPymw66tXTtHt1EBfKPM0PGou0D4JH6yP8/xDTfWrY9yjxfqIg73l9w9NQjh+lo2NRlry9SNWVsvvqeoMncuB61FHeJ4FnBY92AuEryT0/KHvGWYm0Lj2egnM74OSjtLNwrqbgnASc7Kuo/lPda2PwalsT9qnsj2AbeSvlIe/cbz4F9LlO39Dupq+240aCbuTgV4Xju/hl2255+/FC6uR5nPB5tosNV11eJ8qTty5PO8rPuOy70ahXX1UbekrIa+9FGmelIM5rQN+tf1W+zsPtDu39RFvZELSLbANPC77Q53Adec7+wfNEe920MWStVVX9LsqC+101BnPdY+Yac2L/Mi3gj7e78/LcdYd0+unX3p1yN2Aa3m9qd8O7/LH4eQnyEX7OYceVDF0yzxq3c0gr1sfjlKd0etj0FeXD+uqSRZyKjtdZX9Fush/muvIpS69c+opH6z9KfpgKpVZzCzylm6UzHOqMdlDBsw9k8K/K4VchD66tFnnnB1Qf91SkaWO7RZnwBd8Gf1dOe271EnYcVaup9oFy5fbhkmGcivqIJjPX9n7VPp6kPNRPbjt55wGz5nf4kvesI3/SrrhAnUEfcwnyEX7ZYet99688z6Dk6rIdw6bLw2Lreb5A2XqlfzgXMJ/D13jQwX/W2gbbv7xrGyeA/7O421FPuTej7jdybYPr3rW2oULS89qUu6kcWTaF5y0Nvl3Qprj0yqdNUXezb94843DrlcumFNUrVx+INugg+Y9nBK8uPXL5Z1l65JrnfiyFDsLFSW2jjdNi8r86YHKtyYS9BrE6UyJ6Jg98h/QnhBxDhH+pelXXqoW95rLajE2eWk97c7tXNsxHWnuytbA43QN4eOuTuuo3bk+fobkmNR+A3xoNng/4HMydfT/hzBuHkbW+viflSjnEm3aVIcp2LAUey47wP+wYAyr7qXTL4LN8OI7vyLu+fiqFjoolUP2ywf9kzvHhxqzZ12ubvWbPcySuNXusA14HUrqK7YLbgPLRVHv1HVbHPrjrKku1Brx5vlK9rnQFy8u64hqPxMnX3DDKUa2Hpl1diXTy+kr2bawrR5PKULYkzTYiTTUWVWMIjFvC8vyaY/1QjRvUOINx/kbBeWdXW8jr+yp/73HHd8rfQ1qLyf/sC3/zXQdstmZblO5DsJ3/XZCjXQes/J9ufgdLak6kRHJCu+nRNuS+zt3oTwhZhvBNlT+g2p3J58kg/NTW0DdF/UXfNO2oadMXNT5FX/OPqO9SNgDt6QsgH+H/DHzNP0nBGUWDrVP8/I5uvL7n6lzzWXn8PFfcAvtCaTEaS5CP8P8ZbIMr1mpDfMDa2qavEfA6gOvIZKV/qAs8J28yHIvccV4Vgv9bMSbJs05xpiDvjwreuZ1z2/mjHD5qv+sUcbI1bLYLY4mPkXdO0eUbhFqnwKMJzuJud/K21il65xQxbiLvOsUPkO1WsRZq7MX6mhaLexnkI/xzHPrnex8Ix0PlXSvZ9JiIaq2+2XPaVvd51krUnLYao2NMzjsT/Qspx7n56rpPa3WIx3FhGoV8hL8x0dcJKIf9H+hoyrml2lpjaW1pZml1tbmyxMdrxcnqLN5uF+vDdbs7MjM5+ZZZnAx/JQz+9fhH3J9eFmUy+qZLvO1b/Y8iPWYxWhOEy3PZaq6yIf88VzBK/NhzGq7RgrjGU/IW/ZR7vU7LjnIz/TR41Qbs/ZgDP8KbXUcdHiNZbAsji7qr3saAptHv5/gg+30VwfFxzyjvSgquiH5fRe/KkT4+iO3SVNRbbvsmsE3JfayC0Z+IgraHdTtQIX7S2i5uqz56fGk1Oe2ATR5XHYoT0XGxuerWu0V6x+rAJ2iYG6i6UOazJHAoEfDNciVBX5mScgrdKOqoK5uPLFz2XHbwkoajRDimHDi2ms5W0xFpq+nkazq+vfH6/PzsQn252pxbXVlbbTayvHHf9FeWZ5ebreWV2VpzttGsrm40/dZyc2FueWFlprpaXagtbHj555bmn6G+0FxqzlZXqnOzRUZDpvvoWXFbV17jmMA9Lb43OEWHdXibgw6bzFLU8frGIreHWCH40zCLwtEWY/CNlQMPnt6WwsOoKHOc+OBpg38MeDh54Nlna7dounF144ndbl7ZLo9G3bQN/h27OzjfSnqgvNvpSNsZzMO6NBlNRvnq3WQSRboeKwRvsx5p9b6dym3w7xH1votglAzGBX/4zqX/4ym4VJ3FiS/hNvhvd8z8TQj+yoI/g58U8GiTjB8lm0nKmyDcig6WFeuaD643+I+KsqrZRKO9GafKoAwr7e5y42lGZQHP9TEl4HcAjMlsmuCxblQbnaQ8pDtGPCgbj3rJKzNqZgBtlHLPUQbG57gor7+6W8l9ga/RnyBePetSraiOmHymwsin6tLBKSEf42dnEH6q65cxTQvaxmuy+NdlVxB+CmSI8Phs3+O7r5C+7oLvDP805cXJTqspibyyeDeySbimBS6Um9Vp3I6/SLLgE9rUf8PL75hHrE/TeZeN6JcO4jI/SrWn+G8x+V0dKDXWD73eKcphtFGv/LWdmbm8ts7oT0RB23LNpcMoH6s31fbt2+moV4ff3u7AZek30lG4PjGkuN7vEdd3esT1MY+4fMrrQx5xfcQjrm/3iOspj7h8lvGjHnH55Ot9HnH5bI8+6/Fpj7h8tqHv8ojLZz361NVPesTlU78+7hHXpzzi8qn3w2pzfJbx0x5xvc0jru/1iMunvHz6Jj71a1j9Qp96P6y+3Hs84vqwR1wXgi83rHrv0zfZ6tOK4RpWX25YbaFPX86nLfRZjz7lNaz+V9sjrmH1vz7gEZfPtu2zDfmUl89+yGcbGlbZ+7RfPuflhnVuyKd++fR9ferX+d53xM+8ZuWj79iVghufXWvDik5J8KzWlEcAx3jUW16f68qGf3cg/Fbui4SssExGn9eYLV/9N1ycZ7QmCJfnstVcZXOtReO6O8ogDddFBXGNi7wQdTrtKDfSn3Lwqsox5VEmFY+4ODZItX+1fmvwuwW80pNdgrZ9a3W7B/I81m3dVbdoI4x+P7uMTG73EpxdCDkS9baNi1JwRfT7XnpXBnyYNsq+82+LrcGYXrv1dvNiJGYbJaJnZY6oXOdLjMQ72x24QX2G7/GIy+ccvU+/e1jnM3yW0eda8bCu2wzrHNd3eMR1IejE1prG5snep7x8zgn6LKPP+YxhXZP1OcflU+8/6BHXsM73+9SJLf/r/LDRPvvad3vEdSHYwmFdM3uvR1zf7RHXsM6r++zTfPo5F8Ia9oUQP+CzDfmUl08bvdV3nB99x1a8xebpxLD2HcM6p+CzjD73JAzreMin7H3GUw/rfKFPP2fLTmyeP7FlJzZP9sNqJ8z/4jXiOC0m/6uDpXpEdHkdG+lyvIflI49h4o0ayyWiZ/LEd0h/gnj1y09nHVvFfqi4E5PdHsHrNOXF6V3tDhznlcW7EQeu93jE9SGPuD7sEdf7PeJ62iOupzzi+oRHXB/1iMtnGd/nEZfPMn6nR1wf84jruz3i8qlfPtujT/3yaQt98vURj7h86v2FoBMf9IjLp359l0dcPsvoU/Yf8IjLp95/3COuLTtxftgJn2X8lEdcPv2JYZX9pz3i2mpDxXC92yOurTa0ebL3OXb3OUa2eS6bI8E5lVLyfyP2xyA9Kwe+Q/oTxKtnfmouue4WcjXZXSx4nRZ5fE49yhXL1E/dqv1E/Fvtl7HzW8eJ3zgtJv+rA6XGjMnpEuIL6V4K7zdDx4z+BPEaSscuJX5YPqxjlwlep0We1d+uqFf/WMcuFjxcLHhQOmZw4fSm2uDyqnlyLi/K4hIq72WivJc5yovfX+ags3tAOrtz0glRnnHx3WLyvzpYahru5wyOe4ZfWLvAewnwHov/enG3rPCeijJ9WwJZVQj+Wy7p4PwfCU6++yaKeu3ZCLz3Zz/y3wBv9CeI11D2bIT4YfmwPSsLXqcpL07vaHfgOK8s3rlwfcgjru/yiOt9HnF91COuT3rE9X6PuD4+pHw97RHXUx5xvWdI+fqER1w+9d4nXz5l/2GPuHzWo0/Zf8AjLp9l/LRHXG/ziOt7PeLyKa+PeMQ1rG3bZ99h/oT5/eg/2l0m6v40visL74hDHJiH/LluqcbvR1O+43KY/8t3/S0mv6uDpZrh3x4G//p5PFn3BBp9dZ9eKeW/4eI8ozVBuHzLzlU25J/1AMfbfG6PwrWtIK7At32v16nr/jGkP+XgVZWD74xU7awkZGLvtzv4QvhdgrZ9azLkOwYXk9/VwVLdJUNsi0a/n7OMTG5XE5zdCzcS9ergthRcEf2+mt6VAR+mXYRD2VFuz2n1O53yfZxc9+dOie+sfHjf5eWQv51oXC54vNzBI35vcIpOaUA6JUGHcak5mjg91O7kI3wrmaNR91ZeIfhztcUrBfwVAGP8KNlcmeO7OE0JWsaTteOr4L1vW4j0jF98h/QniNdQfdJVxA/Lh9vGXsHrtMhju7BX0Nkr6ChcVxAPqFsbVH/1fuvvijD8OOvvCiHXovW3i+S6N0g5ai3j67lRb7K8q4E268I1kIdthVOZfmOZYvt15kAHL8MxP6hjxtu44NWfnOpVLm8k+NoH7z7T7uU/csjiapDF0wVkgfq9j/KwPvZTHurTAcp7LuRdS3nsT6j/UdTbNuPENsalV1d4pIMyupLoXOmRDsp7L9HZ65EO1p3V1a6ot+6wnXAbL4t3TOcqQcfKg74+rj996hJNE30b/NbO66wQ/NK+Ds7PJDitje8Dvjy28fX7RfdHvcnyDgDtqynvWshjfT4IeayD10Ee1i0nZTdMFrHd+EIBu3EN5HH7d/Xvgfyh3P270d+o/t3lF8fJ1b/bt6rd8no3yhXLlMaD8hH7tXdhfYz8dWv0N8r33ptTrsoP2ksyxzyOzVC+tIsHl19+heBB0blyQDpX5qSzVZ7hKY/1oWb/n0g607gP/dVLumGmE5iPXtmB+X8IxuLn/tFzOjC/QTAWo/TbEC/yteSZ+744HWt3510HeXdQ3vUiL8Z/ScKPyfWGBCZ+5vmgGwBHWbxzzQfdkIJrFHCNAy72ZQz+r8l/eT7g9WfXZudMbjcCT2zjXxCIdl4bb/SnBD/G94TIGx2A17WV+WqjOju72pptLs8010qE33jldzxHdpOAV+eIm6xfGAWRdX393o92B/9NINc4jULeCyivAnnGY6z3F+/v5v+mQPznkT/Snxbwd0EZitRlSFxoD3zg2tYnrt1Rd3tCmxPWBtWXlQ2ypNo8rydiG7NxZUngUmMhK1OM8xcLjIXQziNvXA7Vf9gaza6oV643Eq4XZOC6hXDdKPiaErjYxodpt/n9eKOv7HgIP17ZZdUuTHYvFLxOi7wbN0Su9RbzhcnyXgS0UZ6cVLswvuN28dcF2gXqH9JPkznqstnUXVG6XefvuL3l8WcC6XqzX12/MQw/Tl1H+fSr62i3WBfL4t2IA9cNHnGZ3ihfn/cfFPX1dwuew/rJ9VXVz1lSdXYj5b0opfyclB2wMsV24G/77B9fSHmb0A/NXkj9UJzsbqdB29OFhku1tVLKf6PD75gO6jT7ZM+D73BN5Bsu7XyD3+GaCH57T7uTj/BfhHmYlyU4lV00Hq0dViHPn943albuWtSbLK8OtJ8Dz5yUvTK+i66JYjuvUx7WX4PysD02KQ/t7gzlVQU//eoX1lUen79fOsofC91euO94oUc6WHdWV7ui3rpj3+RFRIffMZ0bBJ2s9v+GSzXNtPZ/qt3JR/hPQvu/P8E5Lsq4mW28SnkNyGN9bkIe6+AM5GHdclJ2w2RRdE0U69bKFHYur77G9iUSfKF94fnzGvB1DTxzUnLCub9Lru3gZTjmB20H1ze2d+NtV9QrQ54bKdrf3yjKoejsHpDObkEncJurqnq3pOqdxwj1lPJzymo7RcYIKPMa5bnG72FkmH+MYPQ3avyu+hvX+L0qeGVfIU7sP1cFnaqgc6HjUva3lPLf6PA7poM6zW0zzUf4CPkI9l3eMYLBvxd8hI/TGEHN51k7RJvh0ZY12A/ApPyAomME47voGGFQXz9+nqU8tMlzlFcX/PSrX1hXG+1Th24v7E+EGluxb6L60xLlGR1+5/JNuC9Ma/9fvlTTzDtGMPhHof1/hcYIWMbNbOM8Jle+vuXNQh7r4BzkYd1yUnbDZFF0jIB1i2VC3kfhHY7ZX9t+9n+F4P9pUk9xnf1fl3bTex7QMNpn55Qu64ZT7THs/E/+PTVGfyLqbe8hfCzlF6gxvbLb9u20yMM9k/3YBWVjhm2OjuOWcfyO9cYpa/7uTJ9tjMfhyI9HOTXZTkWCrxl4V3R/RwNkUcRPCemLxM/zlNcQ/ORp53FifVe6c775D6p9DUoH687qalfUW3fsp9SJDr9z+SncJ6MfiX7KX12qaaKfgt9yTKTBt8BP+Tr5KYHGIoXaOOpvv76I5c1DHtYtp6zxzRf6HN9gmZD3vH7KevtKfI7AfkWV56yUTLf8nfD+zk3wzDauqL/Dc6fD4u/w/pjN8HewrW75O528LX9H07lQ/R1sJ5hndLL8HdXO1BoF+js3XaZpor+D36b5O3eBv1OlfjTM2uK56e/gmmS/8zJsN7LmUEpEO80vurP97H+ev3n5ZR2cL7ssna/nAe2f3Zq/4XROzd9YXW7N3/Tyg+1ty5/p5G35M5rOherPYDvBPKOT5c+odpY1f/PmHP5Mnvmbl4E/8xbyZ7bmbzowmzF/w36Kwb91iOZvXPsGAvkXuf0djgkKvW9AxQS59g3kiQmKn2+CZ7alReJlUB+HKR4yfub5G2yfRffJ4dijiL+DcjbeAq+519kXiARf6AsU9Xdwfbzf2Hvf8fVow0P32xsVe3++xu/sivzbI9XOeMwRJ/R3vniZppkWV8P+jsG/APydH6N+FPnarDaO+st+ktLnojE3ee2GyaKov4O+LNuNrDkUqwf00zzWw4LxsRD1Jst7MdDGvbSclMyM71hm/6bPOPwXUx7q5EsoD+3CN1Ae1vdLKQ/b8jdSHtrOl1EejgcWKQ/19+WUh/r7f1Ae6u/NlIf6e4jy0M8/nDwPm/5wW30J5N1Eed8AeUX3yaDevei6Dl6GY15Rv43vHVHnTLsHWqdubz1279LRI6tLp44cP3ZX6+HTrZOnRgktd6k30e8XprCLeCIHu3EaobznU74dKzUS6TQlvjMapjYL8H4zhitGfyLqrZ4Qw5UF4oflw8OVFwtep0Ueh7O8WNB5saCjcJmuqNB3vk5QHfFyo4POJYLnYTMhl1AempBBuqd+w/iMt3HBj0c5rbBZjARfL4V3RYdFLwFZFBkWocy5W0Wd4W4VbQt3q1jfi5T3EsFPHnsSJ9Z3pTsuu9gvHZQRT2vPe6SD8l4gOgse6WDdWV3tivzbPdXOsoZFo8/pppl1JAEPiwz+chgWbUuexwVfm9XGUX8t7xshj/X5ZZDHOrgIeVi3nJTdMFkMMixiu4HHaj7c7s7DI6VvoO+uhzwcTtmxmga3H+AOEo4DkHcd5eEx2NcD/r9I1iZZh64EHbqB9BJ9QlffbPBqe+9NorzqWCqe4gw0rB8q/bW8l0PeIMeLPZZjGKHqWR2Nh/bHjtlT7eIFgNfsGk/fvBB07BuItlp2Q71jHWsIeLWsp6bA7Nth23bJU0c4vObhKA6veeoIh9c85Yj9LsqEU9YyWl4d43pW0415dawKeG1KkZdEXw469hqi3cygzTo2I+CxvvjIA9Qj+3ZcfOdRx2amBK+WlK7wtF5RXVE+Mest+lUoE05Kx0xORXTsNTlsCfZJrGMqJBGX6VnH7gEdW86hY+poi7w6Zv3slo515220ji3n0DH0iVjH1DYfDG1lHXsAdOx0Dh1z+WNbdqyTN8w6djqQHePtYsp3cumP0jdcMmBfC5ch7NthCj1E+YTwp1y6lVd/MNQxj/6UiI7hxfqJk8u/sm/VUQg35sTr4sPVDypdV6G+yp/n8D787kUpdNK2DvCRDgb/HUnbxGs+rT7wCgCjbUfQj0Kex3WA2ZiPNvDBMqy0u8vtGi/FqWibN5lNR739Aod/Yx1wu0vbFvCRlKM4kJ8bHPwX1SfF4zCFDyn7kje04CbKK2rr8tosDFcqYrNU6F1em2XfqiMe885nuPhw6Zhri4TSMeyfOUQHv7sphQ7aLCwb2yyD/3JOm4XHUMVpFPJC2yyUIdss1eZVaFLeNm8ymyZ4rJsiYU6IE48YtjrF+d/txOt1US+v14myTYvvr0vBlfdKJIP/HVorwDlpf/XeuRIJ257ZAaN9QyDaJaJn8sZ3SH9K8GN8T4i8EFci5T1C3+CfL+B3Cviwa0L6SiScG4/TKOTdQHnY/nGthq9ECnR1Vz2P/JH+tIDna4yKXocQAhfaAx+4tvWJa3fUaz/N5myUzQxr6+rzytZZUraFr17Ctlz06iUrU9Grl9Q6ZUmUQ8mcr15S65ouPUFctxCu5zn4en4GLr76RrXfKfEd90uB4rhyX21j9Cei3roKEVeWJVeOK1PXm6mYCNQLzEM6rngvFX7sA5fphdLf3UTnekHnegcd/N7gwvo79SVlRyypOuO4gReklJ+Tsj9WpqLHVqPM+ajeG8S3gdtm7mOruW2GqVN321T9bJG2GSc+0rnf9nSh4Qodf8djEow1wjiyiy/vfIPf4XwBfntPu5OP8O+Aa4gvS3Aqu8jXWOJY2aMtK3wlX9FjqzFmpkgcqev6Eaw/njdwHUmc57oc5Kdf/cK6Shvz+qDj8rdCtRfuO270SEddA6ri19jPKXr17PWCTlb7b1yuaaa1f54vNPgT0P5nE5yBr+Ir3MZ5LhvXgVifce6PdTDtCE9Oym7gFX5f6NPP4aP/w8zJ1FfYvkSCL7QvfLUNzllfA8+csuJti1xto65RU/aV4xaUX9tvf3+dKIeis3tAOrsFnWG7/pLHCJtx/aW6aijP+D3QsRG5xwhGf6PG76q/cY3fbxK8sq8QJ/afbxJ0VLzuhY5L2d9Syn+jw+9cRxdw20zzEd5EPoJ9l3eMYPBvBB/hGI0RULeNx2G7pqvoGAGv4nq6T3vVj68fP/dzdAfy069+ua5OCu1Th24v7E+EGlu5rsNj36TodXjXCTpZ7f/pyzXNvGMEg78T2v+30xgh0BGqhds4j8mVr6/ia/JcjZnXbvR7hCrWLZYJeccjx3DMzkfGG/ynknqK6+yTl3fTOwg0jPbZOaUruuE24Yrx3Hvvjf65fMV4/MxHo/Z7/TbW5bDN0fHRqDh+H2TP25k+2xiPw4fhCNk4Fd0Tj8fEbl3TvXVNt4tO3mu62U9R8ZEvctBR7Uz5kein/PLlmmbeo94N/qXgp3yV/JRAY5EL6pputZ+pRLzn9VMM/neongL5FfJoVJbplr8T3t/BuVy2cUX9HZ47HRZ/h49G3Qx/x3Xl8Ja/s+XvbPk7ve0E84xOlr+j2hmPOeKE/k7lCk0T/R0V18j+zvPB39me4Ax8BtA56e/0ewYQ+rJsN7LmUEpEO80v4iPjDf7yKzo4L7sina+DQPvDW/M3nM6p+Rury635m15+sL1t+TOdvC1/RtO5UP0ZbCeYZ3Sy/BnVzrLmbw7n8GfyzN9cBv7MK8if2Zq/6cBsxvwN+ykGfy/V02bO37j2DQTyL3L7OxwTFHrfgIoJcu0buEnwqmwcz98ov+omQUfh4vmbYYiHjJ95/gbbJ9Ybp6yxRxF/B+VsvA3TFUBxKurv4Pp4v7H3vuPr0YaH7rc3Kvb+fI3f2RX5t0eqnfGYI07o77zjCk0zLa6G/R2DHwV/5+9RPxpmn1vxa77Yp8X4FNbnojE3JcGDshsmi6L+DvqybDey5lCsHtBP8+h3zhofs1Fvsjw8lwf3v3JSMjO+i15tg3aErz91nROPdoHPOL4Qr8sZNv3htopn2PE+GTzDrug+GdS7IlfboH4b3zuiwlfbcJfK285uTGF3kKtt+NiHvFfbuI7GweO6NmO4YvQnot7qCTFcmSV+WD48XJkTvE6LPA5nmRN05gQdhct0RYW+89U2RY8tuUTwPGwmhK+2QRMySPfUbxif8TZMVwDFqeiwCK/5KTIsQplzt4o6w90q2hbuVrG+067LQX7y2JM4sb4r3XHZxX7poIx4WnvGIx2UN9+UOuuRDtad1dWuyL/dU+0sa1j0ezQsyjqSgIdFBv+fYOnzD8gdD7OVrvg1X+z+4lVNrM94UyDrIF43gnXLSdkNk8UgwyK2G/sBnq+2OQDfXU/f4dUzOJz6C1qS3gtw+wnH1ZB3gPL2Qd61gP9rCULWoa+DDpWu7Hwb/+U97sjg1fbe54vyqmOneIozzLB+uPTX8vC6nKLTpjjkz3uUOtezOnoM7Q8fMXtQ8It2jadvxmD65mKirZbd1FWNBl8V8GpZT02B2bfDtu2Sp45weM3DUXXMtBpe5znyOK+O4TJaXh3jelbTjXl17CbA+w7SMePtctCx64l2LYM261jWUbl85MHW8djd/g/LhJPSsaLHY6t6VrYk77UjeFT24RQdewHo2Itz6Jjr2ogsHbN+dkvHuvM2WsdenEPH1JGfahyOOlZJ0bGXgY69OoeOufyxLTvWyRtmHXt1IDvG28WU7+TSH9cR88rXwmUIvOqDv9vMsCQO1fLpT7l0K6/+YKhjkWsiVDhtXv/KvlVHIVyXE6+LD1c/qHRdhfoqf57D+/C7F6TQSds6wEc6GPyDSdvMuiYCr2aN0yjkeVwHkNdEoAwr7e5yu8ZLcSra5k1m01Fvv3AT5WEdcLtL2xbwppSjOJCf6x38F9UnxeMwhQ8p+5I3tICXK4vaurw2C8OVitgsFXqX12bh1SKNlCNes/C6+HDpmBrLosxYx7B/vony8Lu0EB20WVg2tlkG/3ROm4XHUMVpFPJC2yyUIdss1xXZcSra5k1mriOcioQ5IU48Ytjq9ADA8TUNB6JeXg+IsqlrGg6k4Mp7tY3BfynRD7NzOCftr947V9tg2zM7EHadIv/VNnxEnAp3UscThrjaJu9auMGrI/d3CniTdZjYBH21Da57xGkU8q6jPGz/xqO62ibQFUz1PPJH+tMCnq+jKRrXEAIX2gMfuLb1icuutkH7aTZno2xmWFtXn1G2zpKyLXy1DbblolfbWJmKXm2DMud18INEk2XOV9uodU2XniCuWwiXGhtMCVzcl4SxD9V63r7E6G/UcbbK/ruOs1VXS6n4j4MbItfi10GhPDmpdoFXPv11n+v+fLWSkjnqMl+tpPoP/o7bWx6/KZCu5756iXX9YBh+nLqu1vCK6jraLdZFV3ylwnXAIy5e/0HcfKx60f5xt+A5rD9en1P9nCVVZwcp74aU8nPKiv/52z77R4712IR+KPex6udDPxQnPnK83/Z0oeFSba2U8t/o8DumgzrNPtl++A7jHP+G1rXUser4bdqx6kee28H5dwlOZRf5GrlAW8OWed0Nk+XhvF7RY9UxpqtInLM6Yp51IX7meS1sj7wWmuc6J+SnX/3Cusrj8/dLR/ljodvLRsVt83WNWHfsmxS94vaAoJPV/q+4StNMa/88n23wr4f2vzfBGfiqyMJtnNdacJ2S9RnnplkHcW666F4RvGLyC336ObgmwDx4lO8C25dI8IX2ha9ewjWVa+CZk5ITzjEWuXoJbQfXt7qmU13Vy3MjRfv7g6Icis7uAensFnSG7XpWHiNsxvWsKHNeU3WN38PIMP8Ywehv1Pg9a02Wxwjqqk/2FeLE/rPas6DiyS90XMr+llL+Gx1+5zpag9tmmo9wF/kI9l3eMYLB3wo+wusSnGo+2Xgctmvkio4R8Kq4fvdC9uPrx88cg5nnaBnkp1/9wrraaJ86dHvZ6GtgVWwK+yZFr2s8KOhktf+Hr9I0844RDH4O2v8pGiMEOi6rcBvnMbny9VX8V56rW/PajX6P+FXxoiXiHY/EwzE7X2lg8O9M6imus7df1U1vP9DAfZJ/Q3Cuo+zCzP/kPxvC6G/UUXbKL3AdZXej4FUdX1WB537sgrIxwzZHx0f34vh9kD2Z/R7dy+Nw5MejnAodcRynomc23ASy2LpGfusaeRedvNfIs59S9Bp51c6UH4l+yk9cpWmin4LfcuylwV8LfsqXyU/Zuka+A9PvNfLou2OZkPe8forB/wLVUyC/Qh7dyzLd8nfC+zs4l8s2rqi/w3Onw+Lv8NG9m+HvYFvd8nc6eVv+jqZzofo72E4wz+hk+Tuqnak1CvR3/jyHv+M6o8rgLwJ/5z9SPxpobfGc9HdwTbLfeRm2G1lzKCWineYX8ZUG637u3g7Ov7sqna/9QPvRvd1wW/7MuTV/Y3W5NX/Tyw+2ty1/ppO35c9oOheqP4PtBPOMTpY/o9pZ1vzNC/ZqmkXnb/4O+rwXJc9b8zfdCWWxkfM37KcY/EupnjZz/sa1byCQf5Hb3+GYoND7BlRMkGvfQJ6YoPiZ52/6jZdBfRymeMj4medvsH0W3SeHY48i/g7K2XgLvOZe6IqqOBX1d3B9vN/Ye7a/IWNukJ887TxOrn57o2Lvz9f4nV2Rf3uk2hmPOeKE/s6RvZpmWlwN+zsG/x/A3zlK/WigfcGFr6FjnxbjU1ifi8bc5LUbuNf4C32OGdluZM2hWD2gn+avHhoN46MR9SbLw3OjcC8tJyUz4zuW2b/pMw6fr+dFneQzuNEu8BncWN8XynVOw6Y/3FbxjEXeJ4NnLBbdJ4N6V+TqJdRv43tHVPjqJe5SedvZ81LYHeTqpWspP+/VS9cKGqY2eJzcZgxXjP5E1Fs9IYYrDeKH5cPDlabgdVrkcThLU9BpCjoKl+mKCn3nq5fUES8HHXQuETwPmwnhq5fQhAzSPfUbxme8jQt+PMqp0BVVcSo6LMJrqIoMi1Dm3K2iznC3iraFu1Ws77TrnJCfPPYkTqzvSndcdrFfOigjntaue6SD8uabfBse6WDdWV3tivzbPdXOsoZF/4SGRVlHEvCwyOB/G4ZF/5zc8TBb6YpfQ8fuL14lxvqMN1myDuJ1OFi3nJTdMFkMMixiu7EX4PnqpbxXI+Fw6mu0JD0KcHsJx1WQdzXlPRfy9gH+G6959pl16HdBh/6U9DLvcUcGr7b3Xi/Kq46l4inOMMP64dJfy8PrnAY5XizvUf9/mmJ/jAbbHz4Ceb/gF+0aT9/8BejY36QsgSHtQY49Zh1TR+kO27ZLnjrC4TUPR3F4zVNHRY/kzqtjuIyWV8f+JmXqz2gU0bHnA94jpGPr+gMhXjuf2037hRm0WceyjnLmIw+2jm/v9n9YJpyUjhU9vl3Vs7Il2CexjqmQRFymZx3bAzq2L4eOqaMt8urY1hUBw6Fj+3LoWD/XBVhoK+vYdaBjzRw65vLHtuxYJ2+YdawZyI7xdjHlO7n0x3UFgvK1cBkCr6Lh7zYzLIlDtXz6Uy7dyqs/Jqe8+lMiOoYX6ydOLv/KvlVHIRzMidfFh6sfVLquQn2VP8/hffjdDSl00rYO8JEOBv+apG3G9eG6xgSvDo7TKOR5XAeQ15igDCvt7nK7xktxKtrmTWbTUW+/wOHfWAfc7tK2BdyVchQH8nPAwX9RfVI8DlP4kLIveUMLeLmyqK3La7MwXKmIzVKhd3ltln2rjnjMO5/h4sOlY64tEkrHsH/mEB38Li1EJ+91cQb/cE6bhcdQxWkU8kLbLJQh2yzXFe5xKtrmTWauI5yKhDkhTjxi2OoU53+3E69XR728Xi3Kpq4RuToFV96rlwz+E4l+mJ3bB3j91Xvn6iVse2YHjPaBQLRLRM/kje+Q/pTgx/ieEHkhrl46QLxm2aFrBbzr6qUwa0L66iWcG4/TKOQdoDxs/7hWw1cvBboirJ5H/kh/WsDzdUl56zIkLrQHPnBt6xOXXb2E9nNf8rxRNjOsravXla2zpGzLdsrDtlz06iUrU4zzFwusb6p1ypIoh5I5X72Ect1PuA5k4LqFcO138HVtBi6++ka1X46bYriKwJ1GG7+7mnCEtVvFr/vaR3lqbVbNKXEfiT7rGDxzUrqK14T9VIGwR5StlWk86i2jR/kWui4mTnw8OMrpGnjmpOSE18UUOR4cdY3HeK4jaIflei3WUZzvYR1FH591FH38ojqKa+pFdBT1kOefjHfcNoj2xI59UnbrCsJVtA/H7w1O0blyQDpXCjo29rDyfw3WN34jeeaYGpTl2Tmhq7vhkAerh7B6nD8emK89CjO+cV97pOpI2XXXlWR8XEO/VwJhXaq4H9ZtNXfjuhr0CkFn2GwaHwuBNg31g1OWbSoSD6xs0zAdnxGnovHA/V5RhDI/l68oSpu78EEHZXQhXVGE7QTzjA6/c20v5TXDtHjg8tWaZt54YIO/Y18H51iCM+y2fr9XFLE+D9sVRepqM/aVsvy7CsFfTPUUyH+Rx0KwTLf8qvB+1aBXL+X1q9iXL+pXXSnoDJtfxcdPbPlVW35VHnsSpy2/yg+dYfarbvbkV71kXwfnLdRfB5p7PCf9Kpyz7HefFdsNnBPC/VJ3Ud1m+V98LJfB33d1B+frrk7nay/Q/jWC4730cRpWvyn0cVohruGOn33OR1ldnkvzRIPsCyviz2B7u9D9GTXeOxf9mY06TutC8mewnWCe0cnyZ1Q7U/4m+jPvzOHP4Ldp/szz9nVwvvscnCdifT4XrrIuEe95/RSD/+gQzRO5zuMJ5F/k9neM/kadx6PmVVzn8VwveFU2jueJlF+l9kkrXKaPYeMA67Oqf4kc5ef5G2yfRc/JwbjBM322VeNtmI5ZjVNRfwePUu33nBy2v65rVQf1k5CfPO08Tq5+e6POyeHrpQ96pIPy3mj/bVeUbkP6tUeueS88SwX9nV+4WtNEfwe/ZX/H4C/Z18H5T6gfDbOOUPwoZfZpMbaJ9VldQ+jyk/LaDZNFUX8HfVnXngk1h2L1gH6av3poVI2PatSbLA/3Pu2DZ05KZsZ30eNDUe/4ignXWVxoF/gcmQvxSNJh0x+ea8V9wtyOcZ8w1iunLL0rcnwo6rfxvSMqfHwoL4lwF3swhd1Bjg/dR/l5jw/dJ2iY2uCWyM0Yrhj9iai3ekIMV6rED8uHhys1weu0yEMzj3lIpyboKFymK2o7AB8fqrYp7HfQuUTwPGwmhI8PRROC+sEpy0z0e4uU8TZMx6zGqeiwCI9SLTIsQplzt4o6w90q2hbuVrG+044kRX7y2JM4sb4r3XHZxX7poIx4WvtFHumgvPk2iqpHOlh3Vle7Iv92T7WzrGHRFdd007S+OO+wyOBH9nVw7k1wjgu+NquNo/5aHh6Hy/qMp7GzDuKRjli3nJTdMFkMMixiu4F+EB8fmvd4TxxO8fGehn8xeT9O+DzX62oeXyuQTq3maeNIX/VxxveEyBtkq3e9tbwyu7S01lhZq64srbWK+i3cxhH+IgEfdsthY8n0Hrd645AnTqOQt5/yKpCHWwF5q3eYaZnGUh75I/1pAc/HhxT1QZHOtqg/XLaleh98z7aCx2xxCmsH8o97jP4E8eqZn/Vxj9pCPirkOuWQq/J1OCxln6CzT9BRuMzuD9tWdQ5LQduC9cZJ9aVWpqLjEbVVPfAUblMtHzBfOM9RdDyC061FxiMoc57+VdvhlE7zFDzaJJ6K5rke9T+Kioe/jqaUywcdlBHr7xUe6aC89xGdfR7pYN1ZXan5ET4iqGjfdLWgkzUeOXqNppl3PGLw//GaDs7jyXNY37FYG0f9VVPurM845c46iFPuWLecfI5HsG7Zbrh8BdTxzfAVjP5G+QpXED9FfAX7VrXba+CZ7UNRX4GPtQnjz9VrypZFVH5smxzSoex9Xj23MhX1FVBfeY43kB1pqL6S+UIbU9RXwDbfr6/Ay0+4xYvtgTpupYgfgfzkaedxco2TNspXYP290iMdlDeP1a72SAfrzupKHdPERy/sIzpZ9sjl+6T5Cp+7RtPM6ysY/O9d08H5heR5nL7fzDaO+qv8CNZntXVT+RFYt5yU3TBZFPUVsG55bdd4rwjYyynPYL9yzbP/4/r6neR5V9Tb/nZE3XmXQ94kPCNd1J3Lo056qK35/IfXPPs/lslbDmicIyk4TR/VPJiVYzz5Pwp5/vRwpaaOU0U7VWl3lwnbU1nA81yjmivBNsU+DurkNYRrVOBC/wqP+D0L0+58bzxuhjyRxzzyRPii8jQZKXleRbiuFLhQxi55Go+bIU/kkeV5VUaZWJ5K/ignk5HaavFcwqV8fWzvPNdruMcEPNskhP9/r3n2fyybR/Z187cDvmddmBS40Ya62tmEKMcU5eG3Md7/enE3/wmr0b++pgPz50RbrU242kPWMYpWX8pnsW+Hae5P9fV55wVcIfDsI6pj8vL6ATjXmPdaEq7nfUSD2yLr2F7BL/qAPP/zn67pwPxvop117CfrmLq2An0z1jEca/C1wsNyfCfPPaEesY6hHvHcU9HjFvPqGK7n5dUxrmc1X5lXx/YDXpuT5JiH0X0dmN37umkrHXOtyRbVMbRVG6NjwxVvYXl4hSbKhJMvHeN6Vv1VXh07AHgtDoe3G1wGOnaQaPu+aoJ1TF1fEHhr59KU4NWS5WE4OK8vYTg4z1HdBHk8R1X0GpS8OobbPvPqGNez2h6TV8euB7y2BYa38D4fdGyeaN+YQZt1LOv6DNPPrStzuvM28socVc9ZtoR17IDgF7eVs469FHTs9hw6po75yKtjvKZ5rusY+2rnio7dnkPHVCyUWgtCHbs5RcfuBB27f0vHLggduz+QjpVJx2yuZwV07GGifY2gjfNRrGP7BPw1AGPjsF3EA347Lr7bzDVbnmfAfsIV+8VzFzgfspfycByLMuGkdOya5LmIjnE9P5doYF3FiXVsVPAb4/1UsjlngujaN4vJ72rBVF9dbdWatbmF+Vazuboww8dwxMl0cTIA/ebM0tzK0lytttCstZq1Dae/MjO7vPIME9VW7aw4Npr+zOryfHWuvrSwujK72phZyaK/K3kea3fyca49TtuS33Y9G8MbvgrBvwvs1buTZ9P3iqAXw33MAVdK+X8Wh3g32u5+N97uhS+3e+GN9kS7l0fLm4S8CtHZkfxGeSEu46NC8N+ZlN3qZDt8Y99PC/rbiX4X3+Id9gWMqyzeGXxcP+9PeDS9xbL7jmE6S5Pw4zvmzXQn1uvYxl6XKH/IWIs4nWg/+9/6w7EoiEzqhn8b8ecJ/3p/W4l65WS0twcp29pannpA+hZDh3HrvvUP6Rk/LB/erzIehJ+1VrxHxnQP2++YkA3zsY14nAjEo1qrxevh4jQKecbHWX/o+m4eRwLxGLaNrq3vH0P/D+OGfmRfhy7WDcZ+oN5j34rwPwl9649Dv2F47XuzU5OQv03k22+rrxEBy3t8tpEMlVwR3nRyLKWsY1RWg//7Sfli3t64W+NE+SFfIyk4fxZwPk51guvNrjZv8JMCHtuY8bMr6m2bk/Qd8j4edSd8p+qnRLDsW1o/hd+l/R4XeNJ42C7wqJjEceIVabI+xInHMmVBB9sU9vnjgr7H/mFG9ZWWLG+Myot5WPb72x04TmocaWWKy/vxfR28DMf8qLbm0zey9xV4z3TLBDtGsLwPDXmseOBxWtAZI7zbHPyXCM+o+G4q0u1R/c/Lb0nwq/qaQekgrm9rd9PBesY+7Q/2dfCyHS+Lb59sd/IR/o+gT/vDnH0a2xIswxvbnXdss9mP5TbJ8VLcdzEM9uMI/+/BNr2RxiNjgl787j+QPJWPoPw+9hEm93dw/iXJU/kAu6Je2bAOjxMt9I+tf2EZ/Feo16/vS6dlcp1ylDF+99/3aTjkAeEYh+o7DYdq1/bdLsEXtz22HWMOGqo/UzQqlDdo/ah+G30N5cOofOzPkQ6/GxHwWf7HRApuhXdM4FF2fjvllUQe2zAsL9ow9k3UmAxto2p3aXXn8r0V73n8qjEH70p+aId8z1FW56u16srczNpabXV2abmZNUdp721e0cp19j+8q0C54oTzZzx/h3OBo+1u+jZXhvN3iMv4qBD8cxN7q+ZU7ftpQR/nuJiWos/zd2pec1zAx3V6WcJjiLnn+szC/NLCcrVWX6vXG/OzWfWq5uhcc09hxuy1WknwqeaejP5GzT0pG+Sae9oWRj5Vl11RfajV5XaRx/4U+jRqHKn6DuyL2NeoJfo9HfX2HeazlkReWbzDdnPj/u6y8ZhB/Te8/I59btXXl+i38qVLgL9C8K8A329ufzfOrHG37TdiOaXN27Dva/AvSejiXgHGmVauNJyLUK5vpDqpiDLEcLeklL8UuWWat/wjKbwegvK/McXOcZ97C5UJ/dAKwN2WAhcnHJvdRmU3XsuRXj++p635NBzqv+Hjd64xN9uuMOsK1SbbG1Vuph//TUAZXP6uS6cQ/wTB2/ejkR5/Wh2yTr0B9P91Odq18lldep2nDb5etGtVx6jXbwDfiOVl32TNM9xP5c2yjcy/wa+CDJeIL9XfKx8f5yC4v4uiwduKq9/CcYKq53sIHueYWZcVvOkq6ibu32J7Z/BHQS8+67DNWKfH9mvaWKcVwSvTfjvU6cNUp2oMqMbSeXwUlPPd7W5eDP4MyMHWFlxrY2H3MdbkPsYuH6rdXW61/oHwRdc/WLdRlyqUh3XA49qKoJN3TI59J9uRSUd5WX/ivx2AS8EbvgrB/z2HP7QDvlFtbjQF59Og9++lNof1eLzdgfv4fk0by18W5TH4KVF+hN9BvBr8Bx3lnxTlR77e2u7GafAfFm2N+cRyKZtr73cK+ClRrl1Rr1zsW5Y9wqHsFQ72KYzeRNSrE3E60+7mFXHxGr+rbe8QvLrqeoegw3X9aYePsD2FzzT+sN1zG68IXNiv+J7jmG3O1ubnl+ZXZlfWFporyxseX7gwu7bQaCzXGgurrYVaX3Msoc6cMbiNHjuEmffojB22A58uP5P9BvTPtjvgeV6L8afN76J/hvMRPHYw+D+GvuIr1Ae4yhgn9hE5zolh2JfCtql4TvPr/qEYQ7Pc1BxSnNg/M/h/7OgzlP1x9RlZvo9r7YhjP9D2cp0r3AhfjrL7gZIop82vxcn6E8RhbWyK8Cwmv6sDJu7r8DrJKVFW9n++Snq8i2Tqkhn226MCB8qkQvBfFWMdLstk1Kvrqk447on16mS7O9/gfx3a86+R76fmEmK439qvaaOPscPB66TgFdvMU+3ufIP/TZDXD6bwivwgr2rsZDq7GWMntFsV4knZD4Tv136osZMr1ortb0nQcfUxWA8K3vCxTv5/OeeGSoD/j8knVuO2Ev3O6qc4Bge/jWn++5R5UexLUGZH293lNfhXHejg/PMUnOYHxOmRdgdmfa0u6q0zj35MlWWn/Abkh+fL/ksBXwHxGLzyV7CfNpmwv/JfhI11zb+jLFFvIo+yVHOUJaIdqB4XSkTP5IHv2Karuln0w49znRLls0H++jzGyON61pvbvbJhPngOGmWM/ef/praAbUbZjVvanXyEHwW7MZI85411MxwjKTTZV+d5szgdJRh8Vn41ypPbq8GPJ+VQfnXW2gT3LWptVsX4Kb86bW0mSilPnnWRPOud01D+POudyBfL1OD3OGSqYrJcMnXN6yI/am6c/cAsmZreM695ZWrwVzhk6or9jxPL1OD3OmSqZOSSqY/Y/7wytTM7mde8MjX4ax0yVfbMJVODv34TZarmqpXNUPMs3F+qMvM8K+LcnoJT2a+0vietLl0xvgZfc9SlKtf2nOUa91Su8YLlMvi5QOUqp5SrXLBc2zPKxb60wb9UlEv1YTyvqmLAsV/nuS6Df7lol2o8vd6HJ/9H291lWUzeVwdKejyNba3S7i63yw+IE9sO1SdiG+X1RjWP6drb4dKXErzjdYqSoIP+pBr7sg6oeAekyTpg8Hfm1AH00+M02u7meTF5Xx0oaR1AXWYdyBsHyW0F4Xk+JE7TAt58faUDPBcxIujk1QH7FucifK8VtZqN5bXa2sLccmOt2pivbfhZFEvVeqtZW16eqbWWFhbWiqxVlaJu+auxCMqxQvAt0Pk1wjniwBmn+9rdOA3+QYePo84tVuXktozwvFcxTq45MZdehajPVq1WW5ttLs/PrtSra6srG362y9rc0uzaXHWmvtps1VeXNpr+8ursSnWhUVtdWpqrzs3OD6LPcXLZDOXbcn+gcI04cJUcuLJia24hXMou5pkbCxQz3ywRPStHROVe37MR9barEHNjWXIdIdmpWHAVG8VzrKqPVOsOClfJIy4+vznNNqm4BJfesN++mPyuDpZy64292yi9Uf6lS29U36HOqrmj3YFLsyHqzoKNwuXa0xx6T39eXTD6E1FQ3ay55FoWclUxUXwPA9ojrj9lq5Sffa7gQvvjskcqXrRMeShvGyOoeKpjSR7bOBWLzH2w2VHVtyJunnf/8cQvDby+UmV/B2kF7t9n1dq7JRVHwPWOcwBc72oOQMVxFr33z2QR0/7A9R28DGdJ6UiJ8sZEOdSeCu4DlA/kOk/KtUdd2e+H2908q7Gx2oOsfNN+fGikx/PkuO7P8IiP503+uWMOkudi4vREuxcn85y3bRvcrwAP/xR0iOXAfeSw+dmB+mynn618jyJ+dpy4L+rXNw6FK3SsLfvzqh+M+frdA51vuE251rJY3//gQAfn7yfPykYYj5OR2y6ouSKWf9r6GduF9RinHGsTWG7k64m2xvnvHHNLaj5T1Z+9z1o75/Ne1HpM1jj/LO52L86wc8fV5mavH3C/ir4D953Yjtg3yfLpXWef4T1nvwt6w/1k3jUKNcdYTuFNwTHuNNosa4QtMl/gkqGrfK65tEoGrjzzXy67jrjuIlz4/VgOXHnn+NL2r0ZRr78QKGYt95h6WGPWXDHK0yKP5+VcZ2YgHYVr1COuikdcVm9F2izzwWsrcTKfpkJ4f/PaZ//Hcr/82m4Yw/dcgLnyWs1fnF7b7s5T46n43W8kONR5tPHfYvK7OlCaW1L+uj/89VXVR3LbD3P2QnMlb9s3+hORbk+LXvhxn+msdF/ND3A8PvoLf6/dgeO8sng34sD1UY+4PuER1/s94nrKI64PesT1Ho+4vssjLp/y8llGX3wpOzssuvpxj7h8tm2fOvERj7i27NeW/QpZRp+yf59HXD71/rs94vLZtoe1Pfq00cPa1/qsx6c94roQ+qELoYw++fJpV4ex346fedw+LPrlU17f4xHXhzzi8umbDGufttUeN6+Mw9pvXwjjNJ868V6PuIZV7z/mEdewznV80iOukDbaYFVcYJwsVorXQH6N1hzCxPA0V13n1Y5HvT6OT9olohdFek3A6Lvm4CdE3kD7O2prjVZ1eblZX16dmZ2dLaobBq/2O6v1BZP1ZBhZL6s4jQmQa5xGIW+c8iqQZzzGsr94fzf/Ye6TbC7nkT/SV20z7exkhStOVje7o25dw/ao1hXtfFUVp2rrmriuqOI6SoRfned0Ni7q2g6v+B3yiOVTsW4loK/e43OJ3iNdpHdnu/s7jkljXri8ZcGnksWIkIVrn23W+d1qL0qZeI/TuODF4/pkK69tHNb9B/G5cXbH/AOtU3eeXj56ZOX21mMnX35s9c6lE6eOLB19+erqidbJk6xhGGXIpUVpKBiGY3iljaoUHElTNMIHcXG0kCvCJ++pHypabxt9l3aaOcKo0yswP+3UA+R5PIPne4hnddOYq7dEXKcIl7L8hmsyA9crCZc6GdK+SzsFEWGw51anaKedPIk8T2XwfLrdzTPyxady7szA9Qjhwu93Eq5dGbgeJVz4PZ/COZ1CB2F2wftpQVvhZ1lelMHzY+1unpGviwjX7gxcjxMu/H434dqTgesJwoXf76HvLk6hgzB74P3FgrbCz7K8JIPn+4hn5Mu+zdObXgLvPfZeuUcaRn+jetMsuXL00aWC12mRx9GClwo6lwo6ClfFI65tHnFt94hr3COuSY+4dnjENeUR1y6PuKY94rrIIy6zhWab0DdbTP5XB0qNprVr9FXYJqKsN2OEYfQnol79DmETla+B8uEZkz1h+Fl19dd7hHysLi8ReayPuCMI4fdAGVkfUW8r9G7h4LP/pwVOtrmqz8F3OKJuHOwum4oczqNHiFdFkVv9Zt369Y0Hu8uiborBb3mHlcHvva6D8+UJTrUzhHc0e7ABq/zCcGNd+9Pj2pzJ9LKoN1nec0SZSwK+TL+R77g/fvpABy/DMU20I8+hPGw3l1Metr0rKA/1/krK2yjdnfRIB2XEdmaXRzoo7z1EZ49HOlh3Vle7ot6645nQvDZL7VTn8Ueabbn/oKaZZlv4ZLB1OmBblhKcYcc3tVkeH2Di9o/6q9o/6/PlkMc6eAXk8dgRk7IbJovYbnyhgN3Aur2M8lw7WwL5LY08bQHpb9TOFjX/5drZskvwquwDt03lr+0SdBQumycYJ9yRP3msbaKPXc+rG8PqY6s+175VNr28IXKtNVTfFBHPOAfFNi3NP+ak7JaVKbZbZ/q0W6z3yKtHOc1weSPBF/YZn2n38h85ZHExyKKI74cyv5TyUPfZvqM+sc+Iesg+48WCnzxtM05sv7CutqWUywedC8HH3BWl25BS1NvGy+Kdy/djXzbN9/vMQU0zzffjE0sM/n8e7OD8fvL9wsxTFGvjqL8h/MK8dsNkMYjvdyngV32mPavbC7gNRQIH4+G5AOWr1BqN2jND/Lna2upaY2Zuob5cm23Mzq411+Zm55urazPNpdW5Vq251KgvtOaqa7X5VmtuprEyN7u2sLoyu2a0TJ4jjrIV8JnqK2u1xswzlKqzS82Z1dlGfbU+V11tzqzVavO1+kJzvtFYW2nOr87XG2v1ufpKHp8p0Lxb7lOljP5G+UzKDrl8posFr9yHxOlEuwPHeWXxztUfse3sF1ecLEoxz7pdIF1o9KsLodftstZw+9EFtk+D6gL35a6xcaDxT+62zOOf0GPjIVljaLjquezgJ9A6ed34Uetmau4gXm8bi9L9O9ZJ5Bv7b3vH9aBou05y4v57VwYujs1SvrCrzSMujs1S8qhQ3p+Cv/jbB7thLF7ojwDmd2k9Rs3Nhh1T5m/TRn8iCtqGaq42pMYJsc5ui9y6g3WXFq82IcqaR5eRpzy6rMbMBhfrxL872B8cRsBuA7g/c8BtF3BMi09sQhx8U9hfJDhivL90fTddlAWfXqZuUFan9E5THvLEp1mOinLy7ohS1BmnKPlwpDLGzrh2MeykPNTFiygP63cH5WG8iMV1TUa949T/BTZl4rrON2ij4+Tqi1x9Bdp5g1djfft22NZHeIys1kfVOJjbLK6PsD92JeQNsnby2HUdvAxnSdWz6s9wjoNPnRwR/Kq5E6UPLv25TMDjfAXrD+qIfTusa+ghdMTyroI8lAmnrDX7PPrjsg15dca+VWutkznxunTXpWOKb2xzrGO7BN/KfqXF1uCcE5Ytbc34YFIHWbeyYUxanEYhz2dsmDpZF2VYaXeX29UHxKlom+f1R7TNvP6EdZC21o84MY4Id/sYH7zTMiKcrnmQQCen5va5+eTU0PMgWXtfeB4k78mpJXoe5ITSEY+4TDfGRZ5H+c6z34mJ/cc4FV23M76LrtthvbA/i3JmnxzbFPd/2GbYnw21nlZKKZcPOvgd6/+IRzp5xh0+6Kj9amr/GY99i95o4Brv4a5DXLe77zpNM+3EfV63M/g1iNn65uQ58A7PQm0c9VeNc1mfcfzIOohjRKxbTspumCwGWbdju4F6aXA4ZrU6ehDq6AzVu9q76PIH1Z7F7aKcSs/t23HxnUf9WFB2PiLZqZvQlQ6wfqAOsH7gPhG2K7jvjveUYlK6Y3IqMmY9k9K+jQa3bx5/pO2avw/8bb6VS91gyL6DwhsnvrnH4N9GNiWQzshbufgWD5fNxvIpm31XSvk+CW3znddl01O3VJUoT93Spfb9ch1Zm6jkLIPBP51zDIZxAHEabXeXbzF5Xx0sydtNcH90pd1dbjWGRni2gWqPMtoM9s/T+g38jbjUDV+sZ2MCHvGxnn0M6shu21F+F58Couawld/Btz+hbo0Dz1+m9hxo3Den/GBLam6a7Ty2E7bzfFIL5qEeFL3pzmRR9KY7dRqIshNsC1S/rdqt4d+Mdot9OLdbdeaB60ShrHbOt9ZjXbJ+Y5sZpzy1PsRtJk6vIHpqHQXbTNopK2gvjK/A4+zc8ypGfyIK2t5rbB+NH5YPt+XtgtfpKN0+lCgP6WwXdBSuEY+40m6KjqJeXUC6vmMfoihbF4z+RNQr0xC6MCLkWhJyVT4vyxx9ZYs7c81NBB4D933LciAdcJ5yhPJxzWvyLcvYljnWr9+5yHMBl5q7KaX8Nzr8Lk1/lT+DPijOEf02jSExFqEsvuXxgcE/cH0H57+iMY66JZPbTpwWk//VYqnJL8KetlddVvG/Ecl7hyhzScArH9H4Ljr/nGeuuBT1xmhgX8OxFugj8/prKN1Ni2fxQUed2RV6Pj0tXsYHHRV/peYBBj193RWrk7Zv5L9fp2mm7Ruxs9AqBH8f2Ja/obFlmNNXq0tqTiGicqtxoGr/rM84h8g6iHOIWLeclN0wWRSdf1brTzx/aPLlbzdhvTd33Pv5st7r80ZKnrvn+UF8Vn7eqINOSdAJe0JzdVb1EZaUnEuUp24sztverExF97qizNPOUPEsp3NyzRzrY2vNvFsmLvvbLx0117uZa+Zsm4qumbt8yjSfZeZ6TTPvXleDPwQ+y3zyfL6smbMObsaaOc5xuNbMDU6tmd8CdXQP1buar1N9XynqtZ1qzZzn5c/nNXPWj2FaM78npX0bDW7frphdXDNnu6HWLdCGFlm3UPqD7di+HdZ5D6UHbI9RD1jv1H4jy8PzMVEmnLLmWYrEeau2nldncJ30v6fMvSHeisDrslGqP8xro4yWWlfkuQW1PsF0io7zjydtKCvGwGgHXquc2cy1SpSZWqvkdSy1Fq98ZcOJc7/rOtnuwIVYOzJ5laNOexxN3iF9q/PtkGdw631lGF6rxutEgt90GGliWUYInp8r9O790E9gGa0c+A7xG/wk5Bl8Gd4Zj2YzxyBvsl0M13bCtW0AXMbXtIDf1idfCtcY4RoXuPAdtoenkrpJW4NPW0P5UI4xg2sNxeA/D/7odybPag3F5UvmuX/DNWZSY7NNjEHIvQY6DDEIyr8L7NM3XX27qud4v+zOqLfO1DoCjnf4nhLWM8xjXcA85TeoeQ6OxVF+t5q3cPWLRnsyKhbvqdoxt3OE/yK041+kdoz08sSIbIY/V6LnCQcdxVeWX8N8qbFMJGhnlcGldyomdhPj4KRviWVn39IVjxonroMpAa/maaYJHmWu2iXHh6o9hEXbJY6JfjHH+FyNiZSvi+Nz66P5fiLjZTH5XS2YluZaC83ZRn2lsbawNF+d5xjzKOqeg/JNf66+MrPUmFmorrRm5pZm57Lo/2nyY5zyfPeT46KcvvDPV2fWeA7LM/+NwPF0NT6fzjP+qrW3b2p38HNZ4qTWK+ybuK2bPsXPz4Nv4vR6wF2ivG8WdC3vDW3NR5y+BfLYTn8r5FUo737IQxuu+oXF5Hd1gPSMDi4E9u1m90Tpfprp/83tILTrhv9QGPzr9uFwGPyzhv+WBH/kD3fVcN8KvJcCyOYVYfCv1+0rw+BvGP7bwtTtOv7bw+BvGv5XAf4Q+vPqMPJfx39HGPms439NGPms6/+dQeRTX+f/tUHwz67zf1cY/Ov6eXcY/DOG/54w+BcM/+vC4G8Z/nvD4F/3Pe8Lgn+uafOPn00als9Yj2G7CVnFofE8TNE4NPw+7Rw7y1f/oyifDAPFcazLsJKz3GpOjmWocKn5SlcskAuXqlvXGN4Fv60gvI9YDRf+iYLwkwXhdxSEn8oJz2vrhiNOgc827vtul51h+KlxLIGSxXQY2nN5ZTFNsghUN7XA5V23X+qO6Z2ivNMEz2VHWIUrTqbzcVsye/BA69Qdx0+1To6k4ML6QJoMz8+WxlLwlIlf9S37/hXKV7YT329Leb895f14yvuJlPeTKe93pLznuBlLh9rdv++g37e23fCHk9/TUW8q0R+/D/U72kBaPng1nVTPJQdMnv3GgfzI3DbT3m3UfuMy8cPy4b5X+bVqv7HNU5VEXh6fF/Pu8IjLJ18+cb06AF+hY+oNLuQegThZ/Yfen65i6Y123G89EHWXHc+t4bjA+HkX5CP8bKmD86HknWtfQuD9Z/N5bRPvPwu0B8q5/0yN8YrsP4sTzoNyXlm8G3HgusUjrjuGlC+fuF4dgK/Q+6o5vkPNSxQ944znIIqep4Lfcwx5mv16D9HMsl8YL4TwfxR1cD5NZVT2Iq+vcajdjUut7zLvabhuJlyu+Z+xDFy3ES4Vk+HSZ8R1O+FS+/ddOoHy5b2vafFvWbjidLjdjUvFmQVeH54zniYyys1nHGJsxgTxWiI5LHrhtTmrZOEP/+yK2vviEf+citFif2NHkHqu5Y6BNfobdedf3pg0tf/HvlXxZ6yDar5zStCZFnm8xjcIrns84VLtYBC+7vbEV5zu8ojrTo+47vOI616PuHyVUdmuYdEJn7L3qRM+27ZPvl7nEZdPXfVZj6ZffA7Y7yf/lT/hsU+cVXvduT+eCES7RPRMfhGV13X3mvE9IfIGiQdeWGi1ZuprS7XqTGO20Wq6fMR+zz9GeJP1VBhZN1WMPp7pEadRyJugvArkre8rfObvh0rd/Afy3XLJX/lDCM/zHHnrcnekfQ2TD7bb+DntzA/TScxTZ9jwvKbJEvOwnaTtL4ufbYyCe3Vc8wiqjBt1DlqJ8tLmB7ZDPsL/efI/Lr8dblW0zCHmRxjXqChXnEw/KwT/9eR//PvLpW6cSu44R3GoHaWWleWeddYCz22o8a/hmszAxXMb+D2fj7EjAxfPbeD3OwjXlAMXtsdd4nseW+3M4OtwuxsXfr+T6KTtFz2Lu93Jw7uh4jQKeT7n5mM9+UqpwweXF/uDUqTvQFZxBQav4hAQh7WFaQFv8bJKPjs3UT6VgvJxnWOSJZ9D7UjKB9v4sOnPdod8VFty7Y3M0rebST4YB4PnOrB8NuhMjML6k2XnWT5KnojjNpIPxhNNOOQzrPrj2sOr5JN1xsjtJB/VP53P+uOSD/aTSj47HPK5UPTH+n4lH5OLWvPDuywa5OuptSf0Hw+1o67yqjEJrsex/2wL8jEPX02hndd3NfiXAE72XdX6105RHpePtFFndxiurPMqmOei62wuf9u1zpbVvtnfVuMANZ7ms5OVLXCda8CwURR8Xqlq+o8+lCXLwxhZHq/vjnrlVhK4yvQbyxSX/1fB/jAc84MyQt7y2JpD7Wf/q3aSZ1yGuFjn0vo9xsV1G2YeKH88/PmyhjexIXIt3mZQnpxUuzC+43YxMtLBy3BME/WP24WSufJxXfMCgeddC8uVY2rwHAq0/5yUzHGedqKAzJUtsjzUP+Ot6HlFJXpen3+OtO/FvoXBnwTf4g+ofOhz4tngZ+m0u/lcTN5XB0tzRX1ONRfl8jnVnMCUkJOaE+BzHjZhzDJXdMyS92wwlzwRx6F21CUfZWc3ccwi5bPNIZ/tGeXNM2ZBHDxnknfMu5ntq1JQPkXHvIjjNod8hmDOVspnzCEf1b5c56Rl6RvPmagxgJLPBp0VFtz+uOQTP/OcCcqHfUAVN6r2KBxqd5dHzQfgHoKQMp6b75z7avWL575iGoV8hP98gsD3+V5rc0u1tcbS2tLM0upqc2Up63wve7+t3ckvE69n+U+e130thKe88XZv+Y2OnWtrPhDjMj74HNwvJQjUObV8vivSHyP6XXyLd6jrjKss3hl8rHtfTD4KcW7byszs8kpzZqnaqsU/61n1quSEtihOJmusizFRtgrB/2ypU+afAztzFlbQi+F+xQFXSvl/Fod4N9rufqfqCHXX4I32hODR8vBsYLSTcdqR/EZ5IS7jo0Lwv0S6i/pm36uzifGsZ6al6LPuqnORJwV8XD+/QPYIy+57HuEsTcKP75i3XwnYrlrLzYW55YWVmepqdaG20MhqV3jOSinq7u+iSM8Z49wa9nNjkY77MHw8x/wvE7oxD384onFiP3S43YuTecb32OfbHq4Kwf8W8PDHMBZlOay3TcLtWZ9y3zm93p8IeYSYJ8t7FouKZWI/CH3VW9odOM7LM+cfGpfyN4vad9c6BceVoc+Fe7H+JKWNYqwVfmttlPX9z6Gv+zOw44Y3Ih4nI7ddwPKyX43nzyp4tgsG/1cOu6DOlke+Drc1zq8DTl7PytqD1e94Qa0l8V4kZa/UWAvvE4zTKOT5tD+h5zKyzuw2/ZgmeJSjake8Rpd1/tahdtRVRqWX2O5UP1kWNEqChmt/YlY7KgvcabRZ1girYlPT/ADLxz4Y4eNk9rFCeL+WAMWy2znSDWP49gDMNPW5KL9Xtrvz1Nnx8btfT36oM4vjv8Xkd3Wg1Gypvt8f/tl5dV6vP/xzjbB7EOeWDP94GPz1wHsc1+UzGYb/GbUW6A9/fVWtiXnkf10/d4aRf12dyeaR/6o698sj/lleFzQacTLaOB7z1283V0pEL4r0uMHoTxCvnv2I9XHDbuKH5cPjhj2C12mRxzZ+j6CzR9CZFnm8x2wQXPd5xHW3R1x3esKl+r9B+HqtR762eeTLl7x8ltEnX8oPGAZdVf7DsLRtnzrxOo+4tuzXlv0KWUafsp/wyJcvvY+fJz3y5bNtD2N79G2jh7Wv9VmPd3nEdSH0QxdCGX3x5duuDmu/zfMmw6JfPu0qz90Mwtc9HvnyObYaVh9zqz1uXhmHtd++EMZpPnWC54bPR73n+elh8aN9joemPfIV0kYbLK73WqxPnOzMCV7D/FVaMwwTz9NcVWvopaib9vZAtEtEL4r0mgDvXUJ++F55vr98sU9el2trjVZ1eblZX16dmZ2dLRF+45Xf5YknUOsLYfeuNpdVzAbHzo9CHp/1UYE83IvK53SNB+I/j/yR/rSA53O68talndOFPibv7UUdtjPB1V4Ji0vAuAAV41Ei/BiHg3FLvzfS4RW/Qx6xfK797OWU9/hcovdIV937rfJKghcub1nwqWQxImSR55wzbKeGL0S8a3Ntbml2ba46U19ttuqrSxt9/3hzZmluZWmuVlto1lrN2sxG0y96//pa8nyO338+h3Y/AP/nzf3nFkOlyhInV9xVbKsvjzrP18A3ceI4cMy7XdC1vFe1NR9xwvse+P5z7F84VhLv4uU9fej7b6M8HHdyn4xzttyXo0/Le1Bx3oX3X6L/yuftoP++vvco+R3iXsD5anNJxdx41MPVPYL/XVC2ON3cDkL7vLvDPYSNi9OtYfA31T3uPnXL4lbfmOBTeynNLgW2t60S0YsiPdaydxNR2P6lRPSMH5aPPce26LnJ8wOtU3eeXj56ZOX21mMnX35s9c6lE6eOLB19+erqidbJk+yxsgXnfEwMw3AMn7cUh9rP/lc7Gdjrz9rd5LoJhncdZZ3sdQvhUtH+auSAcAijTrjCfIWf62Msg+dbiWdFM/ANYzPG63YHr0i/3xttsNyHqdxq14Z9p3YlcF2pUTPmj6XwGkWbe3POiOArz805gXidN14nC/KqTsEIzOuC8bqjIK/qhKMy/WY4hFEnEmD+pKC9Qbq2ZDKZKigTdYJzYF7XZ8F2FuRVnRAdmNcV43VXQV6VJ16m3wyHMNvF95i/U9DmPsjFc5zMY9zloKlmmnhUq/puNcvlOvmfT/fHPmac8tA+pp26h/qiTpVzzca7btTYQXnYfqxOJqPhP0mklfze7JNEzBs+t2fKmlszZRnJ2vOhdgd/3pky+yZuo9bG4me0UXE6DLhLlHeLoBuyzM/oxEzgm5Hre6J0+2uj9uckv8sCFtsC7vRW9RKJdyWBh2WL9biY/K81GrVnJhbmamura42ZuYX6cm22MTu79swqw+x8c3Vtprm0OteqNZca9YXWXHWtNt9qzc00VuZm1xZWV2bXuKwjjrK5duRmraIMuw3fm/zebBu+L3nesuHO1AhsY+uB7Y204S7fT9lwNXtodjvLvqMNN9wh+8V5uFE2UJ3V9kTpNtds+JVRJ6Gc+VQAxMMnklya/I/nQ/ak4BuLsm1lOeU7W8EaFzgij/JyRRkgH67V83PBtl+T/N5s23518nyO2/alLdvuThth2y1iLH7eDfjipGy75eHKGa9y86oX5uGqPJ7sY/4ufreY/K4OkLC/CDRn39wj+Dda1l+YDYznJi5Lnp9ZbXpmnenepaNHVpdOHTl+7K7Ww6dbJ0/x4Wtl+s35HABlpBGOU4l+88JhiX6PCDhMeQKjXIFXyt13BaidC92FTaNsdneBbgDmbQ0FulIjsDlvhDRzcVLdRdqya5zMvOOz8dRvl6IO8zPcOHyIn9cP+Y207ViMBpeL6U2o4Uic9kTpLrqZf3Pvd8DzseOnjqw9dsfpo0ePrB1prd5x/FQrosSmP80sY7H4O04Gdy6YUJsp22wTWk+ez3ETurxRJjSQpzWnzokLbULVfWimwxYHis+DmtDAM+CzgWXYUHsTTAaBV4ZznyFs9CeioPq6HoumInDUebxqLw2PoEbbveVQe2msfmOYqwCOdYvvYsdhA59Dqe7ni/FfD7SelzwH7taXN7Nbt3fb2h15rPe98K4C8jsrH4SnvBB3LVyX/B7muxZsNmsy6rhLLwB83FZ41Qzxxe6VzWg8617dfKK1dEo7V2rjEP4eSWEi73gc8UcOWowT4c4VR62W/N5sR+2HkudzfJNPbWus607WueG41TXWtSlJfHY5aoZXOWq3Uh62E8MdGzGb5sPlIjUNWqI8dCTZMbideMc83FzEG4hwcxFvIMLNRbyBCDcX8QYi3FyEF/KVojCbdZ/p9BfCbmauzu8R/GO4b5y2Nu3I1LDO+5EEn3XUbGMi0hV854sX5bDyICTUckCJ6EWRHoQY/YkoqK2suZwodTlc7ERZyObJU8dPLD3Ququ11HWmgnKHOD8icnFiVynN5bLfaUshrqUNTK77PUpRLw9l8c54mk75Pk6BxyKzakxtSUXn8vIKjj8PtTtwnFRkmZUpxvEU4GU45gdlbryp+yBYniPED79z1QdHugVa+fVaH9idcHJF+hWtD5Q53n8a0A0sLCdlOl2yGAVZfBzwMhzTLJ8DshgR/IeQhWqnpajX/qou41D72f+qXY+mfKfspHIVKg7aqp7smc/+UDyxvY7TYvK/vjrTqi7ML8/Xl5cac8vNxvLCwlKtUZut1ebXVuvV1WZ9baY2O7uy0FpYqzXWlmdaS7MzSwuzq7VWdWl2lWmNCL5GqFzbHOUqi+/VvU3bUmSAsuGdgWppPY3/7Q7+t6fwH6Xwn3XWDu8stOfxHPxzO47TYvK/UW00Wkv15mxrpjrbml+Yby3Mrc3MVVeW1tZW56rNleX4YKbZaiOu17l6dbm+0Ko1FlozK2fv6qwZrQmSzbgov5ULd7/wsKUsvle7/SZTZIB1y2eETohv+PeI+JbrdiKFNsKMiDKm4VB2TfE/Lr7Jwz/Lf0cK/2l2R+0iVPXrwsH2jW3RSMp340RX6TfjHMvAybux1A5etVOrRHmIk3djlYg3zHOF/ag+QfkrXAZlS9i3Qpvo2sF2LkyvPpn83uzpVRzel6Lu+o0i7a8fanfDY4Sysh+Gj6Ol35H8j3n43kjjTLszdX0NIurVyTgtJv+rAybjx+oP28yoo4wG/x4o42epjGUqI8vZyqv8WI9lrFWIn/cDzz9IPCv/UekWyw3hlV1VJ1S4zs2z58Dj9HqJ6EWRnh8x+hORtp+Lfvipcb+DclX1oGw9j7eVHhexDUj3UPvZ/+fCPZHn2/l5a816qzUz31xefuaptlrbaPorM7PLK88Iodo661vXs+i/OHk+t5f25hpbux7cKe+uhzLBqW8G2RlxRdR55uU7XHYsUd6tkMfLd0V3RqglQZ4vVXMBKrYoZOwVxuOEWPp7Ru3mVWwUL0mOQp4rNsp4jGFuIPmEiIvDuLswsW/19fMG1UlQ1j83QSaYb/Aoh0D1uJDXRzL6E0Hl1vGR1ElV6szmeH7g4uR5/by4Q0unlu47cupY6+RJnkcr0++823fsN8/JGp8WZ6fmk9OS8cM2EfHxXEuJfo+kwGE5fc4L8Bhezee6tgq55gwmgcdt7Wg9rfue8M7sx2bF8jWS38Mcy2dxe+fCnMpC8ntre9bg+LdOashOWyc1+NfpPCc18MkKlp/nZIVSCt6tfVP5bNufJj/O8XDcta2TxNzJbNs3tTv4VZtUts2+wRMIcB+J2a/XA24ec3+zoGt5b2hrPuL0LZDHY+5vhTwOmb0f8njdOcz4cWYh8N6pWdf4cSv01Zl6zquP/OGuGm6cVyoFkM0rwuBfr9tXhsG/Pp96W5i6Xcd/exj863cFYPh+CP15dRj5r+O/I4x81vG/Jox81vX/ziDyqa/z/9og+GfX+b8rDP51/bw7DP4Zw39PGPwLhv91YfC3DP+9YfCv+573BcE/17Rx0meThqW2NZVS/kdR79xtnHh9O9T4z2Sh4gzKgh91GwXyloZrVOCajrLH8DzXq/5HUT4ZBpqXWJehK/YC+VG3Y7AMXbG7iEvJsJIDl6pbgx8rCL+tILyKXR11wI8XxD9REH6yIPyOgvBTOeFN5/EGAdNnG7sEumsrd9yN0Z8gXn23qSmip2QxHYb2XF5ZTJMsAtVNLXB51+3XRVRerl+jP03wXHaEVbjihGuBZg+eWQuMTxk4OZKCC+sDaTI8P1tKi4kvE7/qW/b9+WgCZTvx/baU99tT3o+nvJ9IeT+Z8n5HyvupSKdD7e7fd9DvW9tu+MPJ7+moN5Xoj9+H+h1tIC0fvJpOqueSAyZP3GYgPzK3zbR3GxW3WSZ+WD7c9yq/luM248RrQUV9Xsy7wyMun3z5xPXqAHz5HGcpP9rgXO2qXzqYZ/UfeP10Rq19Gu2433og6i47HsNTpm/j512Qj/CzpQ7Oh5J3m3icwHxe2zSsxwmovTf27TTlxQnnQTmvLN6NOHDd4hHXHUPKl09crw7Al+s8wH7tD7Y10znXvIS6JbNEedsFzhLlGX/8jvnD73l/Wpr9eg/RzLJf2yAf4f8o6uB8msqo7EVeX+NQuxuXWt9l3tNwuW6aZdmPZeC6jXCpU9hd+oy4bidcas+1SydQvtYP9ntDK/J1uN2Na1TgCrw+7Lw5tST4yXNzaonksOiFVx1r7Q//7Io6hsoj/jnejxtFvf7GjiD1XJspET2r54jqy+hPEK+e9W7d33Dd7hon9jemBK/TIo91UM13Tgk60yKP1/gGwXWPJ1yqHQzC192e+IrTXR5x3ekR130ecd3rEZevMirbNSw64VP2PnXCZ9v2ydfrPOLyqas+69H0y3xdg/395L/yJzz2ibN59ktNBKJdInomv4jK67ohmc87x7xB4oEXFlqtmfraUq0605httJouHxHf8ZpH3r7dZD0VRtZNtccQb5eO0yjkTVBeBfLW9wk98/dDpW7+A/luueSv/CGE53mOvHW5O9K+hskH22387Nrz5drXxfvBuM1jHrYT134wPAsmzzyCKqMa7/BYVsUC4DvXPAKffZU1P7Ad8hH+z5P/cfkbpW7e85Y5xPwI4xoV5YqT6WeF4L+e/I9/f7nUjVPJ3XWOHfLEcp/IwMVzG2r8a7gmM3Dx3AZ+z2c17cjAxXMb+D2fvTXlwIXtcZf4nsdWOzP4OtzuxoXf7yQ6am5H2WyDC7lP55k0H+vJV0odPri82B+Uou54EFdcgcGrOATEYW1hWsBbvKySz85NlE+loHzUmkJe+RxqR1I+2MaHTX+2O+Sj2pKys3n17WaSD8bBjDvks30T5ePSnyw7z/JR8kQct5F8MJ5owiGfYdWfvGccuPo6xHE7yUf1T+ez/rjkg/2kks8Oh3wuFP2xvl/Jx+Si1vyMJvqwRlOtPaH/eKgddZVXjUlwPY79Z1uQj3n4agrtvL6rwb8EcLLvqta/doryuHwktZ6VZ51NnSM07aBjuNQ6m8vfLrrO5vK3XetsWe2b/W01DlDjaYRDGOX7Y37aOCOKgs8rVU3/0YeyZHkYI8vj9d1Rr9xKAleZfmOZ4vL/KtgfhmN+UEbIWx5bc6j97H/VTvKMyxAX61xav8e4uG7DzAPlj4c/X9bwJjZErsXbDMqTk2oXxnfcLkZGOngZjmmi/nG7cJ1nHSe2eWpeIPC8a2G5ckwNnkOB9p+TkjnO004UkLmyRZaH+me8qf4pz7xiifhE3wL7RvYtDP4k+BZ/QOVTZ+kF9jnnivqcai7K5XOqOYEpISc1J8DnPGzCmGWu6Jgly9di+Sh5Io5D7ahLPsrObuKYRcpnm0M+2zPKm2fMou7rKTrm3cz2VSkon6JjXsRxm0M+QzBnK+Uz5pBP3vNV8+obz5moMYCSD54zs9Hy8Wl/XPKJn3nOBOXDPqCKG1V7FA61u8uj5gNwD8Gwn+/1+QTBZp/vZe+3tTv5ZeL1LP/J87qvhfCUN97uLb/R6ffszC8lCIb57MwvJh8Nw1nrSk5oi+Jkssa6GBNlqxD8z5Y6Zf45sDNnYQW9GO5XHHCllP9ncYh3o+3ud6qOUHcN3mhPtHt5tLxJyEM7GacdyW+UF+IyPioE/0uku6hv9v20oL+d6HfxLd6x7k4K+EkBH9fPL5A9wrL7nkc4S5Pw4zvm7VcCtqvWcnNhbnlhZaa6Wl2oLTTy3J9j56yUou7+Lor0nDHOrWE/l3Z/Dt6Fg/D/MqEb8/CHIxpn2v05GH+Dv9Pu67M9XHyHz28BD38MY1GWw3rbJNye9Sn3Vb3r/YmQR4h5srxnsahYJvaD0Fe9pd2B47w8c/6hcSl/s6h9d61TcFwZ+ly4F+tPUtooxlrht9ZGWd//HPq6PwM7bngj4nEyctsFLC/71SbPsRR4tgsG/1cOuzAmyo18HW5rnF8HnLyelbUHq9/xglpL4r1Iyl6psRbeExqnUcjzaX9Cz2W41mtRP6YJHuWo2lGee2KxfRxqR11lVHqJ7U71k2VBoyRonAt3SWH5LB/7YISPk9nHCuH9WgIUy27nSDeM4dsDMNPU56L8XtnuzlP31cbvfj35oc4sjv8Wk9/VgVKzpfp+f/hn59V5vf7wzzXC7kGcW1L3tHjEXw+8x3FdPpNh+J9Ra4H+8NdX1ZqYR/7X9XNnGPnX1ZlsHvmvqnO/POKf5XVBoxEno43jMX/9dnOlRPSiSI8bjP4E8erZj1gfN+wmflg+PG7YI3idFnls4/cIOnsEnWmRx3vMBsF1n0dcd3vEdacnXKr/G4Sv13rka5tHvnzJy2cZffKl/IBh0FXlPwxL2/apE6/ziGvLfm3Zr5Bl9Cn7CY98+dL7+HnSI18+2/YwtkffNnpY+1qf9XiXR1wXQj90IZTRF1++7eqw9ts8bzIs+uXTrvLczSB83eORL59jq2H1Mbfa4+aVcVj77QthnOZTJ3hu+HzUe56fHhY/2ud4aNojXyFttMHieq/F+sTJzpzgNcxfpTXDMPE8zVW1hl6KumlvD0S7RPSiSK8J8N4l5Mf4nhB5g8SpLdfWGq3q8nKzvrw6Mzs7WyL8xiu/yxNPoNYXwu5dbS6rmA2OnR+FPD7rowJ5uBeVz+kaD8R/Hvkj/WkBz+d05a1LO6cLfUze24s6bGeCq70SFpeAcQEqxqNE+DEOB+OWfm+kwyt+hzxi+Vz72csp7/G5RO+RLtLju1E5Po154fKWBZ9KFiNCFnnOOcN2avhCxLs21+aWZtfmqjP11Warvpq5P8A7/ZmluZWluVptoVlrNWszG01/aa610Jxt1FcaawtL89X5LPqXJs/n9v3nzRm0+wH4b4Q9v7NaVbFKPvGbLT3U7uDHshjd2B7jHm/rj6Yc34fk/Zm6bQa+W6m2J4X/OFksnPm/sWxsTPNA69RdS8dWj7/5liOto6vYwli6rjQZDf9urkuS35u9m+s5yfM5bq1mN8pahZRPwBYprZVqncobtG/QesXPO+GbOB0G3BtkyWaGwZJZG4st2cXJ88qDrZU33XH66NEja0daJw4/euTkqZNszxBnRM95bV9W1PGw28HLkt+bbQe3vLZcacsORukeXUiPFm1dKI92T+S2Jey1WZs5dvzUkbXHbj7RWjrVWl23eRGlvBZty3vLb7Us49y2WnPLG2W1wuzhrDcC71ldt1q3tjv41b62MsHxN2jhXgEwr0iBeSXAvDIF5jaAuS0F5naAuT0FBtcUXpUC82qAeXUKDN7/fEcKzGsA5jUpMHcCzJ0pMK8FmNemwNwFMHelwNwNMHenwNwDMPekwLwOYF6XAnMvwNybAnMfwNyXAvNNAPNNKTCvB5jXp8B8M8B8cwrMGwDmDSkw3wIw35IC860A860pMPcDzP0pMN8GMN+WAvNGgHljCswSwCylwCwDzHIKzArArKTArALMagpMC2BaKTBrALOWAvMAwDyQAvMgwDwIMGWAOQIwRwgmsLc1F9am12t5zkAIc79wPfdZoXy/cOgzENR5AmlnIJyFaXf4KVHeaLu3HGot0Oo39m4PARzrFp8jYLzEyfRXnTFgehvjfw3Quifq5h2/KRP9KOpdZw1RF/PV2aWwev/suZ9ny9juxm/yi9Mo5I1SXp66i9PjAMeyCzG6RNmFaSe19dko5B9pxWlbO1pPZZI1ym+zzuW6I/k9zOdy3Zo841j0ZqAfYmx1KAj+WtXwHw7Df9Pw3xIEf7NqMw+/bXUWhbRP1aqKeeB+eVsQ2rVa3n6ZY4bC+AmdfjnveZhh461q1RLhR35UTJU6t5njrNfPLwNcCL8dyojw+Gzf47vV5L86Z6XfO+Jimd9PZVNxb3n0CPFOR72y4dgWdS6Qmjnlc4GeAN4fIpyqHtEPQpuCMkk774jvvzP4Y8n/OP9fRxpn3jv1DP4k8PJw8pwVL/VYpMtfitwyzVv+kRReH4k65f+3KbwiP8hrVvzWUw64ioArEa/lSPv61l+57HG/eq7OuQkb/1ftuadTlZvpx3+TUIZy1GuDGF7pFOLnfZjrc+2RtqV8RpHBfzD5H8vyvSk8RFGvXscJfak0vc7TBj+Q/Md2nXV3kPGtzt/H85YZR5wWk//VwVItrK7Va2HP8enEVoU5x6c6r2Ic0ZZ8jOjaalxeG27w3wM4P5E8q7P62J9Ii73kO0yiaHBbhfvV2G/YCd+odmY21OCngW6ZcCh4G6OhbcB9C9zfGPwPJP9juf9R8qzuycA6/VykaWOd7hC8Mu2fAZxfSJ5dd5aqO0jZR9wpeEE5H2p382LwP5b8j+XwJ8mzmv/AFeQ4jUKez/FFzMefAR9c/5V2d7l93l2KMlP3cPA571gHvOdJ3W+j+hfVXu1bZUemHeVl/Yn/LgJcCt7wVQj+HyX/lT96EXyj2txoCs5fBF7+z6i7/FgHEwD3f6fQxvKXRXkMfrcoP8JfRLwa/D+L0ss/LcqPZ2iNE06D/2XA+ScpfGK5lM2192r/1G5Rrl1Rr1zsWyV7g0PZKxy8R9noTURaJyaJV8xD+lh21bYvEry66voiQYfr+mvJf+WjTaXwmcYftntu4zsELuxXhj2m5PeT35sdU3K+7d+oz8/PLtSXn1nRW11ZW202Npr+bHO2Nj+/NL8yu7K20FxZ3mj6w3QPxF8a7DN/f5U8Z90D8b8dcKWU/2dxiHej7e53w34PxP9Kfg/zPRB/bfiS/1h233PRZ2kSfnzHvJnuxHr9/ATBuR0rN7tybsfK1eobFSuHsWiuWLm0+LUywKTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFryFMWvwawqTFr8X5geOYNiSeA9tYBGUJG8eUf730QotjqgMc65Yrjsn0V8Uxmd7G+F8KtA5H3bwjPtdYO2wszsxK4H5MxjFxvY62u2ljHtbdKMizTvIJ4aegfELIP5aPa+ccjyOiSPvfJqPNilX6huT3MMcqzSTPGxCrVA8bq9TxnQ+Hwd8IG6vUibW6NQz/67FWrwiDv2X4XxkC/zPTDxbLhWP6NN8hT98eJ15T4HvrkE6oO8a4TwsTH9aJIdgOfKr1Tl6/wjGvWuNnePbXGP/4xpS3J94L1yHHBP9qXT2K/NqnGGegdfX5CpXX4irist5LNHHOn+soTmiD4r8dVEcMw/FeU0CbZY7fVgj+Dcn/uAyVUjdOFUM2CThvIZwGfz/g3F7SfEaR29+09zsFPK5DGD/qbrmd9J1rbVDhRvhyCh5e++FyjsC7CYE77B08nTaJsQElQRPXzBH+KPG1m2Tqkln8d5Ggi3PaE0T3IqIb69Ak6ZDxNhlp+8I7vMfCyLbJcsS731AOY5Rv8K6YRGXvY7jHqSw4VlZr+CyLMHdV1Xv0DGWh9IP17NHk/9mTSkrpshgTsnCNyzciRuMi4hftboV4UvZPxWYXtX/TUW/9bqc8FROKNovpqDgM1ru0GEDDx33Du5P/MW/Xl7r5U+cAYryiujeSv8H5Ylc/q+ZaML7pA4QX18hUv2U+Pp+r+leA80PJc8i5gmfSPMtCxZsZTeQnzD6ATh9kOpAWu1qOumVo8J+IuuvCdBHruCLwGPykoIv6zHFxk0QX+6CyoIHjlMCxqFXX2ChwPS6UiJ7JA98h/YlI182iH37W529V/DLKh8d7k2H4mY99l+moWz/ihONzrBvkA+eK2S5h//8D8J7bjLJLNrdUIfgvAM7PJ88qlhbjZZnmSApNHsvw/Hqc+AwLfN4myoR6xu3V4H8s+a/GHXl1hG0GwitbtYt44HpNo436caitaefdN2PwP538x76VcVZSypNmA/8B4GSZqrhOl0yV77NDlGtX1CtHHmdlyZT3LGAcaR6ZGvzPR53yX59S/rwyNfhfBJx5xscumWb5hyxTlDePBbJkeritec0rU4P/5ahTfpapsmcumRr8VwHnRssUy8xzDmnzdmg3cX+o+m7CgXMyBaeyX9tEGVx1qWwa1+VvJv9VXapyTeYs1w5P5dpRsFwG/68ClaucUq5ywXJNZpSLfWmD/7eiXKoP43l5bMtq3MpzgQb/x0DP2qUar+OccJxG291lWUzeVwdKeryOdq/S7i63yw+IE9sO1ScqP2860nqOeVgHXP9KX0rw7lA76ipjSdBBf1KNrVkHcG+hosk6YPD/JfmfpQPop8dptN3N82LyvjpQ0jqA/QHrgIoPcfUfqh/l+ZY48Z0R2A6UDvBcR1bsxqF21FVG1AFck7a5jmGPuR9NEJxvMfebHfNeNOb8vIu5X5hdW2g0lmuNhdXWQm12M2PuL0kQxO3yMrKVFUEvhrvOAVdK+X8Wh3g32u5+N+wx9wfAh4nTMMbcX0V2C8vuez7sLE3Cj++YN9OdYdhL9Mnk+dyO+Z9Z3bqLxZ3Mxznc7uBXvgme1h8/XxJ1w2f5PzzvWw5S352TvgPFrs6Hil19C8knTOxq6FsfavOu2NVz+jw4iMF7wlFXJX/lqapY8hLRDqTnudeXjP5EFFKvOutLo8QPy4ftTKC9Gz3rushPRciH4xG47nC8qeZ1EO8IweOzfY/vDib/XWc4lSgvivTcEvorV1PZQsWilolO2QMd1o84LSb/qwOlepXXHZGOikvhNh0mJrS+dUaiWz7n1BmJL07+qzMSuU0XOSOxSWVDv27QNo18uc4LC+E/Bzp3dJ51Mor8+jNctz71XcVk++RfzXVirNoheI95ak6b+0eEfyXgvDV5zoqfUDHK3K9MptBDe85rOq8GXl6fPOe/p5EjldKS1dwOgl9M/lcHTFNUKqRhtHEVdjN6qfVZLuI1VC+lVq5RPtxL7QwjnypGNmEveajdKxvmg08KQ4vM0asqegC1WrWgEcrjOkHZ7RC0S1F3y18fNad8xydaGfy3Jf9jvt8O8CgP5MUV9es6yQ35Uafh7aI85f2rGQXsHeM0Cnk+R3mxfN4FfGB54lRpd8tCyQ7hi8rO2vM0waMc1YgAaXL9sT5x5HVZfFcSeNQsFp+cladni5OtKBjes//hXQXwxmmjd+ta9P4w79a1HRrnwi13yb/zbnV0mE7Eeq/BPvP3dPKctTr33Q64Usr/szjEu9F297thX537ePJ7mFfnbFfGMK7Ome6cP6tjs82t1TF32lodK5Jqa1urY275bK2OnQ+rY/VqHh8B6V9gq2NrJcKP/GytjhX3NbdWx7ZWx4yfNJ3bWh3bWh0rmgKvjq1trY6l87+1OvZs2lody5+2Vscy5LO1OgawW6tjg+nS1upYNy9bq2PPpq3VsYSnBP/W6tizaWt1rJNG293vtlbHnk0XwurYTQmCc3t1rLlhe8cCzQrXw86C6/tisCw8u4v2wb5RMyl2T8zZ8yejzvOlgC9OeFcMj78CrRAFPvu/WhumFaLIH+7quX0+fef8+FsBfwj5BDqfvqrOp/fIf81W/5YTfPEYxFZAnpnVeeWx1dajrdV7lh544MixB+5urZxonXr5ybtbz7w+wZOovFCCCzucTEyMo0S/Rxw4okhPqOHiR56jHgNN0jbzuFxIf6OOesx7FIvJbpvgVV1ZnLbwh3S2CToK14hHXFzfWB+Lyf9qsdTgF6GPDeVFGUyWNyHKXBLwPORDvuP/DwJehmOaWE8TlIf6MEl52OZ2UB7W3RTlsX1Q/6Mo38INfjeSUi4fdFBG7FqFWlzmo1DHPNLBurO6Usef8VFLRdtwRdBRi+XW9cZ8LabQVMegxsncGg4ueE3UwXlz8hw2+KI6x/qPiY9ZQ/1VC7asz2gbWAfV0Wp57QZewfZuwMtwXA41Da+mH9eH1lFvHb02+R/z/G3wDeI0vpHXOOVZTM57VC1fDTNsfYCqZ9YPXH5g/cCpf7YrOO2NMuGU1ed8BvAynCVVz8qmIC2e2i4LftFuDPsU7APJ782egsUhg6vPDDzszu1jr0/pRb19cggfu0z8sHy4/anAMO7X43So3YHjvLJ4N7LBuDYvuLM6k1cXhjW4k8eq+C37RHE61O7AcZ6rzztXcNn3cXIdv6nGIq7gSvMXlQ9u00Rs43ZF6XVjfOHVHFHUW07DzYE3eHQo96M+p5LYpiOtwL7trBqHWFLjPq53dXy58nu53pXfWxI8ZPm2vwN4Gc6S0pES5bnCSrje46TGqhXKUwGIKiwg7VjcOOH0IuKMIh1OYn6VCkhL8xNc4SLsz6mxbJy4DRn855L/gX1w2Ya2O8pXdpRPyfVwW5fvF5L/MewP56CndIp1UbUpy8M2xXWkgn9dZTD4n0z+89HRcdr4Y8yrzZiPi4EP5PUs/+3ucqtjzBGex5SDHGPONkT1oao9sp6NCXjEx3r2c8n/WDbPL3Xzhzo/Qbxj2V2hSWy7ULfGgeffTp4Dz9Fv2JwL90uoB0X7JZNF0X6Jw8IwT829Kzux+eF9ut3inAi3W2yjZQHP7TarnZv/OB311iXrN7aZccpDutw3qzkM15UG2GbSxucVUYb4u98DfFiPaN/xW7bvBv914OUPkmflE7F+KbvEvESRtnuusUOeOfDAPnfuMekwbE5SY7LA/tT69a9q/lXVcxwmvjPqrTPkb93+wPcWXpDHR1d+uMsWboSPjrSzNnpwHat2zO0c4f9b8j/Ot2tkXeOXEvEXRe46dNU5ytd4dc25q3op0bOy/67rZ1z2X/GFPgBvLZmg364yuPRO+eOb2AfPqD4Yy859sMsXjhPXgdqWovzjaYJHmat2yb4p0nVtFXG1S/Rbrb24+i+0s7w+odon9tHnc+jzc0qd8l4BunUWVtCL4W5wwJVS/p/FId6NtrvfDXvo83Vgm+M0jKHPVycfDWPos+nOMFzbcVnyfI6HXs9uhV67k/Ujh9rd+KOot2/Hvgu/Ueuth5O87RFst4o66/Mc+xai3rk/9Sm3PYJ/nme+KPkd+wnXJc9Hjq2caL25dezUy9/ylq4g1rOBrRbJGlHilewS/c6KSj0XNnNZUP5mRxIsJM/nuOWb3yjLF8gyNQOvAErLp1ZKywTH38T5Luu4UUeNBZJTPfCMVCPPyATpDxqpirQmoqA67Ixwd0Wy+JyBVLg2s05R1linZ2HanbwRyhuFvDHKQy8eV8mvAThug+zZYF9lq7oxjhsB3wuS58Dey/xmei88ao4iPdo0mW/WZvrnJ7+HeTP9geR5Mup4hQ3Al9ZG0I/j1Qk1IxO4PdeNVxU5pqLvY4/Xji49eer4idYrjx1+tLVy+tSR48duXlp5sBVRwsaHijkSpXfMWFCFowzfq3QuOMXzye/NdoqvTJ63nGJnagR2xpqhz3FTTrEyOKbDtoyFz8aTwdwKMLcCTJz6nVZQnfYtlKfCKHFYjmctn88dunU8ZpBj43xN8nzs+Kkja48dPvbw6dbp1uqdp5ePHlm55fSxlWcN9dGjESV2ukv0mycq2CaPCjyc8LsSlGHYbfUVye/NttW4/SdOeIZ4CFt9cRj8VRUCdQk8X0zlRN1b9MSD4TM9qES9iZeP1p1I4q/kn79aREktI1nak/y/GN5dksIrh4ot+uG3bvgDnSIodQaXvCcpz+pO2aNSym812ZoGW3LgnRJ5htPqCvm1clj/hafyGV6fssRl5AD41+1HqEkIpQt8fncU6TbDfgDbVM+8Lq0PuoGHMtFkHhFG6S8vBozS+3IOWKW/GGbE/PF3HFLD73giJxLw6wP15H8lBReGFyE8h2+HqsM9gifj/f8HD99ZhjkkNwA=",
      "debug_symbols": "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KX3KmDKnrJdsx5SnW91ln1Km1ClfK4Y+WBL3ZTcfLHnI4XZ/qPlgySn7a33Se5tyuN0X43yw5CF1SpvydLO7jClzynrJwZKHbFP2KU83v0ud0qb0KWPKfEk9LfQu25R9SplyVkhnhdSnfN0arjnlWaH7FbJjyjZln/J0u18h0yltSp8yphwVuoPUT4AMeQLkPmjwEyCn7FPKlMPtvr7uJ0BO6VPGlKfb/QKcABnyBMgp25R9SpnytBh7Pj5lTJlT1quQOSuUs0InNUY7nNS47/P4SY1TDrccf+tTDrf7ro+f1DhlveRJjTvXfVAj7yj2QY28b8v4oMZD6pQ25L04gxoPGVPe3fLOVB/UyPsuXQxqjI+tx6BG3okYgxoPOdzuHT0GNR7Sphxud8LEoMZDDjcbcYfbvaFiUCN9bKa1KfuUMqVOOdzG7tmgxkPGlDllveSgxkO2KfuUMqVOOd36dOvTbVBjfB0pBjVOOaiR91y0GNSo+8QmBjXq/liMQY3xJbMY1Kj7kYkxqDE+xRWDGg95dxvfoolBjYesIe9xB0Aecrjdh2oxADLOV4kBkIfUKW3K4SZj6zKmzCnrJQdA6v4kiwGQhxxu9xFeDICM75HEAMhD2usSDoA85Fm3e5tZTjnc7gPDGACpsdE6ADKOGY0BkIeUKXXKUbd71lwMgDxkTJlTDrf7WC4GQB5yuI292QGQuo+5YgCk7h0yxgjkIW1KnzKmzCmH231XNwZLHrJN2aeUKXVKm9KnjClzyulW062mW023mm413Wq61XSr6VbTrV5ueRxTtin7lDKlTnm65V36lDFlTlkv2Y4p25R9SplSp5xubbq16damW5tufbr16danW59ufbr16danW59ufbr16SbTTaabTDeZbjLdZLrJdJPpJtNNpptON51uOt10uul00+mm002nm043nW423Wy62XSz6WbTzaabTTebbjbdbLr5dPPp5tPNp5tPN59uPt18uvl08+kW0y2mW0y3mG4x3WK6xXSL6RbTLaZbTrecbjndcrrldMvpltMtp1tOt5xuNd1qutV0q+lW062mW023mm413erlVscxZZuyTylT6pQ2pU8ZU+aU022ypCZLarKkJktqsqQmS2qypCZLarKkJktqsqQmS2qypCZLarKkJktqsqQmS2qypCZLarKkJktqsqQmS2qypCZLarKkJktq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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "get_note_internal",
        "random",
        "check_nullifier_exists",
        "notify_created_nullifier_oracle_wrapper",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "slash",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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K49WHq08uDy4PLg8uDy4PLg8uDy4PLg8uDx6efTy6OXRy6OXRy+PXh69PHp59PKQ8pDyiDj3IC7qRVKkRaPIijwp4nwSFZWHloeWh5aHloeWh5aHlscoj1EeozxGeYzyGOUxymOUxyiPUR5WHlYeVh5WHlYeVh5WHlYeVh5WHl4eXh5eHl4eXh5eHl4eXh5eHp4eUbh0ERW1Ii7qRVKkRaPIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqOVRyuPVh6tPFp5tPJo5XHG+eAgK/KkM86HBlFRK+KiXiRFWjSKrMiTenn08ujl0cujl0cvj14evTx6efTykPKQ8pDykPKQ8pDykPKQ8pDykPLQ8tDy0PLQ8tDy0PLQ8tDy0PLQ8hjlMcpjlMcoj1EeozxGeYzyGOUxysPKw8rDysPKw8rDysPKw8rDysPKw8vDy8PLw8vDy8PLw8vDy8PLw9MjiqMuoqJWxEW9SIq0aBRZUXlQeVB5UHlQeVB5UHlQeVB5UHlQebTyaOXRyqOVRyuPVh6tPFp5tPJo5VFxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedScS4V51JxLhXnUnEuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXnWnGuFedaca4V51pxrhXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4HxXno+J8VJyPivNRcT4qzkfF+ag4j9qv4UG9SIq0aBRZkSdFnE+iolZUHlweXB5cHmec2xFkRZ50xvlFVNSKuKgXSZEWlUcvj14eUh5SHlIeUh5SHlIeUh5SHlIeUh5aHloeWh5aHloeWh5aHloeWh5aHqM8RnmM8hjlMcpjlMcoj1EeozxGeVh5WHlYeVh5WHlYeVh5WHlYeVh5eHl4eXh5eHl4eXh5eHl4eZxxbhTkF0Uh2UVU1Iq4qBdJkRaNIisqDyoPKg8qDyoPKg8qDyoPKg8qDyqPVh6tPFp5tPJo5dHKo5VHK49WHq08uDy4PLg8uDy4PLg8uDy4PLg8uDx6efTy6OXRy6OXRy+PXh69PHp59PSISp+YXh0XowWdf9CDrMiT4sQnUVEr4qJeJEVaVB5cHlwevTx6efTy6OXRy6OXRy+PXh69PHp5SHlIeUh5SHlIeUh5SHlIeUh5SHloeWh5aHloeWh5aHloeWh5aHloeYzyGOUxymOUxyiPUR6jPEZ5jPIY5REJLibpR4Kb1Iq4qBdJkRaNotNDg06P85EXdUEXUVEr4qJeJEVaNIqs6PJoUSB0ERW1ooeHH0G9SIq0aBRZ0cPDWyxLcBRRUSviol4kRVo0iqyoPFopn2nNOUiLzr/tQVbkSWf8XkRFp4oGcVEvkiItGkVW5Eln/PpcjIGKWtHpEVc8VhE44gLGOgJHnFOsJHDhABrQC2NFgQv5RAnsQCmM+f+HBQpQgQNoQC+MtQAuJGADMhBuA24DbgNuA24DbgY3g5vBzeBmcDO4GdwMbgY3g5vDzeHmcHO4Odwcbg43h5vDzcstSngSCdiADOxAASpwAA0IN4IbwY3gRnAjuBHcCG4EN4Ibwa3BrcGtwa3BrcGtwS3W7aAjUIAKPI/hWp/EgF4Ya3hcSMAGZGAHClCBcOtwiyikM3/MNXIuJGADMrADBajAATQg3GKtD+JAAjYgAztQgOE2AgfQgF4YMX8hARuQgR0oQLgNuA24DbhFdMeSG3PBnQs7UIAKHEADemFE94UEhJvDzeHmcHO4Odwcbl5uUbiTSMAGZGAHClCBA2hAuBHcCG4EN4IbwY3gRnAjuBHcCG4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbgw3hhvDjeHGcGO4MdwYbgw3hluHW4dbh1uHW4dbh1uHW4dbh1uHm8BN4CZwE7gJ3ARuAjeBm8BN4KZwU7gp3BRuCjeFm8JN4aZwU7gNuA24DbgNuA24DbgNuA24DbgNuBncDG7IJQ25pCGXNOSShlzSkEsacklDLmnIJQ25pCGXzDWGyAM7UIAKHEBLnMsMzVWpZgKZ2IAM7EABKnAADeiFBDeCG8GN4EZwI7gR3AhuBDeCW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Mbw43hxnBjuDHcGG4MN4Ybw43h1uHW4dbh1uHW4dbh1uHW4dbh1uEmcBO4CdwEbgI3gZvATeAmcBO4KdwUbgo3hZvCTeGmcFO4KdwUbgNuA24DbgNuA24DbgNuA24DbgNuBjeDm8HN4GZwM7gZ3AxuBjeDm8PN4eZwc7g53BxuDjeHm8PNy60jl3Tkko5cEoVHdK4L1qLyKFGAp1vjwAE0oBfOpQQnEvB0a+E2FxSc2IHh1gMVOIDhNgK9cC4vODHcPLABTzc+AjtQgKcbx2lGLrnQgKcbxzFELrmQgA3IwA4M3TjNyA+sgaEQhx754UIGdmAcb5xQ5IcLB9CAXhj54VxcpUXxUWIDnm49TjPyw4UCPN36/LcDaEAvjPxwIQFPtx6NIPLDhR0oQAUOoAG9MPLDheEWlzryw4UM7EABKnAADeiFkR8uhFvkhx7NKPLDhR0oQAUOoAG9MPJDjwYT+eHCBmRgBwpQgQNoQE+MaqVEAjYgAztQgAocQAPCjeBGcCO4EdwIbgQ3ghvBjeBGcGtwa3BrcGtwa3BrcGtwa3BrcGtwY7gx3BhuDDeGG8ON4cZwY7gx3DrcOtw63DrcOtw63DrcOtw63DrcBG4CN4GbwE3gJnATuAncBG4CN4Wbwk3hpnBTuCncFG4KN4Wbwm3AbcBtwG3AbcBtwG3AbcBtwG3AzeBmcDO4GdwMbgY3g5vBzeBmcEMuEeQSQS4R5BJBLhHkEkEuEeQSQS4R5BJFLlHkEkUuUeQSRS5R5BJFLlHkEkUuUeQSRS7RmUs0MNw8kIEdKEAFDqABvXDmkokEhFuDW4Nbg1uDW4Nb5JJzjZwW5VIXRi65kIANyMBT91yYoelcxPh88upcxnhiKPTABmRgBwpQgQNowHCLGzCXNp5IwHCL2zIXOJ7YgQIMtxEYuue3tM6FjScSsAFPXY3rEJlA44wjE2hcksgEGscbmUDjyCITaBhHJpgYmeBCAp5uGkcWmeDCDhRguMWNjfAfcTgR/iMOJ8L/rHFvURX16CgNPC1GnFCE/4UdKEAFDqABwy2OIcL/wlatZC6CPLEDBYgWFTF/oQE9MaqjEgnYgAw83c6B9zbm4sgTFXi62fy3BvTCiPkLCdiADOxAASoQbgS3iPlzoLZFxVRiuPXABgw3DgxdDRxAA3phRLeNQAI2IAPjO2D+mQAVOIAG9EJ8dYz51TGxAWXWPrQoj3p0oQcOoAG9MEL+wjgJD2xABnagABU4gAY83WKEOYqlEgl4usVQcNRLUYwAR8EUxdBuVEwlKnAADeiFEfIhGxE/qRdJkRaNpAi/GOqNqqVEAjYgAztQgAocQAOWW9QvJRKwARnYgQJU4AAaEG4EN4IbwY3gRnAjuBHcCG4EN4Jbg1uDW4Nbg1uDW4Nbg1uDW4NbgxvDjeHGcGO4MdwYbgw3hhvDjeHW4dbh1uHW4dbh1uHW4dbh1uHW4SZwE7gJ3ARuAjeBm8BN4CZwE7gp3BRuCjeFm8JN4aZwU7gp3BRuA24DbgNuA24DbgNuA24DbgNuA24GN4Obwc3gZnAzuBncDG4GN+QSQy4x5BJDLjHkEkMuMeQSQy4x5BJDLjHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy7xyiV8VC7ho3IJH5VL+KhcwkflEj4ql/BRuYSPyiV8VC7h44AbwY3gRnAjuBHcCG4EN4IbwY3g1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDGcGO4MdwYbgw3hhvDjeHGcGO4dbh1uHW4dbh1uHW4dbh1uHW4dbgJ3ARuAjeBm8BN4CZwE7gJ3ARuCjeFm8JN4aZwU7gp3BRuCjeF24DbgNuA24DbgNuA24DbgNuA24Cbwc3gZnAzuBncDG4GN4Obwc3g5nBzuDncHG4ON4ebw83h5nBDLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5JJZF3mWUPOsi5w4Q3riw6KdhdUcdZGJDOxAASowur2CrMiTYkOms+yaoygysQHDqgd2YFjFKcTmTBcOoAG9MDZpupCADcjADoSbwc3gZnCLbZvO4lueGxZeSMAGZGAHRrdOkBaNIivyi1rtpRblkO3wwPNIzyJfjsLHRhRoQC+M7ZouPI/0LG7lKHxMZGAHCjDceuAAGjDc9MTYwulCAoZbnEVs5HRhuMUJxWZOFyrwdGtBVuRJsafTJCpqRadii0sUmza1uAKxddr8B7F52oUEbMDzSFucYGyidqEAFTiAp5sEeVJspzbptIp/FxuqTeKiXiRFWhQmU8aAXhhRfGEcZlz8iNcLT4W4p7F92iRPinhtcWsiXi9swPNAOa5pxOuFpxXH5Y14vXAAwyuuacQrh1vEK8eJRbyeRRwc5YiJDOxAASpwAA0YbnHoEa8crSritcehR2T2OMjYXK3HQcb2ahcOoAE9MWoQEwkYYhyowAE0oBdGqF5IwPizHmhAL4yYuzD+TAKjfWkgz+2DmHPnJubcuok5925izs2bmHP3Jubcvok5929izg2cmHMHJ2YuDy4PLg8uDy4PLg8uj14evTx6efTy6OXRy6OXR4RbH4HnBfGgVsRFvUiKtGgUWZEn1UaG2MkQWxliL0NsZojdDLGdIfYzxIaG2NEQWxpiT0NsaohdDbGt4dy8sE/0woi1C08hicYSsXYOjvLcxlCi3URUSbSbiJRzAJHntoQa/zaebBd24HlyGg024ufCATSgJ85tCi8kYAOGGwV2oADDzQNP3XEeztyk8MJTd8S/jafehQzsQMGfKXAADQi3BreIwAsbsANl7qbFUVV30SiyIk+KwJsU4i2wARmowDi8uIbxqBs9kIANyMAOFKACBzAuRhxZPOsmRvRdGG4a2IAMDLcRKEAFDqABvTDC8EICNiADw80CBajAcIu2FOF4oRdGQF54ulnc0gjJCxl4ulnci3hEXqjAATzdLG5WhO3ECNsLCRhucQMibC/swHCLM45gvnAADeiF8Yi8kIANGG5xoeaepHGac8fRM3pk7jk6kYANGBmQAxU4gAYM3fOEZO44OpGAoauBoTACDeiFc2fRiQRsQAZ2YByvBSpwAK1w7izqgQ3IwA48c0B8Qs39DS8cQAN6YTwdLyTg+Xw84vrGw/BCBQ5g6LZAL4xdDi8kYAMysAMFGGJx32JjwwsJ2IAKHEADQmxAbEAs9jOMj8W5o+GFHShABQ6gAb0w9hi9MNwksAF57kXItc0h1z6HXBsdcu10yLXVIddeh1ybHXLtdshRa/Z4VwxkYAcKUIEDaEBPjFqzxNAdgaFggWNucMhzh8NJnhR7HE6iolYUih7YgQJU4ABa4dxk9AiMV7rQne+mE0+FFjSKrMiT4hk5iYrixZEDGdiBAlTgKJyvoz0wFCSwz40fOcrALtKi84LOv7YiTzpD7SIqakVhErdo7io6UYBWOPcNjXs4dw6dyMDzMONCnA+7i7RoFFmRJ819fOMWzZ18JzYgAztQgAocQAN6ocHN4BZxF5/tUe2V2IGnW3y6RrVXYrSTuBWx1298D0e1F7e4cLHf74UEDLcwjgC88HSLz9wo/OL4vojCr/iyirqvi6zIL4qir4uoKBRb4Hmk8TEcZVwc73hRxnVh7PJ74XmkHAqx0++FDOxAAYbueYJRmsXxMRylWRwfw1GaldiBAlTgABrQCyMILzzdIrVFwVYiA0+3SCNRsJWowAE83aJhRsHWhRGcF9LcjpSjXusiLjoDIU484nWSFo0iK/KkeDRGcEb5VmIDMlCBcZhnI4ySrMRQiPsZIXshA/vcO4xrp0OurQ659jrk2uyQa7dDru0OufY75NrwkGvHQ64tD7n2POTa9JBr10OubQ+59j3k2viQa+dDrq0PufY+5Nr8kGv3Q67tDznWsOIZDRGhF3phROi8/hGhFzbgecniyzUKwhLjyyqufzwiLxxAA3piFIRxfBFHQVji6RZfxFEQxvFFHAVhfJbfchSEJSow3CzQgF6YO7Wx5VZtPPdLnMRFvUiKQvFs01HexfHlHeVdHN/CUd6V2IECPI80PqyjvCvRgF4Y0XwhzS3EOOq44mPbcvU5rhWouFag4lqBiqMsizX+OHptLhSgAgfQgF4Y4XghARsQbgI3gZvALXbn1rht8Vy90AsjdC8kYAP2vAa55hxbrjnHUYjFGnc93m4v9MJ4yl5IwAY8zya6DaIQK1GA59lE10UUYiV63qRcFJ4tF4XnKL2KfoGovLqoF4V4C1TgABrQCyNkLzxPZYpFyF7IwD5XU2TLVSbZcpVJtlxlki1XmWTLVSbZc5VJ9lxlkj1XmWTPVSbZc5VJ9lxlkj1XmWTPVSbZc5VJ9qM8qDyoPKg8qDyoPKg84o03ekeiwirRgHHNznCOCqtEAjYgAztQgAocQAPCjeEWD+d5vPFwvpCBHShABQ6gAb0wHs7R6xIVVokNyHMZS44Cq4ukSItGkSVF6EePTdRL8fVfzyONyIt6qcQBNOB5pNH1EvVSiQRsQAaebtHJEvVSiQocQAN6YYT8hQQMt7hwEfLR3xL1UhydLFEvlajAATSgF8aL9YUEbEAGws3gZnAzuBncDG4ON4ebw83h5nBzuDncHG4ON0+3HvVSiQRsQAZ2oAAVOIAGhBvBjeBGcCO4EdwIbgQ3ghvBjeDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MZwY7gx3BhukRnOzrwe9VKJ4dYCB9CAXhiZwSWQgA3IwA4UoAIHMNw00AsjVZydeT2KpBIZ2IFhYYEKHEAD+pV3ehRJJRKwARnYgQJU4CjMfVt7VENd1Ioeohq3JPdu7Udu3tqPmSSmzAAa0AtnkphIwNMpLku81k/qRdHpFVaz12viAD6sznfHXrs+9tr1sdeuj712fey162OvXR977frYa9fHXrs+9tr1sdeuj712fey162OvXR977frYa9fHXrs+9tr1sdeuj712fey162OPeqd+9qf2qHdKbMDoJmyBHShABQ6gAb2wHUAChlscTmNgB56npUFaNIqsyJNi06hJodgD40glMI50/gMDemE/gHGkFtiADOxAAYabBw6gAX1uA9Upt4bqlFtD9bnV4yQu6kVSpEWjyIrKQ8tDy0PLQ8tDy0PLQ8tDyyN62s7ezh5VUp3iTo0DSMAGZGAHClCBA2hAuBncDG4Gt+jjprj50cl9oQAVOIBWGL3aFO1gzpAO0qL4o7gg0Wl2oSdGyVMiARuQgR0Yh+iBChzA6Og8Ar0wovlCAp5uZzdjj0qofpYE9aiEShxAA4bueZpRCdXPzscelVD9rMDpUQnVWxxvxG2LI4u45TA+4zZRgQMYvcpxZM0L+QASMHqWOTAs4nA4LOJwIrzP/sEe6751jsOJ8O5xQhHeEyO8LyRgAzKwA6OPPI5hdpJPtGwjUSZ1YfSOXxgWcbzRP34hA8Ni/lsBKnAADeiFegAJ2IAMhJvCLbrTe1yz6E+/MNziHkeYT4ww73GpI6Al7mYE9IUCVOCpK3E3I6Av9MII6Aspk3XUUSUysAMFqMABtMIIaIm7eT6vExnYgXEWcY+jm/zCATRgdIWcpxl1VIkEbEAGdqAAFRhX54zCKKlKJGADMrAD4ywkUIEDaEAvjOiO97Oor+rxshQFVv3s/etRYZVowFA4204UWSXGmEGcUMTxhQw8j/fs1+tRaZWowAE0oBdGSF8Ybi2wARnYgQJUYHTrxuWLOJ7XIeL4QlydiON4m4oarEQBKjDOIq5vxPGFXhhxrHGpI44vbMBwi0sdcXyhAMMtDj3iWOMGRByPuNQRxyMuVMTxhQQ8dUdch4jjCxU4gKEb5xYRO1tJROyFDOxABcaYS2B8dF9IwBjhiXOLj+4LO1CAChxAA3pilGslngd59mn1KMxKFKAC4+Ql0IBeGGF6YZwFBzYgAztQgAocQAN6YXxIn6OovTcGxllooAAVOIBxFvPPvDCC90ICNiADY9Q0ruQchp6owAE0oBfOwemJBGxABsZZTBxAA3phBG98gkb9VmIDMjDOIu7bHKWeqMABNKAXxtfzhQSMIbsjUIAKHMAYtqNAL4wwvZCADcjADhRguLXAATSgF8ZD2KJxRUhf2IAMzEKHHpVaiQocQAN6YcT8hQRswCjBiHYWD2GLKIyH8IUGjLM4r3rUb/WzwKtH/VZiAzKwAwWowAEMt7PBRP1Wj64kmSUj8Q/iwRpdSVG/leiF8TJ9YSi0wAZkYAcKUIEDaHUM0SE2MTrELiRgAzIQZzGruiYqMM7ivPNRv5VIwAbkq2azy6zDnChABQ6gAb1w1mFOJGBMZYjbHRWXFyowrs5EA8ZZnC0qCrwSCRhnEWccj9sLO/AcxozOoagASxxAA3ph9IJFl0ZUgCU2IAM7UIAKHIUxlB19HFHVFRMkepRwSbz0Rg1XogHjyOLf+gGMI4vr4A3IwDiyuA4uQAUOoAE9MQq5EsPNAxuQgR0oQAWOPOOo8JLok4gSr8QGZOCpGxkmirwSFTiAOemmx/JgF0Yd5oUEbEAGdqAAz6tzLiHTo/rrQj6ABIyz4EAGdqAAzwiYp8kDaEAvjHrqCwnYgFw4N0GLSz13QZsoQAUOoAG9cO6FNpGADQg3hdscnB6BChxAA3rh3BVtYuhG25l7oE0UoAIH0ICn7rzUsVHQhQRswNMtOoui3CtRgF66c8uziQRsQBy649BjW6DpFvsCXTiABvQ0HnPzs4lUODf7iO6ZuURWsoPnfh/RLTNXyTrOIrA+l8lK5oX7whLMwbrwWNjAPPXj2HjqSLAsrAvb8u/nMZ/tZi6JlUwLt4V54b6wLDy9LHgsbAtP3/PmzDWzkmnh6TuCeeG+sCy8nKOMhW1hB+uxMC3cFuaFl2ury7WNGIpurLmz4IUEbEAGdqAAFTiABoSbwc3gZnAzuBncDG4GN4ObwS1CL17S526DFxKwARnYgQJU4AAasNyufQcnErABGdiBAlTgABoQbgQ3ghvBjeBGcCO4EdwIbgQ3gluDW4Nbg1uDW4Nbg1uDW4Nbg1uDG8ON4cZwY7gx3BhuDDeGG8ON4dbh1uHW4dbh1uHW4dbh1uHW4dbhJnATuAncBG4CN4GbwE3gJnATuCncFG4KN4Wbwk3hpnBTuCncFG4DbgNuA24DbgNuA24DbgNuA24DbgY3g5vBzeBmcDO4GdwMbgY35BJDLjHkEkMuMeQSQy4x5BJDLjHkEkMuMeQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkEkcuceQSRy5x5BJHLnHkkrktaPSczn1BY9x0bgx6oRdGLrmQgA3IwA4UoALhZnAzuDncHG4ON4ebwy1ySXxkzq1CLxxAA/qFMrcLvTDcOLABGRhuGhhuI1CBA2hAL4xcciEBG5CBHQg3ghvBjeBGcGtwa3BrcGtwa3BrcGtwa3BrcGtwY7gx3BhuDDeGG8ON4cZwY7gx3DrcOtw63DrcOtw63DrcOtw63DrcBG4CN4GbwE3gJnATuAncBG4CN4Wbwk3hpnBTuCncFG4KN4Wbwm3AbcBtwG3AbcBtwG3AbcBtwG3AzeBmcDO4GdwMbgY3g5vBzeBmcHO4Odwcbg43h5vDzeHmcHO4ebnRcQAJ2IAM7EABKnAADQg35BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi5pyCUNuaQhlzTkkoZc0pBL2swlGjiA4SaBXjhzyUQCNiADO1CAChxAuBHcGtwa3BrcGtwa3BrcGtwa3BrcGtwYbgw3hhvDjeHGcGO4MdwYbgy3DrcOtw63DrcOtw63DrcOtw63DjeBm8BN4CZwE7gJ3ARuAjeBm8BN4aZwU7gp3BRuCjeFm8JN4aZwG3AbcBtwG3AbcBtwG3AbcBtwG3AzuBncDG4GN4Obwc3gZnAzuBncHG4ON4ebw83h5nBzuDncHG5ebnwcQAI2IAM7UIAKHEADwg25hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hJFLGLmEkUsYuYSRSxi5hGcu8RNnLplIwAZkYAcK8HQ7x3kk6vsSDRhuZ66O+j7jiQRsQAZ2oAAVOIBwi1wyMXLJhVTHMHPJRLgJ3ARugnMTnJvALXLJ/LeKc1Oc28wP8W9nJmgnzkwwkYANyMAOFKACB9CAcDO4GdwMbgY3g5vBzeBmcDO4Gdwcbg43h5vDzeHmcHO4Odwcbl5u/TiABGxABnagABU4gAaEG8GN4EZwI7gR3AhuBDeCG8GN4Nbg1uDW4Nbg1uDW4Nbg1uDW4NbgxnBjuDHcGG4MN4Ybw43hxnBjuHW4zUwwAk+3cz0OiWLBxA4UoAIH0IBeGJngQgLCTeAmcBO4RSY4V/+QKCFMNKAXRia4kICR5SyQgR1omSr6TBWBM1VMJGADMjAOfaIAFRiH3gMN6IWRKs65BBJ1g4kNyMAOFKACB9CAXhiposfJR6q4sAEZ2IECVGC4eaABPTGqCRMJ2IAM7MDT7ZwfIFFNmDiABvTCSBUXErABGdiBcCO4EdwIbgS3BrcGtwa3BrcGtwa3BrdIFee8A4l6xEQvjKRwYShIoAIH0IBeGOF/IQEbkIEdGG4WqMABNKAXRvhfSMDT7ZxsILGeXGIHnm4apxnhf+EAGtALI/wvJCDcFG4Kt/ioOOcHSNQjJg7g6Tbmv/XCyA8XUv3byA8XMrDj3wpQgafbiOON/HChF0ZsjrgXEZsXdmB9rgs6BwSdA4LOAUHngKJzQNE5oOgcUHQOKDoHFJ0Dio5GRUejoqNR0dGo6GhUdDQqOhoVHY2KjkZFR6Oio1HR0ajoaFR0NCo6GqPG0M6KfYkaw0QGdqAAFTiABow7dLbqqDxMJGADMrADBajAATQg3CKOz9J7icrDxAZkYAcKUIFw63CLOD4r4CUWq7OzwF1itbrEBmRgBwpQgQNoQC9UuGl9Gs3ixgsZGG4cKEAFDqABvTDi+EICxrnFPY44vrADBajAATSgF8Zz/kICws3gZnAzuBncDG4GN4NbZA2LCIj8YHFjIz94XN/IDxca0BNnneOFBGxABnagABU4gAaEG8GN4EZwI7gR3AhuBDeCW+SHs7JeohTzwsgPFzIwFHrgABrQCyPmLyRgAzKwAwUYbiNwAA3ohRHzFxKwARnYgeFmgQocwPqsHviIH/iIj9JLO1eDkKi8TGRgBwpQgQNowIebH3GHzphPJGADMrADBajAATQg3AbcBtwG3AbcBtwG3AbcRujGhbJQiBtroRDX1zpQgAocQAN6oR9AAjYg3BxuDjeHm8PN4eblFgWWiQRsQAZ2YLh5oAJHIR3AU+Gsi5comkwUoAIH0IBeeMZxIgEbMNxaYChwoBfyASRgAzKwAwWowDjeHmhAL+wHkIANyMAODLe41F2BA2hAL5QDSMAGZGAHwk3gJnATuAncFG4KN4Wbwk3hpnBTuEUcUzSYiOMLvTAi9sJTocXtjti8cAAN6IXn8ziRgA3IwA4Mt2hREccXDqABwy2aRsTxhQRsQAZ2oAAVOIDhFq0k4jgwihsTCdiADOxAAYabBQ6gAb0wovtCAjYgAztQgHAjuBHcCG4Nbg1uDW4Nbg1uDW4Nbg1ukR/i1TKKGy+M/HAhA0+Fc1KHRMFiogG9MGL+QgI2IAM7UIChe7aoKDf0eDRHuWGiABU4gAb0wojYCwkYRxaNICL2wg4UoAIH0IBeGE/e6HaLcsPEBmRgBwpQgQNoQC80uBncDG4GN4Obwc3gZnAzuBncHG4Ot4hujgYT0X1hB44LNUoI/ez31CghTGxABnagABU4gAb0wojYc20WjRLCxAZkYLhxoAAVOIAG9MKI2AsJ2IDh1gM7UIAKHEADemFE7IXhZoENyMAOFKACB9CAXhjRfSHcOtw63DrcOtw63DrcOtw63ARuAjeBW+SHHi0q8sOFArTCiHmJ9hAxfyEDO1CAChxAA3phxPyFoUuBHShABQ6gAb0wovtCAjYg3AxuBjeDm8HN4GZwc7hFdEs02ojuCxnYgQJU4AAa0BOjANDPJVI0CgD97PTVKABMZGAHClCBA2hAL6QcQtVZAHhhA4bbCOxAASpwAA3ohZEJLjzP7eyG1SgATGRgBwpQgQNoQC+MTHAh3BhuDDeGG8ON4cZwY7gx3DrcOtw63CITnOvkaBQAJgrQCiO6NdpDRPeFDOxAASpwAA3ohfH0nxjPY432EM/jCxkYbhIoQAUOoAG9MCL2QgI2IANhEaGn0RAj9C5swPizaFERehcKUIEDaEBPjHq5RAI2YAfGn51JNwrfEgkYf+aBDOxAASpwAA3ohRFDFxIQFhEM55pFGhVsF0YwXHj+2Tn6oFHBlsjADhSgAgfQgF4YwXAhLOL5di6ApFGKluiF8Xw7F6nQKEVLbEAGdqAAFTiABvRChUU86s7xFo1Ks0QFhpgEGtAL41F3IQEbkIEdKEAFwi0C5xxy0Kgp8xGtLwLnQgZ2oAAVOIDRARTnNrubAmd300QCNiADO1CAcXUiAiKyAqN6LDHOwgMbkIEdKEAFDqABvTAC8kK4Reid6wVp1In5OcChUSeWOIAG9MIIvQsJ2K7+dZ11Yhd2oAAVOIAG9ELOgT+dFWEXdmAOjilXpbpyVaorV6W6clWqK1elunJVqitXpbpyVaorV6W6codbh1uHW4dbh5vATeAmcBO4CdwEbgI3gZvATeCmcFO4KdwUbpoDfxrrwCUqcAAN6IVzIHgiAXPgT2dN2YUdKEAFDmAOjumsKZtoB5CADcjADhSgAgcQbpZVinrVlE0kYLhxIAM7UIAKHEAD5lCczpqyc+RKZ03ZhQ3IwA4UoAIH0IBeSHAjuBHcCG4EN4IbwY3gFsNK56CbdmSCWSd2jkbprBO7UIEDaEAv5ANIwAZkINwYbgw3hhvDjeHW4dbh1uHW4dbh1uE2B5vixs7BpolWOIeVJubgmM7arwsVOIAG9EI9gARsQAbm4JjGonKJChxAA3rhOIAEbMBwizsfMX+hALPCVWdx2IUGDLcz3mZx2IUEbEAGdqAAFZiDY9rNgF7oB5CADcjADhSgAuHmcPNyk+MAErABGdiBoXteKKF6W4mCrxiN0ij4SmRgBwpQgQNoQC9sBxBuDW4Nbg1uDW4Nbg1uDW4Nbgw3hhvDLd7XzzE1jQXoEgVohT0Hx1R6AzKwAwWowAE0oBfKAQy3uFmSg2MqcwBpogG9UA8gARuQgR0YxxuNYA4gTRxAA3rhOIAEbMAcrtIo4koUoAIH0IBeaAeQgA0IN4Obwc3gZnAzuBncHG4ON4ebw83hFnFM0WAiji/MoTiNkrHEHBxTPTpQgAocQAN6IR1AAjZguLXADhSgAnNwTHUOIE30wnYACdiADOxAAYZbDxxAA3ohH0ACNiADc7hKozgsUYEDaEAv7AeQgA3IQLh1uHW4dbh1uHW4CdwEbgI3gZvATeAW+SFeLaM4LNEKIxNcmINjqipABQ6gAb1wHEACNiADQzdalOXgmOocQJrIwA4UoAIH0IBeOAeQohHMAaSJDcjADhSgAgcwh6s0SrsmRmlXIgEbkIEdKEAFDqAB4UZwI7gR3AhuBDeCG8GN4EZwI7hFdMeYWqyxl9iAAqzBsdFqcGzwASRgAzKwAwWowAEMtxbohf0AErAGx8YcQJrYgQJU4AAasIbihhzAcOuBDcjADhSgAgfQgDVcNUu7LiRgAzKwAwWowAE0INwG3AbcBtwG3AbcBtwG3AbcBtwG3AxukR9iTG2WgV3IQAXW4Ngs7bqQgA3IwA4UoAIHsIbiZhFXjFzNIq4LGdiBAlTgABqwBsdmadeFcCO4EdwIbgQ3ghvBjeBGNTg2C74uJGADMrADBajAAQw3DazBsVkcdiEBG5CBHShABQ5gfOuFW3x3T6yZmjqLw2KcbBaHXcjADhSgAgfQgDVcNYvDLiRgAzKwAwWowAE0INwUbgo3hZvCTeGmcFO4KdwUbpEJJg64zaGtFtiADFRgKER7sANIwAZkYAcKUIEDWENxs1wrhtdmudaFBKzBsVmudWEHClCBA2hAL6QDSEBYzHEnDfTCdgBrcGzWXV3IwA4UoAIH0IBeyAcQFnMQ1gIN6IW9BsdmsdWFDcjADhSgAgfQgF4osJjjTkfgABrw/LMYBpt1VxcSsAEZ2IECVOAA1lDcLLa6MP6sBSpwAGtwbBZQTbQDSMAGZGAHClCBAwiLeNTF8Nqsj7qwA2twLJZjSxxAA/qFY9ZSXUjABmRgBwowdDUwdMeJc1hpIgEbkIEdKMDoAOqBA2hAL2wHkIANyMC4OhY4gAaMs/AT+QASsAEZ2IECVOAAGhBuEXrnoNuYlVDnkNmYlVAXClCBA2hAL5zzkuLc5rykiQ3IwA4UoAJHYXQmz0YQnckXNmAOIA0smzawbNrAsmkDy6YNLJs2sGzawLJpA8umDSybNrBs2sCyaQPLpg0smzawbNrAsmkDy6YNLJs2sGzawLJpA8umDSybNrBs2sCyaQPLpg0smzawbNrAsmkDy6aNuWzajKw5m3FiBwpQgQNoQE+cy6ZFW5/Lpl3YgAzsQAEqcAAN6IUEtxhAirY+q6YuZGAHClCBAwg3gtscVqLAHPgbc9m0CxnYgQJU4AAa0Av5AMKtlicZVMuTDKrlScZcNu0czBtz2bQLB9CAXtgPIAEbMIfixlw27UIBKnAADeiFcgAJ2IBwE7gJ3ARuAjeBm8BN4RZZ4xwZHHMptEg2cyk0j+urBvTCcQAJ2IAM7EABKhBuA24DbgY3g5vBzeBmcDO4GdwMbga3yA8eNzbyw4UE7MAc+BtzebMLPXEub3YhARuQgR0oQAXmwN+Yy5td6IV0AAnYgAzsQAGGmwUOoAFPt7NDcMzlzS4kYA78jbm82YUdKEAFDqABvZBzKG7M4rALG5CBHShABQ6gAb2ww63DrcOtw63DrcOtw63DLT5pj7hQUu9Gs07siOsrAlTgABrQC/UAErABGQg3hZvCTeGmcFO4DbgNuA24DbgNuA24zRmKcWPjNf9CK4wX+gtz4G/MkrELFTiABvRCP4AEbEAGhlvcrHhfP0fwxiwOu5CADcjADhSgAgcwB/7GLA6bSAeQgA3IwA4UYA7FjVkydqEBvbAdQAI2IAM7UIBwa3BrcGtwY7gx3BhuDDeGG8ON4cZwm7MZPdAL+wFkYA78De4DaEAvlANIwAZkYAcKMAf+Bs8BpIkG9ELNgb/BSsAGZGAHClCBA2jAcItWMg4gARuQgR0oQAXmUNzgYUAvtANIwAZkYAcKUIFwM7gZ3BxuDjeHm8PN4eZwc7g53Bxuczbj2aL6nM04kYAdmAN/ox8G9EI6gARsQAZ2oAAVGLpni4rSrhjBG70JUIEDaEAvjIi9kIANmAN/I0q7EgWowAE0oBf2A5hDcaP3BmRgBwpQgQNoQC+UAwg3gZvATeAmcBO4CdwEbgI3hZvCTeE2ZzNGg5lDyRMFaIUjB/5GHw3IwA4UoAIH0IBeaAcwB/5GnwNIExnYgTnwN7opcAAN6IV+AAnYgAzMgb8xS7suVOAAGtATZ2nXhQTMobgxS7su7EABKnAADeiFdAAJCDeCG8GN4EZwI7gR3AhuDW4Nbg1uDW5zNqMHClCBXsg58DdmadeFHShABQ6gAb2wH0AC5lDcmAVfFypwAA3ohXIACdiADISbwE3gJnATuAncFG4KN82BvzGLwy7sQAEqcAAN6IXjAIabBubA35jFYRd2oAAVOIAG9EI7gPGtF27WgAzMgb8xi8MuVOAAGtAL57DzRALmUNyYxWEXdqAAFTiABsyhuDFLxi4kYAMysAMFqMABNCDcCG4EN4IbwW3OxGqBAlSgF7Yc+BuzOOzCDhSgAgfQgF7IB5AK53BVD2RgB+bA35jlWhcOoAG9UA4gARuQgR0Iizl2q4ENyMAc+BuzRutCBQ6gAb1wHEACNiADYTEHbC2QgA2YA39jlmtdKEAFDqABvdAPIAEbEBZzYOpMurPu6kIC5sDfmHVXF3agABU4gAb0QjqABIQF5Ry8MQuoJsbz7cIc+BuzgOpCBnagABU4gAb0Qj6AsJiDTT1QgQOYA39j1lJN7AeQgA3IwA4UoAIHEG5zWqIG1sDfrJq6sAMFqMABNGAN/F0LYk0kYAMysAMFqMC4OmcEzPqoCwlYA3+zPurCDhSgAgfQgDXwN+ujLiQg3CL0YmRw1kfFAMdcEOtCA9bA36yaupCADVgDf3PH0QsFqMABNKAnzh1HL4whHQnsQAHW4JjVcpjDajnMYbUc5rBaDnNYLYc5rJbDHFbLYQ6r5TCH1XKYwwhuBDeCG8Gtwa3BrcGtwa3BrcGtwa3BrcGtwY3hxnBjuDHcGG5cA39zb9ELB9CANfA3q6YuJGAD1sDf3Fv0QgEqcAANGK3vzIizaupCAsa5xb+dsxkndqAAFTiABvTCOZtxIgFryGHuLXphBwpQgQNowBrgsJrZNObeotHFMfcWvZCBHShABQ6gAb0wBpsuzPkiY+4tGk+nubfohR0Y960HKnAUenUbzyW1LuxAASpwAA1YndSOTuq5X2i8RM79Qi9kYHUbzxqtCxU4gAasTmpHJ7Wjk3ouqRU9srNc68IOFKACB9CA1W3s6KR2dFI7OqkdndSOTmpHJ7Wjk9rRSe3opHZ0Ujs6qR2d1I5Oakcntc9Oag8UoAKrO3pWeUWv8KzyurADBajAATRgdVI7OqkdndQ+O6lbIAM7UIDVbTyLwy40oBeik9rRSe3opHZ0Ujs6qb2Wsh5eS1kPr6WsxywOi85kRye1o5Pa0Unt6KR2dFI7OqkdndSzpiwSk6OT2tFJ7eikdnRSOzqpHZ3Ujk5qRye1o5Pa0Unt6KR2dFI7OqkdndSOTmpHJ7Wjk9rRSe3opHZ0Ujs6qWfRWXQ8e3VS21Gd1DbLyy7MbmM7qpPajuqktqM6qe2oTmo7qpPajuqktqM6qe2oTmo7qpPaZiHZmVNtFoedPch2VCe1HdVJbUd1UttRndR2VCe1HdVJbUd1UttRndQ2S8bOzmQ7qpPajuqktqM6qe2oTmo7qpPajuqktqM6qW0uqXV22dpRndR2VCe1HdVJbUd1UttRndR2VCe1HdVJbUd1UttRndR2CNwEbgI3gZvATeAmcBO4CdwEbgo3hdvspI4GU53UdlQntc2FtiaO7Da2ozqp7ahOajuqk9qO6qS2ozqp7ahOajuqk9qO6qS2ozqpbS601aNFVSe1HdVJbUd1UttcaKtH06hOajuqk9qO6qS2ozqp7ahOajuqk9qO6qS2ozqpbS601aOVVCe1HdVJbUd1UttRndR2VCe1HdVJbVSd1DYX2jq7bI2qk9qoOqmNqpPaqDqpjaqT2qg6qY2qk9qoOqmNqpPaiOBGcCO4EdwIbgQ3ghvBjeDW4Nbg1uA2O6k9sAMFaIWc3cZG1UltVJ3URtVJbVSd1EbVSW1UndRG1UltVJ3URtVJbXOZrLP2y+YyWRcKUIEDaEAvnO/rEwnYgHATuAncBG4CN4GbwE3hFtFtEtiADOxAASpwAA3ohZEJLO5mZIKz0szmAl4XMrADBajAATSgF0Ym8LhDkQkubMDTzSmwAwWowAE0oBdGJrgw3OKMIxNcyMAOFKACB9CAnjjX/bqQgA3IwA4UoAIH0IBwI7gR3AhukQlcAztQgFYY0X1+tFkUhyUysAMFqMABNKAXxtP/wlDwQAUOoAG9MKL7QgI2IAM7EG4dbh1uHW4dbgI3gZvATeAmcBO4nTH/eDwcwWNhW9jBZ9wX08JtYV64LyzBFKwLj4VtYQePY2FauC08faNhjb6wLKwLj4VtYQfbsTAt3BZefG3xtcXXFl9bfG3xtcXXF19ffH3x9cXXF1+fvhE0rguP4ihEK546I7gvLAvrwmNhW9jBdCxMC7eFp68F94VlYV14LGwLO7gdC9PC09eDeeG+sCysC4+FbWEHc/ienSYW9WjFbWFeuC8sC+vCY2Fb2MF98e2Lb198++LbF9+++PbFty++ffHti68svrL4yvTtwbxwX3iAZz4hCaaF28K8cF9YFtaFx8K2sINnPqFo/zNvULSTmTcunvpxf2feuHgsHPpnP4nxzBuTZ964mBZuC/PCfWFZWBceCy++tvj64uuLry++vvj64uuLry++vvj64uvw7cexMC08fSmYF+4Ly8K68Fg4uorPJtNnqji7m6zPVHGxLjz/lINtYQfPVHExLdwW5oX7wrKwLrx4zXCfxzzD/WJZeP6tBI+FbWEHz3C/mBZuC/PCfWFZePGaIXvuWWt9huzFfeH5tyNYFx4L28IOniF+MS3cFuaF+8KL18gReZuFahcyMEfkrddwuc1CtQsH0IBeaAeQgA3IQFh4jsjbrDi7sAFzRN56DZfbrDi7UIEDaMAckbdZcXYhARuwA3NE3mbp2IUEzBF5kxout1k6dqEAFTiABvTCdgAJCIuWI/I2K8Mm8gHMEXmTGi63WS92YQcKUIEDaEAv7AcQFldsWLAt7OD5+IuOT5mPv4vbwrxwX1gW1oXHwrawg3Xxmun33G3SdKbfi2nhOB49gnnhvrAsrAuPhW1hB8/XvItp4cWXFl9afGcuPoeRTGfOPSuQTGeevf77PDYOnsfWg8fCtrCD5yvZxbRwW3gemwT3hWXh6avB03cET9+4zjNHR8zpzNHzXGaOvng5x/m6FT1yOtvbxbawg2d7u5gWbgvzwn1hWXj6xnnN9tbjvGZ7u9jBM3dfPH3j3GfuvpgX7gvLwrrwWNjA87Mu+ux0voZFn5zOV6/oMdP56iXRNuar18UOnq9eF/PCUyeu/3yVunjqRBubr0wS12q+Aklcq/kKdLEtPH3P6zOuGJxMC7eF5/GM4L6wLP9GFx4L28Je12fMGLyYFm4LS12HQbgOg8bCBj7bs0RHdFQaJRKwARnYgQJU4AAaEG4CN4GbwE3gJnATuEm49cDQPW9UVBolErABQzcursaRxX1RLxwHkIDxby3QC+0AEjDc4n4YAztQgOdZRJuPiiCZt+580UgkYAMy8BSbd/NssRNjmSSJth6lPRJNPUp7EhV43qxo51Hak+iFdAAJGLoaGAoj0IBe2A4gAVsdZGNgBwpQgQNoQC/kAxi6FtiBAlRg6J63JYptJB5fUWyT2IECVOAAGvA8snjORbFNIgFDN+5bNPB4ZkVZjcSjKcpqrmsmuL6C66u4vorrG81+4ogTips1GNiBAlTgAMYJTTEvjAi4kIDhFhc12no8MKO6ReJ1NKpbEg3ohREBFxKwAc+ziFfMqIRJFGC4xUX1ATRguJ3XNyphEgnYgAzsQAEqMNw0MNzO6xDVLXKWCVpUtyQKUIHnkZ11hBZ1LIkEbEAGdqAAFXge2VlSaFHHkuiFETgXEjAsWmAHhtgZZLFEkVgPJGADMrADBajAAYyDjIsaMRQjQ1G8kkjABmRgBwpQgaEbVz2iJQZ+ogpFYqwmqlDE44zPl5vEATTgKeZxSeIpciEBwyLOLaLwwg4UoAIH0IDhFlcnovBCAoZbNMR4Dl3YgQJU4AAaMNzO6I4qlEQChltc1IjNCztQgAocQAOG2+O2eFShJBLw4abncIBHbYqec+Q9lj7Ss0rYY+kjPfvJPSpWEgfQgH7iOPF81OnZlexRsaJHuFEDMrADTzeKwznjWM/SP48FkZTiyM7HYqIXntGdGG5HYAMysAPlaqkeNS+JA2hAL4zovpCADcjAOIu4kjyABvTCHmcRV/IM/8QGZGAHClCBA2iF13dLHNr13RJ8fbdMnu/EceWv75bJvPD83ogrfn23TFbwGVdjXoUzrhLpxLjDZ1wlMrAD5cQwPOMqcQAN6IV+AAnYgAzsQLjNz5Qz1zjNz5SLaeG2MC/cF5aFdeGxsC28+M7PlDNFOc3PlIvbwrxwX1gW1oXHwrawg9vi2xbftvjOboPz2ew0uw3OqQpOs9vg4rYwLxzHeT7MnWa3wcW68FjYFnbw7Da4mBZuC/PCi29ffPvi2xffvvj2xXd2LZwvGE6za+HiMyItbt35iExU4ACeEWlxKc8ovPAMwkQCnvF/Prw9akQSO1CAChxAA3rhOIAEhNuA24DbgNsI3WgEFgpxfy3+LC6VdaAAFTiABvRCj4OM6+sEbEAG9joGF6ACB9CAnhjFHokEbMDZVo7gsfBsKxTs4BnDF/fMgVGvkXhW5MZDdy78c6EBvbAdmRmjtiOx8lrUdiR2oAAVOIAGrCwatR2JBIQbw43hdoVr8BVak8fC679x8BVak2nhtjAv3BeWhRdfWXxl8ZXFVxdfXXx18dXFVxdfXXx18dXFVxdfXXzH4jsW37H4jsV3LL5j8R2L71h8x+I7Fl9bfG3xtcXXFl9bfG3xtcXXFl9bfG3x9cXXF19ffH3x9cXXF19ffH3x9cXX4XsVb1xMC7eFeeG+sCysC4+FbeHFlxZfWnxp8aXFlxZfWnxp8aXFlxZfWnzb4tsW37b4tsW3Lb5t8W2Lb1t82+LbFl9efHnx5cWXF19efHnx5cWXF98lt1xFHZP74tsX37749sW3L7598V3yFS/5ipd8xUu+4iVf8ZKveMlXvOQrXvIVL/mKl3zFS77iJV/xkq94yVe85Cte8hUv+YqXfMVLvuIlX/GSr3jJV7zkK17yFS/5ipd8xUu+4iVf8ZKveMlXvOQrXvIVL/mKl3zFS77iJV/xkq94yVe85Cte8hUv+YqXfMVLvuIlX/GSr3jJV7zkK17yFS/5ipd8xUu+4iVf8ZKv+pKv+pKv+pKvruKQc2KbX8UhF8vCuvBY2BZ28JWvJtPCbeHFlxZfWnxp8aXFlxZfWnzb4tsW37b4XnnmfPGMSo7R4j+fIZ7IwA4UoALPt582xQx4vv2cBRweCxQlhtsIbMBws8AOFGC4eeAAnm7nlByPmo8Lz4AeTIEEPN047vYZzYkdeLqdM248Cj8STzeO01QDhluc5jiA4RanORqQgeEWZzwEGG5xmmMAwy1OM779J8a3f/QsRI1IYgOebj3OOL79LzzdehxkfPtfOIAG9ML49r+QgA3IwA6Em8PN4eZw83KL0pJEAjYgAztQgAocQAPCjeBGcCO4Edzia+McRvOoSElU4AAa0Avja+NCAjYgA+HW4Nbg1uDW4NbgxnBjuMV3xTnA51GcMs4BPo/ilHEOuXkUp1x4vgQkErABGdiBAlTgAMKtw03gJnATuAncBG4CN4GbwE3gJnBTuEV+kLjHkR8uZKACQ+GM41i2KJGADcjADhSgAgfQgOF25odYtiiRgA3IwA4UoAIHMNyiPUTMT4yYv5CADcjADhTg6abRuCLmLzSgJ0bpUCIBG5CBp9s5CulRNZSowAE0oBdGzF9IwAZkINwIbgQ3ghvBjeDW4Nbg1uDW4Nbg1uAWMX8OtnrUHCVaYUT3haGggQJU4AAa0Asj5i8kYAMy8HSL7ppYJCnxdIsOmqgrGvFyFWVFiadbvIJEUVEiARuQgR0oQAUOoAHhpnBTuCncFG4KN4Wbwk3hpnBTuEV+iA7dqCtKbEAGdqAAFTiABvTCyA/RHRxLMiU2IAM7UAoj5i3uW8T8hQ3IwA4U4Hm8Fvc4Yj4wiolGdNJGLVGiFUazj57ZWNcoUYHxZxJoQC+MR92FBGxABnagABUIi4iA6I6NaqNEBobYCBSgAgfQgF4YEXAhARuQgXCLth4durGu0Yj+2qg2ujDa+oUEbEAGdmBk8CNQgQNoQC+cz8KJBGzA6CaNuxlN+UIDeuEc2ppIwAZkYAcKEG4Gtzm0FddsDm0FzqGtiQRsQAZ2oAAVOIBw83KLJY4SCdiADOxAASpwAA0It3jUxah0VEclNqAAo4P8CPTCWMzoQgI2IAM7UIAKHIWxQFEMks8Fii7swFBogQocQAN6YSxQdCEBG5CBHQiL2QNlcZSzByqSm80eqIt54b6wLBxf7DY140s7sp3NnqaLaeG2MC/cF5aFp34PHgvbwg6ePU0X08Jt4ekrwX1hWVgXHgvbwg6ePU0XTy8N5oX7wrKwLjwWtoUdPHuXLqaFF19ffGfvUmRUm71LF+vCY2Fb2It99i5djHvqR1uYF+4Ln+NmMdATSxJdGMUeFxKwARnYgQJU4ADCLYo9IjNGKVciARuQgR0owHDTwAE0oBfyASRgAzKwAwUIN4Ybw43h1uHW4RbFHh43LMo6Il9GVdeINBBVXRfGI/pCAjYgAztQgAocQLgJ3BRuCjeFm8JN4aZwU7gp3BRuCrcBt3hwx7BoFIMlMlCBoRB3Pp7WFxKwARnYgQJU4AAaMNziZsXT+ohbGE/rCxuQgR0oQAUOoAHD7fFMPCeNHwvTwqfhucvGybxwX1gW1oXHwrawg+PBfZYwnUwLt4V54b6wLKwLj4VtYQe3xbctvm3xbYtvW3zb4tsW37b4tsW3Lb68+PLiG6/wZ53VybxwX3iA4+v1nFJ7Mi3cFuaF+8KysC48FraFHRxhT2OyLKwLh45NtoUdHMGfTAu3hXnhvrAsrAsvXhHjNNtwBHkyLxx977Mdxsdosi48FraFHRyJIZkWbgvzwotv5IFz2u3Jod8mOzhSQTIt3BbmhfvCcuX8k3XhsbAt7MVRvVZMCzfwHNq1+cscwzWfv9D6S1t/4fWXnm+h5y+y/qLrL2P9xdZffPmlH+svtP7S1l94/WU9gr4eQV+PoK9H0NcjuF6k5zWYb9J+/S99/UWW075emq9fxvqLrb/M4rpoHzRfqPMXWn+Z9XVt/sLrL339ZT0CXY9A1yPQ9QiuN+v5y1hv8Fhv8Fhv8Fhv8PV6ff2yHsH1Uu3/9fjtb//wn3+LmvzeHr+289d4nzlHJOJtJqAlcEJPkARNGAmW4BdIKksqSypLKkdJ3jnvKAryAjRhJFiCXxBleAGU0BI4IZU1lTWVNZU1lTWVRyqPVB6pPFJ5pPJI5ZHKI5T9XH00wS+wI4ESWgIn9ARJ0IRUtlS2VPZU9lT2VPZUjsq7OWKToAkjwRL8gqiaVYnAOv+5RByMIivypPjQmERFrYiLepEUlQeVB5UHlUcrj1YerTxaebTyaOXRyqOVR3xWnJPJomp2UnxUTKKiViRF8bd8Uvzt+Z4RITWJiloRF/UiKdKiUWRF5SHlIeUh5SHlIeUh5SHlIeUh5SHloeWh5aHloeWh5aHloeWh5aHloeUxymOUxyiPUR6jPEZ5jPIY5THKY5SHlYeVh5WHlYeVh5WHlYeVh5WHlYeXh5eHl4eXh5eHl4eXh5eHl4enxyx+nURF4aEncVEvkiItGkVW5EkzfoOoqDyoPKg8qDyoPKg8qDyoPFp5VOS1irxWkdcq8lpFXpS06jnUGGuYXTSKrMiTZjT6SVTUik69cygw1i67SIq0aBRZkSdFNE6iolZUHlIeEY3nnMg2o5FPGkVW5EkzGoOoqBVxUS+SovLQ8tDy0PIY5THKY5THKI9RHqM8RnmM8hjlMcrDysPKw8rDysPKw8rDysPKw8rDysPLw8vDy8PLw8vDy8PLw8vDy8PTg4+jiIpaERf1IilK5ShAVQ2iomg5chIX9aJoOXqSFkXrtJOsKFrno41HselFp8c5rBqFphedHuf4ahSZXiRFp8e5ikiUl15kRZ4UUTuJisLjPOaI2km9SIq0aBRZUXicZxmRPImKWhEX9SIpCo9x0iiyIk+KSJ5ERa2Ii3pReJxXNyJ5UsxjOK/unEcS5ElzFsl5deckkqBWxEW9SIq0aBRZkSeN8hjlMcpjlMcoj1EeozxGeYzyGOVh5WHlYeVh5WHlYeVh5WHlYeVh5eHl4eXh5eHl4eXh5eHl4eXh5eHp0Y+jiIrCo53ESVfR8HEiA2eJ5flHV8VwoBaiFrijbLejarejaLejZrejZLejYrejYLejXrejXLejWrejWLejVrejVLejUrejULejTrejTLejSrejSLejRrejRLejQrejQLejPrejPLejOrejOLejNrejNLejMrejMLejLldQliuoyhUU5QrmEAimEAhmEAgmEAjmDwimDwhmDwgmDwjmDgimDghmDggmDgjmDQimDQhmDQgmDQjmDAimDAhmDAgmDAjmCwimCwhmCwgmCwjmCgimCghmCggmCgjmCQimCQhmCQgmCQjmCAimCAhmCAgmCAjmBwimBwhmBwgmBwjmBgimBghmBggmBgjmBQimBQhmBQgmBQjmBAimBAhmBAgmBAjmAwimAwhmAwgmAwjmAgjCXzATQDARQDAPQDANQDALQDAJQDAHQJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkEsEuUSQSwS5RJBLBLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLFLlEkUsUuUSRSxS5RJFLrhXLzuK3a8GyiQNowJqrcC1WNpGADcjADoRbh1uHW4dbh5vATeAmcBO4CdyuTCCPXlg+e2HjVfmcthBvygE9QRI0YSScLzPnXIZ4Rz4hXpHPeQzxhhxwKp9zGOL9OOBUZrp6cwM04VQ+Zy7Eq3HAqXzOWogX4wBKCOV+9eYG9IRQlqs3N2AkhLJevbknxOtwQChnby5nby5nb+45hyHehAM0IZT96s0N8Atmb+6RvblH9uYe2ZtL2ZtL2ZtL2Zvbsje3ZW9uy95czt5czt5czt7cnr25/XFne3S3x107uxlHQty1dnbtnHB+VcZd48efSP1JjPKd/4DOnnuN/x7/Xh+/jvg1BM8mZNGRH3e8X3e8nQfgUDv/6swx//m3uSQXz77la4WxBEvwC2IBlABKaAmc0BNS2VPZU9lT2VM5xr0uoqJWFOr96nmOFc0olhuaZEWeFEt3ncudRY9yLGYWPcoXjSJLisVFop871haZNIqsKDz86hW+iIpa0XnM0Vs+l9o67/VcaYuunuKLPCmWE5p0qkSPcqz/ExQL/UTfcqzoU323Un23Un23sVIZzXWy5Oq7vYiKWlHo6dUnGwtnRZ/spFjRZxIVtSLOo4rVfCZJkRaNIivypFjHZxIVhZ5d/a8XadEoCj2/+lVj6bHoV71IirRoFFmRXxT9qrE+WfSrXtSKQq9dfaixYln0ocaCZe3I69eOvH6NjiIqakVx/cYZjzEeF1c7NuClhJbACT1BEuJYriGnCZbgF8wVy2wmqQnxV9dw0rW8WIJfUOuR1WpktRbZXInsuEI+avIlQRNCuV0hH+AXUC0+RrX2GNXSY1Qrj1EtPEa17hjVsmMzDYxKA0MzDZyrf8w0MCn+1jMNTBpFVuRJtdgY1VpjVEuNUa00RrXQ2EwXk6zIk2qRMao1xma6mMRFvSiUWyaOoLnm2BkgtbgY1dpiVEuLUa0sRrWwGM11xXLoaNJcVSyHji6Ko4oUEh7n9asVxagWFKNaT2ymn0lW5EmRfiaF3nl156JiRyadGFSf64i1TDqTqKgVnSpeSccr6XglHc+BoIusyJPm4mE5EHRRKwoPyUQ0SYrCQzMRTbIiT5pLhgVRUSsKj5EJa5IUhYdlwppkRX7RTFiTqKgVhYdfA0EXSdH5OnDQlcRiNbE5EHT0K4nFUmFzIGgSFbWi8yXnGDkQdC4jNgeCzoK2ORA0aRRZUbzVUA4EnQuIxWopsTxYLJZyERf1ovA4k3Z0TE8aRVbkV1trtRRYq5XAWi0E1modsFgg5SIp0qKRNJcA6zmcNKkVcVEcs+Rw0iQtGkVW5Enxrj2JisLjfNujqNuIXHW+8keqCugJkqAJI8ES/IK4PgGUkMqcypzKnMqcypzKnMqcypG38ltE8ltkAiecyvFRIgmaMBIswS+IDBZACS2BE1JZUllSWVJZUllSWVM5UtT5SRTZKLa65fwvoczXo/f8polcc36LRKqZ2wImUEJL4ISeIAlxhHo9nvkq8giItMJXkceElsAJPSFebI98ET/yRfzIF/EjX8RnSVwRFbUiLupFUqRF47pO86k8KY7+LDUi/n/b7P/bZv//rM3G93s01bMsN5oqZVOlbKqUTZWyqVI2VcqmStlUKZsqZVOlbKqUTZWqqbZsqi2basum2rKptmyqLZtqy6barqYaIAmp3FO5p3JPZUllSWVJZUllSWVJZUllSWVJ5WiqZ0dHNNUASugJ8Vf9asUBfkG8GgZQQkvghJ4gCXpBNOfYGKYlcEL8lV7NOUATRoIl+AXRrgMooSVwQgouK0wuC0wS1pdclpdcVpfMxSUDCdiADOxAuGFZyWVVyWVRyWVNyWVJyWVFyWVBSZodwhM7UIBwa3BrcLu6c/X6yqFYbDLXkQw0oBdiEcllDcllCcllBcllAcll/chl+chl9chl8chl7chcOtKuj6NEuAncBG4Ct2toyK9PpAsVFdPXJL34+mlABnagAGchcbs+muZ0rywV5uuzKbEBGdiBApy6+fGUaEAvvObe5QdUYgNOt/yGShSgAgfQgF54zb6T6wNqTrIjzLeja7qdXt9QiQocQAN6Yrsm2un1JZXYgAycbuP6mkpU4AAa0AtnSFt2DM0b0KgBGVg3q7UqfG+tSr5b60ABKrAq6VszYNXxNz6ABGxABnagABUIN8wbaJg10DBnoGHGQLumCNj1wTSr+K+VKD2r7a4T6lUjfy1DOZGAM11FUR0DO3Cmq/ODc4bpxAGEm8BN4aZw0wbEbVHcFswDaJgF0DAHoGEGQMuS//O1Y44BxPMjegmj7z8e4HRV3k8YCZYQLx3xiThyvECo/9fjP/zLv/2Pf/yPf/63f/3v//Hv//RP5/+W/+F//u0f/rf//Nv//Y///k//+h9/+4d//V//8i//7W//33/8l/8V/+h//t//+K/x8z/+8d8f/+vjfvzTv/4fj58Pwf/zn//ln076r/+Gvz6e/2nzs8sh/poP1RLwcVeBY5+YS8FHKTxeBW9L0NnHMSUegfBUgp9LUHQUhsQjZbdFon+R6M8l+pnRQuExbgGBPm4fg7VUeCRce3oM+lxCorRuHoQal4TQbYXR83Y8+mL7MwXbNAk5e3RC4RGC9EzBnyuY5EnYQJN6vGh8EaBds6RzcHEew+OBXxq9fZWgjYShYT8V2F9IwoW0Z5eBtg1i5L14PBP5aYOgTat8vARVw3501j89jL6LcfO6FHw8PwzdHcbodRi0nIp9uyPjuUb0RobEHCxNhftnwrGH1TyTxwvz8zPZNM7HO3eru/J4l1lvy9dQb8f716PR29djdy4tNtqah9HOq/D0XHgXbOcg0BVstqRf+3pV266NxeTyqTEamqn+4lzYrM6l98192bTTpvU0ejzclzT+OK8vGmP3OGpWrUxWjW/HsUmizKNaKjs/19gdR+tSj0V7fhy8aafd6zjkOPypxv7O6IFWNr7E3bcjabvY9UrIbb0z3zV2LTXqtK9WRv5cY9dS25HZ8DGmMV7T6FyPyG7PWypvWmrUrczoVxwF69eI4U37cMTLsVyMPyQ2zVRbJVRttjmMXfMwratxcn+usru1o/e6tf1589g21EfU5UV9jN1Ke6rS2+4BYVLn84iT40ky6/yXpsN+1Kvgo4OlP2+oZ5L4Cx8xPeapXsehm8beN0318RmaB/L49lxT2dd3wm7vXtPtUXSq9NH78fQotq8grEti16evILJ58LPihWzw2tb1tkbnuhqdRZ9r8PsvMdL/0pe6ftQHZP8S+f0XGvgI7bu7smkdhCa6vBS28fXFQTYt1Ooz1tifK/gupedpuD9X2F4JOap9mtLzj1DaPfCt2gXz+lL5NU5097iPsZl5HGLHSxq91Uf9o4235xr9/Taub2fR7RXl+ph8dDnz8zMZ2xcXZC9+fjW2rcPwWuqtvxZrzvVa6vb8q3Yc78baoHdjbbS/NNbc8yD647Y+vxLbD6eGp9qXOPnaPsemfRpxXYxHx/dLGh5bis/Lcbg/1xjvx9qwv/J50ql6XXojfamNd7zg97HpMtn2Hx3oP1puyreOm123aONKoY/3p6fdosbbV42jXjX8edPYapjWcZjT2xp+tBc1Di4Neh4qNt5NG2bvpo2tglaUHMul+ENidymckMe/fBt8vRROb/c1byXutfG9RIPE8jn+K4lbXd4u2w96xZfBixLVa/SQ0JckpHrzHuNgz+/INn3WS8Kj06a/IiFeb11bCXl7CIGO7QM+74h13wwi0PvjEPz+QMTR3xyJ2B9FjIJeR7HE2R8am+eRWd4Sp7a5GGM7nlF9eGS2nEzz/mLjeD6wcmy+k4amxBhPL8cPOePW6M5uhOluEt6K9KPVN85hvhHZPuUxgKrr68q3wcv9kVDlwEfnQt8cibz7fKXdUNPN9/L9qaBzhGh3UfXtx/T+QBR3d6zDAN8PZDfWdPOa7oaabl7TrcQnLodVxDy6zXeXo78Z+9vDeCSgevMh2bT03UgTN69RIl4ek/oLCa5vLual9/27hO1aeh3F42PnqcTdq9E2r+Z7kVHdTjLGJuJ4N2Q/qnfigfbsZHYSt8epd2MRN79BtxI1mqHLW8PvJBQDRLaR2F2NKD+6rsbakWftN5cUfVey9lb/IbJpp+RLn+K59exLLdVavtyKiz1vZH0/Ilqxv1yRR3P7KkFvj+7sjkLw1dNtcxQ7iRq6E9ucyPaCuudzQVnotdDXPqja+qv5Q7n6Bx4j+JuU3N/+uKf+9tf9XuIDD0pFOZvq7l1MttHv1WHy4CUb/iLmHs9Yqsft7v1UtsOhKkjsTz9sf9DAN5A9/yzdajDG/rk972z4SeN4W6NTfRL2drymwXj/6LTR8Fuf+o9UMF7SuNnjcPc49hrba8p1b7s873NQfv963NR441zGMpxpb2usafl3bazVF67Q5nrsnvzogabRNz0P2wMZ6ENZv6O+H8huzOnuzd1p3G3sN4/j9QaC7gveJcPdyNOcjTRvDK2dBr+6MdY6xgaet9Shuy6Q+ihsm/axHXlCMny8uSH4H+MmvzgOPupb3TaXY//IZXx/uDx9N7RjL9IWEX1F5OaH4U8nc+84dl8xNvKqPgbSng/akO16UA/U7NHajfK9f2v7PVXDHfqlmPI3n2R407VNIcDbox329kiFvT1QYW+PU5DT+5l024l7c6Ti/UGG97vmdz3iN7vmXT/RNX975sfzZL4bPbrXO/eBWTTbGQ9Wj7bmX/p/v1W070aP7nXw7SVudfC13dDPzTy+vRj1Etd8U8vQjrf79dvxdr/+XuLmp/V4u2NuvN0vpx/oltP3e+UatQ/0yu2+3QbjrXo5jNsCj0GY6sl68Fi7ob5NltiNPN0M163EvXDdNY574bob7bnXCb6dV3SriW8VbjXx7fyom018P8fqZhPfTW6628S3E6RaDQi01ta68X5fIxZKuZ6t8lxjPxGnUdXit7aqfI+U/byiW5GylbgXKc3ffrDdvxy6SRzbGWN4HdZ1TPL7jLHbGuN9jbWf5Dcz1w6tvslDn8/2aizbV8nlTXIzdW03uwnvHNbpRQnJJGQyXpTodRTrcNGLEsqvXdAWKz1l6LdXRfBYmMvNvXJrHQHjm/uym1HIWl8r5zyWlzQe37CYvLJpYjdnNj66SDd39+4szZ3G3RmnYxO3/d2vpu1RDFTU27HJYrK5pM71qPRHp9yzl7m2ndvEmNvE63IQ366obF5LH88nVMytI4rfNXbPfVrmzz26Ou3p2ej206n6nezLQ/sXed3qo+WB+lRj/6STqtGgLxWVfzzpdjOcHLMjj7Wj4dv3/XbmK1G1s92kxLYb7rEadf5Sxv1HU91NlELf9XHY5sbs3nKx9ok6PW/uuylKj+5vTL3Q9jxkdnf3qLKGxzf5rpXtevNdqwfcffcaI+8nANX3E8B2qtPNBLAdd7qdALb3hutp9xhjaK811q8i/lRkP229FgN4vJk/f/Pfa9Rlbbybxr/T4Cqqbl8WNviusavTqO99s9fmrT/Gemt+Tl/O5Dcaj87OGg8k669p9BqYkHUQ/lcag1qNCSyfub/TwOJFa+fv7zTq40GsPb8e0YieP6nQJ09fYve3Mkhnb8jwsj7K44vodRksGfOQ4Y3M7u27YdT2wUobmW3voRiWBFo73X4tU48d0eN4+aSw+sPjpHZHs11mwLDGSDdqL8sIBoJt2Ms3fJkBTW1zNL7rXu10YO0E6vKyjC4yRi/LIBj62Yn2XEY+cqd+kKmFFM47NV6W+cwNx5o/D5ZXM/k6qWS8puEo63R77WmgRz0NlOi141Cqjg+lTcbbaxgKqXfXdFde9pEVagZ6o20IvahiiGYzOl5U8eVYnDfHsi2GHFgIafM5uNdwrLjzZWrwLzSso9tBnr8N7j9uvaEb132zJNNuLOte0f5e4tbAyV7i1sjJD8sP4blMvrzMfWse27lLmAPv9LR/fi/RqsjdHx8Or/TPsxCWY5LNR8teRb2uBw/afPq0491Bj73ErUEPbu0vHfT4ejnayxcV75APFX1RZTBer4ds8tD7M6n4/ZlU/IGZVPcvx2Y86qdbY4vKZhEzeTeVbRXulTlsX8a5KiofvH3E9HcHxLcSj2yI/tOh/UWRgXXhHuwvilRH/YNNX2lnvUOjS3u+6mffLtbykYXdmqNL6UuPobymsfZL/0ZD0D0ma+T9QoOP6h9/fP/xUw15f5bsdmW3o6rwHt+M6839xepwhJWzHu8QTzW4v10nsJe4l5f723UC24vRsJhP+7KOzrfD2IqYY7hxLVP/Q6TtPhBv1ErtDwOfh93XEf5fnQtGT+Ro/WWR6rY8ur0sUl/Mx4urGN5eCbG/+7jcKtx6XG5HLG+WTO1XdLxXMsX6iarA3QJaeFZ2a8+LTnk3pnWv6JS3I1q3ik73EjeLTndXozVMcdHXapo718z2/mWezB9XdNebUr3quqw1176Nq217yg7Gx/rawvrXxrFdee/eFR37euRsX3Zs5gtvNWID0akxRntNw6v64/GAoJc0Ht/4+ZrsR5PnGruh/bvL99m7SXCrcCsJbidy3UyC+2UIbybBbTu/mQR3M+weL001BbON54vv8W4CFY1qYeenS4l8L9rYamCef1vLJf7Q2C6CemvCzlbj5oSdH86l3oDawe25xu5b/9aMQ96ONA0n3BdfHnHfJ9zsj+TWnMPtBWl01KfPIyW/dFEbYUF7WtLHdw3nty+q776Ob07j3B/HrUu6TWO3ZgruFe5MFNwWON17Rm6XYO41k4rXiX6/WsbZa/27/qWG5lfLOEOjvbiM8+2loN/uE9O3+8S2ZVo3n2/7Ja3vPd/6di2/m8833c66/sCq1lgJ52tx9G80sPTDo/Pn+Vrjnd5eULrT2ytK7yVuhv32itbAehNvm6uxG1e/u3bM/kldEq7PFxvvuwlVN5eO+UHj1tIxW42bS8f8pHG8rXFv6Zi9xr2lY3p7f6mUrcbNV8q7x7HV2F/TW0vH9N3Um9vXY/zV53Jr6ZjbGpulY35oY7eWjum7LaPuLh2zP5B7S8f03ajN3ZvL/f3GfvM4Xm8g95aO6dvV/G4uHbM/kHtLx/TtYn63vjl6p/e/OfbHceub46cn7q2lY3rve5E7S7ZsRe6NuPx4MveOY/fYNux/QPr8+6Vvd426uXTM9rX/1vfgXuHW92B/9xj2CneOYT/IWpUJD/T/emmgdvCyz9vxmoZiwFidX9OwKoBpfshLGo+Bp3rGHe359eDe3x913oo82kR929p4WjK2lfDqRlJv4zUJfGG7PE0ct1tHf7GFNWjwpnXsvrHvjX3vJW6NfXfVv1TiZjLff4H93fqb390TzDwa/mrmWI7jVQ1sCfHAVzV6u6Xx9hOlv/1E+aHCs/qivLUXi0Sr4u2BTyuithWzty7FDxK3rsW2jrmmYLavi079pha6XkYfvQzjRQ1sxWzj1ePAhHQbm01y97XuHVXqa2X3LyvmV5XN9KufVDpUxvM5EX0330nvzfbt292j7s32/aH+v2F5DV8qb395TbAtvPnx8lyE9Vj4ZRV8uJj3zUzK7bxS9APzbvPv7To9VRTQ2job4dsaO93ff/L7+09+179U4uZSVLvrySiq5HFsrue764Ntj6Lj3aF/mcb9bW/X4/25/nJ8YK7/dhWohhUW11KPX60kta6++fx6tO2qFDeXo9qK3Pvq2Evc+ur4QeLOV8d2ubNbryB7hTtvINtVBe+tTjvePYZdJ1a9e+haFMp6VwDrHMmX/dbsrsCwGmAdX7an7f6SBOtTCdmu4leZc+26bt87W7YSta2rLD0Df0rsNjkbVaA/1gl6jxfNryLbSUuCnbAWieO7xG67E0J3y2MU7EURfCk8HtPtRZFRNTdt3Zb1dyJcI5uPY6JXTwfdR3w8P53dakuH1QQ7Wke+7zd2VPnTunWw3z6GVoPeX/YN/oUA+mvWSoRfCAi6FP0VgS7V9b6u8faLI6gXlLbMif+FAFf55pdFVb4JCG/Lpau2d3nZO+eh//4Y+Ngcw/sfSMLvfyDdyle8vsH/oj1U0VPvL8VEp/73xpR+IfDuzVSt4aQHPp8hvpPAnrg6xvGKxDjqQoyD9aWj8PpKfVViHLUOwTjGS9fi8aSoE+H22lFwzR8cvFnZ4a7EpitkK2GQcHtJolfn+OjML0lYfX8M09ckes1DeKC/JKHVeTm0vXZHpCrgxloo9RuJUQPhw16L1C8n8qoElo/U8Vq7wE7eY1B/7ShqhtxDQl47CsE6mNLfviP0vHWKbqdR3V1VZhsn9bL6ats4iyuwFgTTS8dBKpiyo/Ja6jnXaEetp9iLIoqaUx3HeE1kYLmQ8zH3okjVaj7YX7ywhrujRvTikSwXdrecUnSkPZW5vbaYbPeEur222I8y99YW++mkbq4tJvv5QHdXrPpJ5v2k8LjdsjQ8fbXhVUX9g+XFOPKlenutz/2dCFbxeuT/lx7lNAgLoA567T3x8YdYMXCsn8O/FBkQ8c3j4wNDTWJ/6ZcUjVYv8CfLa1ekLYtetFcva2Pcm9b5RRFdjuTVpsYHZm1xay+K9EVEXrywzKvIi42elwpZtlevyVhE/MVb3JfG1tuLt7gfq0h/sZ1gtd3HN87zu6PHdvMRrmU4HrxpKT/JYOWZzpul5/Ron3j2/HQ0NWLz4M3H229O6g2ZqjM/1wfaXWL9f+LaOE6qH/0TJ/WGTNROp8zmS13p+H/g2mDXwQd3+chJ9RcT53FgLafjePH937GK2titL7z9Oru5wvhGAxvV2To6Pm4PItR9WYc+v/29kv3FZ1ErsNi6lNy3o9gNU61zM/k1BcPwp72ocKCz8oV78RgbqzF1Wha0/cWAzpf6AHtpTIgr4Dut5e79dvc1o/t6Xd9Dbg8D1xeO6GsC9T4ia/3aLwRqZdMv01JfElg+638hsA7GHy8JYAlf768IjJr3MNZRqZcE1qD+hQCWVzleOgWst2uvnYJV94Gt08deEpCXbqPXA89fu4iOAtv+UkvEAjWu+qbAeOk20lFDtHToS5fRnPCcXLqnqd2XwK4TfqyLDLfvqxDsauqw2ZN8WXboW37eishhtcQ3rWtj/SGym9c06pnbRns2WWx/HMQoc1F97WS+DDTq8apIPTl13b7idyIoNtYvdfn3n51O9f3ptJTL/KKZfZFYPoP/aGay3YJvqahd1tbr7TeXg3A5+NUbY0tZmm/au9j7N2Yrcq+a9YeTwfId64TT3wVvq75KaX0TNNtVVW7VGO8lbhUI6/sTlLYSH7grAgn5sqXpHxd0u2wYNg2XLzu5H78RQQ/yl4UzfiWC2o3HOFn/gIi+fCQ2ln6w5yLj7ak1++PAvkI01i+KP45ju72Z42x83eDs+3JbW5k+aiG0vs7z+UNke0Km1Rmy1iz/cUL7PILdlr7s5/W92e+WmWrLNmn09CmxXajqVgn3XuJWCfcPEndKuI/tq0xdTH/aTO8JfJmUfFvg3vYTN3tA6CWBW4tTbb9Z75SgH+8mi133h6Me1ZeHa/+2YKL67g3sqKkNfiybJf0psqnvFfTiypdxlUfv1O0jeXTp1ScHLUsV/nkkvPuKrjJhO5aR9O9V4D+I1KPN1q0//xTZrd7YBmra112o/rgmOxGuFa4eKK+K3L07vOtdIFyTZRDvz2vygRr9cdyqed3V6I/jAzX6e5GbNfp7kZs1+rvrcVTP0WMQrj+Nm3HsvqEYpY4PXh72f8psJ0oxVlNb97DiXx0LY+yau7fNsdj7qeAHkXupYCtyN3bGbsW927Gzm/t9M3aIPxA7W5G7sbMVuRk7e5Gb81t+OJ1781v2qeDukRwfmGnzwwOjagJk3ej9l08d7HjQj+fPv2ObCOorhpdHqH1VGI3fHZ/ZStwbodlL3Bqj2UvcGqW5K7EZp9lK3Bup2UvcGqvZStwbrbkrsRlq2EvcGrHZStwbs9lL3Bq1uSshL97UeyM3e4lbYzd7iVujN3clxos39QMjOIR5WdSX2cHfM99ua0SmGqFnWl8Y9NtLVOfdy2UtKMvHWkX4baGJsV20a9SH6rme4kZkeyQ1R/jRCWwbEf3A69xuSaO7X3Z7kZtfdj+I3Puy216T22+n8om3U3n/7VQ+8XYqn3g7lU+8nW5jGDNaHp9QfRPD2/ETLLy3vs79ISKf+JqST3xNySe+pvQT7VXfb6/6ifaqn2iv+pe3115v7NyX1PhHU9uNGDDV0mC8bgNP3/aS0V2d3jLBZ6xv7d8eFtvtn+5U2e0V7lTZ/aBwo8ruh1tCWK57KZL745bs5hbJQajk6OPpLdlpdMfQ5bEObH/X2HxUdnzCdF2HHl7W4Kca9y/q5t1qN45DWI+Z1h63P05m1z6OjjWu/fkFsW3FkWMaG60zz99ReXqDt6+9h9157dVPdOjoJzp05BNHIp84kv174r0OnR9E3u7QufvmfPy1R3HzrXlX9YsdCpfvmebf4mU3oMKEJ2V7KrE7htouvi+rCP55DPKBt6Dt4nv33oJ8fOAtaCty9y1oK3L3LWgrcjfw96fz9ppJwlhijJen5W+6YGvv7La8f3zfYCd2A3r+vn5nqyA73t6XdC9xb6ug7cPJl8neT/f5sP1IUO1/+aXuSn4hIdiGU59L0H7qRVXD0jIl6FspjG03gKonilPbHEbbhQn2WezLovLf95K4e0/G03uybeDrNvXrbljfbutuA4d75cW7o/ASoC+9n8cvTmQsJV9tcyL2dqzu1uG7Gavkf2WsNsIqqOtc7j8uRttuqDPwgv4Y+HhWafWTCK9LGPBTkd1yv8bohV3nKf1xOtvtRGv2nB4NL4E27mso4k3XFVl/oyEuKF/XjcamnTJmAvK6hrL/4jhGq2fbuZ7P0+Pg/fRKzK5cN5jnbzeGd9VTx9+tpvtDov2112O5L2NdnuWP67Hbcklr/TGxZf+578fB8n5P4+7VGB0vfVB7JZ12JUi0zXOB30+n/H465ffT6U9pbFn/ZMizzQusfyIX7kTuFdHv06lUr3r7Uv/+/d7utpR4PKdR17zUAn9vpnsRvEa1o+1ExvsB84PIva75rcjdrnmT4/2PUtuNR937KLXdaNTdj9K9yM2P0r3IzY/SbaNn4mU4eJPQZFffxzVNqnXetFf5RHvl7Qa0+Azi5w/N3abRt09Gjw+czPbetJrIzl+W1f1+b3TbXrFbz7pBzZ+nw3/1vcGSMuuKE3/cnN0ecPfPRj9xNtvVL1AZO8budHYvrMeBySe2E/lEgx2faLDb00G/0Je9ef84nfGJBjs+0WBvvvo++l5e+6zR0WpOy1h2pnv102hYf6qxXXjv9tyvrczduV/WdpvdsGJjS17nyfwhY/ulY2pYiNq66aj+5li4bhDxcNqc0vbLs/Yze3Rf0fMvrZ0GNqbttKzr+V3D+gfe1+wDc1T2IjcrmX4QuTcms70mt18/7QNzVMzfnqNi/oE5KnuRu6+f/oE5KvveFuFl+ejnvU+74SquZMJrWci3XuvdWJUsK1KMdR/TZt9eCPgjmWTfZ3Mvk2w17mUSP473M4nv5h3czSR7kZuZ5AeRe5lke03uZhI/PjC66sfbo6t+fGB0dS9yM5PsRe5mkm13KRrJuizFtzdP3w1edSzT2pv152lg//mI11fW8ern483HuH6itdInWiu931rpE62VPtFa6a9urdgz0kWet9a2HR+oLVKE1irA76119z0tRBAR3YjoJ1rrB+rNvX2itbb3W2v7RGttn2it7ROtdfdd/2VJAXner+a7Jt+PGtDqx9q9/kdT+0R2HZ/IruMT2ZU/0V75/fbKn2iv/In2yn91e2X0DDz6xp73Q8Xi/be6OtYR2O/tddeZdTu/Dv5Ee/3ASg3eP9Fe+/vttX+ivfZPtNf+kbeB3fh4q4oSaUsr8d+Msfca6xfpz7/5diNKjx61mqJI614Hx28ORKoTWHRZSOiPA9mNfPzd9Xe/1Xv7bvW/eyv4/lBxcDPsdiK3w247Qepu2O0+TG6GnR4fCLutyN2w24rcDLu9yM2C3B9O515B7j6L3D2S/oHS4P3z9+6R8CeOpH3iSNonjoQ+cST0iSM5PnEkx0eOZNufdm/uyA8i92Zt7Puhb16TH3rE712TH0Yr7l2TH0RuXpPd/C9S7BGhy+JPfwyN7R7kbNXBwH48XwNuL+K1kBy7PF+NzncjOB95L2FH9d9Bx+ZI9N0Xk92eVHdfTHYLcB61fG4n2Z2Jvz9C/oPIzUGCncjtVyRvH3hF2k6+uveK5P0Dr0hbkbuvSFuRT5SHfSkx5+cl5jGJ92n43luJ+4cSs5sdP/KJakb5QDXjWVX7fnul6DV7r8E+ND7QYn9Qudlkf1C53fvziT4X/USfi/Inmgodn2gqRO83FWqfaCrUPtFU6C+vfm3Vx8e8mWC1FekH48VCnpdpPn4ff7XKvaWof9C4tRb1Txp3FqP+4Q7ffLH/qbXde7P/ITHdPpZ9krz55eUfOJQf3jBufu/IB27QD6Xw709oFswuWkbtx/1dXo9R636f/Gway14COx8etqTYX0hgxb0HLy/2v5Bwqfk4x1o+9BsJbIf6pVD7NxLVF31KyAsSjz9blg1p+jSD7Pqh7p7LXuXe1KJj+5S5sVPJTuDWJiN07IazPqHx9pWgJnVX2zox0u7P7W6oY27rhOZXJfQlCcbMbD7sNQlsk83rZJVfSEjNRiTpr10LxlT5dbb9yxKv3dR1YUum1ySwQ0pXfVECJ7JO+v+NRL1mU7fXbmqvhagenTvHi+0C6x+0l25qHxj8fuliomlKe34d6NjW0lktM9rM1mZx+yjqNXQdE/3NaVQf6JeFxX4hIBgN7S8JVD+dOL8mUKtMe39P4Msa07+5iFiN7KVcqbWokbK/eQSv3UYivN6143mP+l0JolckmtfgAB/rpWy3I4KPytb8ZQ2MbxKPF9pd90irHgl0591ePqiN6lxpY1No+4EB4O0MPjwxdNnV+zcSsbThlBj+0scLOV50vb0mgTWQ6VgK5H8jgWnAtC6j/CsJfEORvXYU7Hgl8teOQmpshNaU/ysJvAaI+WsngpvK7bUT4Y6dV+SlExk1k2R0fUXAa89Jl5dOwo+/t/77bwSqTfmQN0/hNQFpXmO6L6UZqTat9NIRNKnVU5ouXdEu3xL2bpLUo6e1Frdoy26I+v37b7um37qn0LI/2p8i2x0iR822evA4Nh3au1GlRq2eAOt6wM2/v2Lu9p56PHIU34L+qsqyNVFfxpb/jsrujFq19tbG8zPatZWOFa50GV/+3lZoN6rUiTB9bBm2EP9FIl++g2h52fFf7Hh9YH7vYywN90aO7yej21vTcSTLu4b8cUn225rmZV36KPnbh8ickfz2OA4db5fxPS75B2rWHir0/kPuIdLefUT8cD43XwYpRgbffZk7S1DefWbuNe6+0P1wPjffLH+In471m2Xdq/mP+Nmt3aejFroYbVnhyb8HULv9VrUeiv8iqaAH8lgXdfgjqbTtEv/1Uc6yrJojv3hnP5bxgnWS7p8Hst1DpeYc85eV5r5dkofK7uUAa3Q/hnSWfpYmv1BhvHo/XljtVRWtniceX6Zd/KGyybX3Fs97aOwy7b3V8+an0+7N4N5aFw8d2g6I3Frs4odTujcx/HEon6hqoF0R2/2nIcv7T8Pd/Kn7T8PtWNPNz98fVG4/U7dL+918Bu007j+Dbh7JkFfvz+2n+26jqPtP992eVXev7E2N7TXZady/O9trcvsNYZtrb828fxzJpp3cnXq/P5J7q789Xr225eT3VtN6qLRP5MjdLg/3c+R+MtW9HCnyiRjcFXHej8FdAebdGJTxifjZns9H4ufeWgCP58sHFgP4IX7urdD3OJTt3lX31m97qPRPBJDKJwJI9f0A0vGJANrvX3U3gPQDrwf6kdeD7fncD6DdS+Do+GSw3efLbkjLB/YusGXc/Y8vqbEtppZqcQ9evoL+/CDbTr0hTL1ZN6P682B022lV3wy6bq3Vvl/d3ZJ/dxd/INrtanV39Yf9sdxdL5PIjk884o0+kaHsE/MAyN6fB0D2gdr78+vmExlqN83qbobaadzPUNvzuZ2hxn7vwlsLUjz60LY1OfdWpPjpWO4t0vo4lg+s0vpQ+UhXgn+kK8E/0JXgH/lU3Y6Q3Y6h3WjS3Rjazty6HUPb87kfQ7t4xu4N9GV/9+9Ps7abd9W53hX6Y5DqaQ9YO/ZLPaJOYXnh+DYP9AeRe5t5P0R2jfbmbt4Ple247r3tvKntxsiY6xueeekU/6VKH+hFPuxVFbFKcroMFfxS5eYO5T9d3XtblD+6dT/Ro9DoEz0Kjd7vUWjbzbHu9rq23cqCt3td9yp3e10bvZ9wtxq3E+7dIxny6v3BHsNN1+XC/1DZbhBz+8o2fv/K3tR4/Zrcfby39olesNbGB67JJ3rB9udz9/G+f5Ld3I6eGn/io6zxJz7KGr//Udb4A/P0HiryiSzJn/hAbPyJl9vGH8i1/JFcy+Mvb/2dse/v8kb5Z+vf7j9OVUzDa0nct622HyLbQaGaiPz46nq6P/1e5HH29fQ4Gm9EdkvhVEsRX6v+f3UcHYVba33EH8cx/trjoJrs9Xhy9xcvagwBvC1SE1LeEFnTUtu0ke1qg4xMwMty+b8TwX7Xjw+qj4jIqyINs8d6f1kEW92Lf+B0XhcZOB2z90XWj7nfiayz2dZZjt9FtgNk92J4fxyK2Za7yNmNjt08jv2zoq7H41nRNs+K7crfRz3N5VjnxukvRLrXhGA51pb2h8hufrXUhMf+ZXbW6yL8XOT+ld31poztBE7sD9yXPZL+OJSxaa86Duz51I4XRaxK5NXW2s1fiXg1+7FuFPorkdGqSGR8mbX9O5F6o36I8Gsij88CrHvmm3Y/flhYYFmegPUzMv7iKXGNihn3zcW14yOn9BuZzSntO0dR7rjvHN319aL0sqs9XVb5cUIfWHvwobJLlPVEXl8NzsUHvmnoJ75K9+sP3vsqNfvEV+lu3b/7X6XbY7n9Vbpb//P+V+luUOzuV+lO4/5X6fZ87n+V7gJo1DKifa3F/iOAfDsOS5hne9AyvPC9mKFtB5EOdOk/LswyD+5PGXs/EP0De8E9Oj/f3gyO+NguW6uY1Te2jf/+pV1Gc393hwibuT3Y2qsyupS6a3s6/+xxaXYZt7oTe6fnN5q3IzeETpm203g/8/NHZo7xB2aO8UdmWjF9ItsyvZ9ttxq3s+3+fG5n2180fH5eO/ZD0sZOd+v7+vekzfSJRU6ZPtJu6QPttn2k3baPtNv2gXbbPtJu2yfa7bYwo/UqS2rC7XlhBu9GkRSTnx9PoOcvCbzfd+tu+eUPx1LrnCovsxX/FNm93i4LUslaZ9V/VQmKbZv7sa5Q+sex7IbFtGbmad/doA9sKvoQ+UTBF39k7hh/YO4Yf2TuGH9k7hh/ZO4Yf2DuGH9k7hh/YO4Yf2TuGH9k7hh/YO4Yf2DuGH9k7hh/ZO7YPjFVTZ+ufXF/JKb+kS3c98cyqkLdtklS9vUHeX90k/K3x2GV3NYVnP/OceyGGawyitjuaSqfmMxwf577Urcpf5zPbofuKi38sopea9819jWB9Tn35TFI31vJbi+uOTB6NbZ1nck/VXYrG3auUdi+3J8/VXZ7T3Wq7NZpPaPvfZOs23U8lmpWWdfnk+8qbTdMcCCUaV1r8bvI7vWg1aJXtq5S9KfIrnqndathgnX9/5dFvizc+CuRWmtvrAv//k4EywYO8ldPB8XGD9zdHdp2ymOJ1S+3WH7TaLHBUf8yYv9Ho92OBdWaWGN5jbT2CwmvZu92bCR2JV43C254bNdpuVdwsxW5W3DDuy+5e4PTPxzHvYIb3k0W+8Rx3Cy4+UmEPiByr+BmL3Kz4IZtO23hXsHNXuRmwc0vRORVkXsFNz+J3Cq4uX86r4vcK7i5LbIruNmL3Cy44d041s0Y3h/HvYIb3k0Ou5tLdg8KrG9+LLH3x5NiNwp2t9xmK3K33Ia3I2A3y21+IfK8FGP/JtBrLa7e1/v7/U2gH9tOTMxy9i8rZPt3lV2nLFuekPfj+QtS327HxVhHi9fv2T/OZ9fjd6AQ/suWa78SwUOH1yHXX4pg34pGuyPZdclqw4qU29Ox999u+m78614m+OE47r3ddKK/9jhuvg50+kCa7/R2ev3hOO6l+U76/kXdtlTBOrvbm2vvv8xvRW4393a8f2c+0dxb+2uP4+bL/E8i9AGRey/ze5G70budu3XzZX4vcvNl/hci8qrIvZf5n0RuvczfP53XRe69zN8W2b3M70XuZnl+P7vuj+Nmlmf7a7P8qB1tz20onh9HPz4QfFuRu8F3X0ReFbkZfD+I3Au+26fzusjN4Lsrsg2+fnwg+Pr7763747gZfPKB99btfqvYUr7Z5vbuxrZuf1HIBzpdtyK339Pk/dwqH+h07WJ/7XHcfU+TD3S6/iBy8z1NPtDp2vUDna57kbuPCv1Ap+sPIjcfFfqBTtf7p/O6yM1HhX6g03UvcvdRMd7/1tJPfI2P93sF9ln+5tf4tjTxboIeb0///uE4bibo4X/tcdzNaLuFD2+3VHu/pe6P42ZLtb+4pd79otiuVnj3MbEVufuYuC8ir4rcfEz8IHLvMXH7dF4XufmYuCuyfUxsRe4Gn8v7wacfCD5/O7Pux5C0KjC6jk01Sd/v3+WobGk4G/u2JKYc2723avpT68uY2B+zx2U7nDWwIdlaa8rSf6Ni2J/alpz0d1Run5Htzmi7fx2e5DLaTmW7Xtzfn+r2d85IP3J19SNXd78CXn2jrNPZ31EZr6pwFb8+0F9V6diSr3N7WQUfgF1fPqNeJaNtHVz+pYrU06NJ51fjyLB9nOmxiYDdENfdIWqh8f4QtewGMO4OUe9Fbg5R/yByb4hadtOg7nYoyXZG1s0Opa3I3e8VaW+/0v5wHPe+V6TpX3scNzuUfhKhD4jc61Dai9z8/JLtTmA3vxT2Ije/FH4hIq+K3PtS+Enk1pfC/dN5XeTel8Jtkd2Xwl7k5peC9LeLCH44jntfCtLb+7mE3u9Qkv6BHn95f13DH47jZoJ+f13D/XHczWjbCVx3W6q831L3x3Gzpcpf3FJvdijJdoDr7mNiK3L3MXFfRF4VufmY+EHk3mPi9um8LnLzMXFXZPuY2IrcDb73VzX84ThuBp++n1m3XxQ3h6hFP1D0KvqBKkDRtwcNfjiOm8+aQX/tcdx91owPDLPJ+8NbPxzHzeb+/nytH1rqzbei8YGi163I7eZu778FjE809/eHt/bHcffbd3yg6PUHkZvfvuMT0WsfKHrdi9x9qbEPFL3+IHLzpcY+UPR6/3ReF7n5UmMfKHrdi9zN8v5+drUPFL2K21+b5W9+UejxgaLXvcjN4PuFiLwqci/4fhK5FXz3T+d1kXvBd1tkF3x7kZvBp+9P1vrhOO4Fn74/WeuH0Z8at3ngZhRV9zt35YGMZSljeXEUypcxvl+O5jrXa9q6X/UfKj8MuNdLFvXlA+n7gLtux7KwHsUDn68WshUxrDhifXMcu83rb86o/YXIizNqhWt5tcdopTyvhtDdMMVjALh22W26VdkW8GEDsUG+U9kW8hLePdd503+qbPoFrFYodFruz/cZwlsN93r6HWtq/FNk09rurpKj223ab66Ssz2Su6vk3BfZrJLzg8i9VXL2IjdXydmL3FwlZ9tO6GhY7rrvWtt2y667s9qVP1AyoPyBkgHlD5QM7EVulgz8IHKvZED7B0oGtH9gtF/7212vPxzHvR4PfX9Qa38cN7sItH/g00+7vX8yH/j00/cHtX5oqfc6+FQ+UNyyFbnd3OXtrtcfjuNmc39/1tb+OG528P0kQh8QudfBtxe5G736geKWvcjdPgb9QHHLDyI3+xj0A8Ut90/ndZGbfQz6geKWvcjdLD/ez676geIWfX/W1j7L3+3gGx8oGdiL3A2+8YGSgR9Ebgbf+EDJwP3TeV3kZvCND5QM7EXuBp+9/946PlAyoPb+eyt/oGRA7QMlA2ofGIjditx+T/P3c6t9YCBW31+GcH8cd9/T7AMDsT+I3HxPsw8MxKp/YCB2L3L3UeEfGIj9QeTmo8I/MBB7/3ReF7n5qPAPDMTuRW4+Ksbx/reWf+BrfBzv9wrYB8ptxnYTrpsJerw/sPXDcdxL0IP4rz2OmxltkHygpb6/CuEPx3GzpdJf3FJvflGM9oGSgb3IzcfEL0TkVZF7j4mfRG49Ju6fzusi9x4Tt0V2j4m9yN3ga2+XDPxwHDeDj9/OrPsxpFgXO+PGXxyx/KrSdiq7EViWSgS8jkT9bhy38zIdd6MyduNZMXwwR0/XicGq3zW2u53iqhzrxOBfqTTc5abLrja/VBl4obd1c+k/VHaTtDwqwOco37rt6i9VuEZQve+PZTdSIIdg27tj2SDnt+dUV+adc2pVrOKtf0RlSba/vNfeqgzIB++OZeyqEKqvgY6Dd0GwG+CiuTfx1Dm3SP2Qjr2s0wR7n7YhL17kR66qsWp5XcU0Q+Ex9v1qoulHPUweT2t+VYW49nhqB21UZPcoGFY54jFyvuyE93d0tpt5KyN7apdXdR6pt47n8X/tQzr+GZ32+nndj6u9zv14+M3x2MvtB1tPkB26a82667JtrTZuerCMl3U6Ni17SB4v68iAjvgbOsqf0cHmjE345ftlsbPfdb94+xj+hc72sbXXQR/5Q+forx8Pf+Z4+qLTRV/Nzg3bu+9fMMb2aKJL4DqaIfSyjnXomPBndLS9oYOrbNsstlv58G7V5NhNDbtbNfnDGfnSbrxv2vG+ONZq2bLHi/+2rHWr0vH5IJuPqn3RcK9XAxF6VUWxI5+OdV/MX6kMrps0um6Wcxu7vqvbBcxjO1Byt4B52G6nz7sFzGM3nHa3+Hj4bs/E23ta7u7QaNh7e/QX77MpNtvV7SaQOxU/6mXUv+yH9TuVVqu5eXv9WBgf4f04XlR53F10px107Nrubs7Y3JIleyrXBtN/pXKgq3KNgNdVdseyvzKEMvHHm2x7NU89/rb6s+jcOu65ju32+qLHxzfqvNmel5z/RsblZRl83x1f2t8vZeSezA+7G9d8iya7nZbt3nCbrk8lkl9ooKhC1+7cPzR2w0uPF6A8m8fTf7er93b3abOMSPa1FP+Pa0K77jVWvI/zuuDp9529bTfo9pmdvRvW0nwEANrK9529bTve9Xh81rPtbJ2Qab+SMbTcx7tm28js7pJy3aXH8GmJfH+5s+0eYDJqpt2Dl4/Tx2vfd53tqwOW01x3Fz6X+fyqsh3TWG5TW8YSfqnC+L7tyxyqP1W2Z9RqW/q2dmr8HZX9va4tpB9dPuzP7/VuSCK2IJ6fbrw89dl+dSje0ex8mXj056HsumlcHYVb47DnYb2bv3Q7rH86mkge19H48jL/p4xvu/DRg7U89lnvppjH+Fk2XT2WRvd4Sv7X/+fx2z/+j3/+9//+L//2P/7xP/753/71f55/SHy6nV+L1IukSItG0KN1kBV50OOg23HSmScaFbU4j8ffNi4Kj/MLrYXHeVGbFo2i8DjvXAuPs5KXjyIqCo/zO4q5qBeFxzm6wlo0isLjzIHsSf0oCo8z+Hp4nEv1dC4Kj/O7t0tReJwvo30UWZHPNPvf/iZHUXic7VhOj3Z2PAoHPa6u9CIp0qJRdHq0MxWJJ+lRREWtiIt6kRRp0SgqDy2PUR6jPEZ5jOnxOPPRi8LjHDgaWhQe5zfsCI+zQGaEx/npZeFx7rFk4XGuUGytKDzOe2S9KDzOHkPTovA4pwdaeJyl5eZJfhRRUXicr1PORb1IisLjTIs+isLj3IfBw+N8i3l8pQAp79zjhQA4z8VP7MBwOh/3j7GDeBzFvz29Yv3pRyc80AvpCDz/LRHwdGMK5EA98XTjFv9VgAocwHA7qzEoYn9iBD+fI34U0c9nZFKEP59hSBH/F3ZguJ0TZChSQHxlUOSAC8PtvIEUWWBipIELCdiADOxAASpwAOHGcOtw63DrcOtw63DrcOtw63DrcOtwE7gJ3ARuAjeBm8BN4CZwE7gJ3BRuCjedbmfTUAZ24HQ7b6EqcAAN6IXjKIVBQLgNxr/tQLgNuA24DbgNuBncDG4GN8O5Gc7N4GZwM7gZ3AxufgAJ2IA4N4ebC1CBA2jAcmvHASRgAzKwAwWowAEstzZzSSAdQAI2INwIbgQ3ghvBjQyIc2s4t4Zza3BrDOxAASoQbg1uDW4MN4Yb40oyzo1xboxzY7jxAOJKMq5kx5XscOtw63DrcOtw67iSHefWcW4d5yZwE9w3wZUUXEnBlRS4CdwEbgI3gZviSirOTXFuinNDLmmK+6a4koorqbiSyCVtwG3AbcANuaQhlzTkkoZc0pBL2oDbwH1DLmnIJQ25pBncDG7IJQ25pCGXNOSShlzSkEsacklzuDnuG3JJQy5pyCXN4eZwQy5h5BJGLmHkEkYuYeQSRi7ho9z4GEAD1pVk5BImuBHckEsYuYSRSxi5hJFLGLmEkUu4wa0RsAEZ2IFwa3BDLmHkEkYuYeQSRi75/5V2Ljuy5Mi1/Zcan4Hbg2bG+ytCQ5D6toQGGmqh9QAEof5dEWRE7gVoqElhp1ekrzC65zok3SIz5JKQSyJEi6WokZRLQi6JEC1Fk0tCLgm5JOSSkEtCLgm5JFK01HWTS0IuCbkklmhLNLkk5JKQS0IuCbkk5JKQS0LzktC8JOSSkEtCLgnNS0LzkpBLQi4JuSTkkpBLQi4JuSRatNZ1k0tCLgm5JEa0EU0uCbkk5JKQS0IuCbkk5JLYom1dN7kk5JKQS2KLtkWTS0IuCbkk5ZKUS1IuSbkknx9aPkuxFFtxFEUz0eSSlEtSLkm5JOWSlEtSLkkTzX6uW8olKZekXJIumosml6RcknJJyiUpl6RcknJJhmgRihpJuSTlkgzRQjS5JOWSlEtSLkm5JOWSlEsyRUtdN7kk5ZKUS3KJtkSTS1IuSbkk5ZKUS1IuSbkkS7TSdZNLUi5JuSS1xkmtcVIuSbkk5ZKUS1IuSbkk5ZJs0VrXTS5JuSTlktQaJ0c0uSTlkpRLUi5JuSTlkpRLckQbXTe5JOWSlEtSa5zcosklKZekXJJyScolSy5Zcsl6fmjrCcVUXIql2DrDKIomlyy5ZMklSy5ZcsmSS5aJZq04ij8jueSSpTXOctHkkiWXLLlkySVLLllyyZJLVogWpqiRlEuWXLK0xlkhmlyy5JIllyy5ZMklSy5ZcslK0VLXTS5ZcsmSS5bWOGuJJpcsuWTJJUsuWXLJkkuWXLKWaEvXTS5ZcsmSS5bWOEsuWZqXLM1LllyytMZZJZr2S5ZcsuSSJZcszUvWxyX7HX/2gla34ij+7AWteRRN0RVDMRWXomgj2og2om3RtmhbtC3aFm2LtkXbom3R9g+tnkfRFF0xFFNxKZZiK46iaFrjlPZLSvslJZeUXFJySWleUpqXlFxScknJJSWXlFxScknJJSWXlFxSckm5aC6aXFJyScklpTVOab+k5JKSS0ouKbmk5JKSS0ouqRQtQzEVl2Ipiqb9kpJLSi4puaTkkpJLSi4puaSWaKsVNZJyScklpTVOab+k5JIq0TQvKc1LSi4pzUtK85KSS0p7r6W912qNpOYlpTVOab+ktF9S2nstzUtK85LSvKQ0LynNS0p7rzW6bqORHI2k5iWlNU5pv6S0X1Laey3NS0rzktK8pDQvKc1LSnuvtX+uWz+Poim64g+ttV/S2i9p7b225iWteUlrXtKal7TmJS2XtIViKi7FUhRN+yWt/ZLW3mvLJS2XtFzScknLJa291/ZWHEWNpFzSWuO09ktaLmm5pOWSlktaLmm5pOWS1t5rp66bXNJyScslrTVOa7+k5ZKWS1ouabmk5ZKWS1ouae299tJ1k0taLmm5pLXGae2XtFzScknLJS2XtFzScknLJa15SWte0nJJyyUtl7TmJa15ScslLZe0XNJyScslLZe0XNLae209x2m5pOWSlktaa5zWfknLJS2XtFzScknLJS2XtFzS2nttPcdpuaTlkpFLRmuc0X7JyCUjl4xcMnLJyCUjl4xcMpqXjOYlI5eMXDJyyWheMpqXjFwycsnIJSOXjFwycsnIJaO919FznJFLRi4ZuWS0xhntl4xcMnLJyCUjl4xcMnLJyCWjvdfRc5yRS0YuGblktMYZ7ZeMXDJyycglI5eMXDJyycglo73X0XOckUtGLhm5ZLTGGe2XjFwycsnIJSOXjFwycsnIJaM1zug5zsglI5eMXDJa44zWOCOXjFwycsnIJSOXjFwycslo73X0HGfkkpFLRi4Z7ZeM9ktGLhm5ZOSSkUtGLhm5ZOSS0d7r6DnOyCUjl4xcMtov2dov2XLJlku2XLLlki2XbLlkyyVbe69bz3G2XLLlki2XbK1xttY4Wy7ZcsmWS7ZcsuWSLZdsuWRr73XrOc6WS7ZcsuWSrTXO1n7Jlku2XLLlki2XbLlkyyVbLtnae916jrPlki2XbLlka42ztV+y5ZItl2y5ZMslWy7ZcsmWS7b2Xree42y5ZMslWy7ZWuNs7ZdsuWTLJVsu2XLJlku2XLLlkq39kq39ki2XbLlkyyVba5ytvdctl2y5ZMslWy7ZcsmWS7ZcsrX3uvUcZ8slWy7ZcsnWGmdr73XLJVsu2XLJlku2XLLlki2XbO29bj3H2XLJlku2XLK1xtnae91yiT2SySsbsiMHciIvZDW1PHqe8/48FvJWllZeGVyJ5ZUDOZHBNXANXAPXUK+jXgfXUe/HMacpz9V69fhCLuRGHmT1Xz1oZXvQy/agme1BN9uDdrYH/WwPGtoedLQ9aGl70NP2oKntQVfbg7a2B31tDxrbHnS2PWhte9Db9qC57UF324P2tgf9bQ8a3B50uD1ocXvQ4/agye1Bl9uzcH0X7qvCfVW4voXrW7ifC/czut2ewn1VuK8KXHS8PY37qsFtcNH19qDt7UHf29PgNrgNbqNeNL89A+6AO+AOuOiAe9AC96AH7kET3IMuuGeDq2dEr4yf342fX7TCPRvcDe4Gd4MLXxl8ZfCVwVcGX5keGJnpiZEZfGXwlcFX9oBr4MJXZuAauJoKmcFXpsmQmWZDZvCVac/XTJu+ZnoabaYpkZmD6+A6uA6ug6uJkZmj3kC9gXoDXD1NMguMc2CcA+Mc4Aa4AW6Cm+AmxjlRb6LeRL0JbuL6JsY5Mc4L47zAXeAucBe4C9yFcV6od6HehXrhKytcX7TmsjeXzbnszmV7Lvtz2aDLDl2Drwy+MviKXbrW4DauL3xl8JXBV+zVtQEXvjL4yuArg6/YscuWXfbs2oA7uL7wlcFXBl+xc9c2uPCVwVcGXxl8hf5dQwOvoYPXXNvI5nq+bQ5fOXzl8BX6eM21AWQOXzl85fCVw1fo5jW08xr6ec0xv3LMrxy+cvjK4St09ZpjfuXwlcNXDl85fIXeXkNzr6G71zzA1fMqc/jK4SuHr9Djax7gwlcOXzl85fAVOn0Nrb6GXl/zBDdxfeErh68cvkLHr/kCF75y+MrhK4ev0PdraPw1dP6aY37lmF85fOXwlcNX6P81x/zK4SuHrxy+cvgKXcCGNmBDH7A5PlTgjesLXzl85fAVuoHN8dECh68cvnL4yuEr9AQbmoINXcHmA+7g+sJXDl85fIXeYHN80MDhK4evHL5y+AodwoYWYUOPsIU2qi301MsCvgr4KuArdApbaIvJAr4K+Crgq4Cv0C9saBg2dAxbYD0YegZmAV8FfBXwFfqGLbAeDPgq4KuArwK+QvewoX3Y0D9s4eDqiZgFfBXwVcBX6CK2CHDhq4CvAr4K+Aq9xIZmYkM3sUWCm7i+8FXAVwFfoafYIsGFrwK+Cvgq4Ct0Fhtaiw29xRYL3IXrC18FfBXwFTqMLbAeDPgq4KuArwK+CvgKjcaGTmMLfAQq8BmogK8Cvgr4Cv3GFvggVMBXAV8FfBXwFbqODW3Hhr5jC3wgKgbXF74K+CrgK3QfW+BjUQFfBXwV8FXAV+hBNjQhG7qQLfDxqNBzNUv4KuGrhK/Qi2yJ/auErxK+Svgq4St0JBtakg09yZbYv0rsXyV8lfBVwlfoTLY0cOGrhK8Svkr4Cv3JhgZlQ4eypYOrZ26W8FXCVwlfoU/ZMsCFrxK+Svgq4St0KxvalQ39ypYJbuL6wlcJXyV8ha5lywQXvkr4KuGrhK/Qu2xoXjZ0L1sucBeuL3yV8FXCV+hhNjQxG7qYDW3MlvAVGpktC1zsX6GX2dDMbOhmNrQz27efeZ98uO/PSduno/n9+Xf7tDT3ff3h9n394c59/eHO/TjsIB/u+5d22aex+ZMPd5/zX1998uHuc/7jq3zu8YVcyH3yqf346pvf3Hz/Nhu7Lc7fbL99fme83Sbnb46TD/f4Kv387oTjq28u5MP1U8vx1Tcf7vt3Hdhtdv5mQz7c8xnr2+/8zYf7/i2Ldjuev7mQDzf2yYN8uOcT2rft+ZsP9/17Eew2Pn9zIB/u+cT27X3+5sM9n9m+3c+5zns4vvrmrXx8leu8Hzfkw61zzuOrb07kw/18LrqQD/f9mXy7jdDfvJWPr/Lcq7cX+psPt8/YHl998+HOqf346psPd04tx1fffLj7XLvjq08+vvrmw93n/MdX3/zmrvPp/dsYvZ5zzuOr9dzXFI438iBv5eOrbzZk1zlX4Hji+MJxcBe4a/B6cAvcArccOfS9hXoL3AK3Gq9HvbV1vMFtw3FwG/U2uI1xbnAb3Aa3wR1wB/UOuIN6B9xBvVN4DcZ5MM6Dcd6Pjm9wN7gb9W5wN7gb3A3uRr1b3NtQfV9/O6q/xx3HA8cTeSEXcuN7B8c1zre1+nPcwDVwDVwD18A1cK2RwTXU6+C67qvbZv09Dq4nXgOug+vg+uD14AbGOVBvgBuB16DeWDgObmCcA/UGuIl6E9wEN8GFrypRbxZeg3rhq4KvCr4q+KoWuAvcBS58VfBVwVcFXxV8VfBVFa4vfFXwVcFXBV9Vod4Ct8AtcOGrgq8KvqoGF76qBrfBbXDhq2pw4auCrwq+qsH9PLif4auCrwq+qgEXvqoNLnxV8FXBV7XBha9q4/pu3M/wVcFXDV81fNXwVcNXDV81fNXwVT+NPDgPuPBVm65vm+N44Di4tnAcXPiqDVz4quGrdtTrqBe+agfXwYWvGr5qH2RwA1z4qgPcADcSxzHO8FUHuIF64atOXF/4qhPcBDfBha8avmr4quGrTv171PBVw1cNXzXmVw1f9cI4w1cNX/UCd4ELXzXmVw1fdYELX3WBi/lVY37VmF815lcNXzV81fBVY37V8FVjftWYXzXmVw1fNXzVg+sLX/Xg+sJXDV81fNUDLnzVmF81fNXwVW/UC1/1xs8v5le9US981ZhfNXzV8NU8D7K48ziOB3IiL7y+cLyRBxlc0zgP5lcDXw18NfDVYH418NXAV4P51Zjuq4GvBvOrwfxqHFz4auCrga/GG8fBha8Gvhr4ajC/GsyvBvOrwfxq4KvB/Gowv5pAvZhfTaJezK8Gvhr4auCrwXpwElz4auCrga8Gvhr4ajC/GvhqML8a+GoWuPDVwFcDXw3mVwNfDeZXA18NfDUfX+2TD/fs1dzm8nX2Z253+SdfX32yITtyICfyQi7kRga3wR1wB9wBd8AdcAfcAXfAHXAH3A3uBneDu8G9vnr/5lK7feffXMiNfLnnd4BeX518m8/vOW/3+Tc7ciAn8kIu5EYeZNV729C/GVwD18A1cA1cA9fANXANXAfXwXVwHVwH1zXOty39mxt5kDHO11efDG6AG+AGuIF6A/UG6g3UG6g3UW+Cm+AmuAlugpvgJrgJboK7wF3gLnAXuAvchXFeGOeFcV4Y54VxLoxzgVvgFrgFbqHeQr2FeuGrDV9t+GrDVxu+2vDVhq82fLXhqw1fbfhqw1cbvtrw1YavNny1R97Yg3EejPNgnEfe2INxhq82fLXhqw1f7Y16N+rdqHej3o1690+9/shX/shX/shX/shX/shX/shX/shX/shX/shX/jzgGrgG7sdXcXIgJ/JCru8Y+vPx1c3gGrgOroPrqNdRr6NeR72Oeh31OrgOboAb4Aa4AW6AG+AGuAFugPvx1Rmfj69uNmSM88dXZ9w+vroZ3AQ3wU1wE/Uu1LtQ70K9C/Uu1LvAXeAucBe4C9wCt8AtcAvcArdwX1UhN/Igb41VP8jgNrgNboPbqLdRb6PeRr2Negf1DrgD7oA74A64A+6AO+AOuBv31cZ9tXFfbfz8btxXH1/dDO4Gd4MLXxl8ZfCVwVcGXxl8ZfCVwVcGXxl8ZfCVwVcGX5mBa+DCVwZfmRVyI//8u+Bmuq8MvjL4yuArg68MvjL4yuArg68MvjL4yuArg68MvjL4yuArg68MvrJAvTHI8pXBV/bx1RmHj69uBjfBha8MvjL4yuArg68MvjL4yuArg68MvjL4yuArg68MvrKFegv1liE7svxslcjgFrgFboFbqLdRL3xl8JXBVwZfGXxl8JXBVwZfGXxlg3oH9Q7qnUBGvbOQwYWvDL4y+Mo26t2od6PejXo36t2oF74y+MrgK4Ov/FG9/hiyIwey6vVnIRfO2ciDDC585fCVw1cOX7nWg+5aD7obuAYu5lduup/dUa+jXke9rvvZHfXCVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDVw5fOXzl8JXDV77075FrPeiu9aD7Qr1L/x651oPumF855leO+ZVjfuWYXzl85fCVw1cOXzl85Y1xbtxXjfuq8XPUuK8aP0fwlcNXDl85fOWYXznmV475lWN+5Zhf+WCcB+M8GOfBfTUY5/0ggwtfOXzl8JXDVw5fOXzl8JVv3c8BXwV8FfBVPPr5DfgqML8K+Crgq4CvAr4K+Crgq8B6MLAeDMyvAvOrwHowsB4M+CqwHgzMrwLzq8D8KjC/CgfXwdX+lYf2rzxcP0eh/SsP+Crgq4CvAr4K+CoC3AAXvgr4KgLcfJDBTXDhq4CvIsFNcBPcBDfBXeDCVwFfBXwV8FXAVwFfBXwV8FXAVwFfBXwVmF9F4b4qcLEejMJ9Vbiv4Kso/BzBVwFfBXwVjZ8j+Coa3Ea9jXob49yodzDOH1/tkx05kBP5cN9/schvf/s3H+75S1W3v335OnkrX1998uGev1h1+9u/+XDjnPP66pMXciEfbpyxvb765MPN8ze0rq8+2ZAPN+PkQD7c919W8tvf/s2H+/47S37727/5cN/9nH772z/5+urdb+m3v/2bHflw65z/+uqTD/f9lzv99rd/8+G+e4n99rd/8+G++4f99revOTVeX32yIx/unHqvrz75cOe8h+urT27kw51T+/XVzddXu082ZEc+3H3e5/XVJ7+59Zz3dnz1zW9u2an9+Oqbt/LxVZ2fr9vf/s1+8hnn46tvTuTDtVPX8dU3N/Lh+mVt5eOrOn9/7fa3l59ajq++OZATeSEXciMP8lauBxncArfALXAL3AK3wC1wC9wGt8FtcBvcBrfBbXAb3Aa3wR1wB9wBd8AdcAfc46uKc18dX33zIB/uccjtb/9mQ3bkQE6d5/jqm8HdjdcPsri3v/2bDdmRA1nc29/+zYXcyIMMroFr4Bq4Bq4l8kIu5EYG17ayP8iG7MjgOrgOroPr4Pogo95AvYF6A9wIZIxzYJwD4xzgBrgBboKb4CbGOVFvot5EvQlu4vomxjkxzgvjvMBd4C5wF7gL3IVxXqh3od6FegvcwvUtjHNhnAvjXOAWuAVugVvgNsa5UW+j3ka9DW7j+jbGuTHOjXFucAfcAXfAHXAH4zyod1DvoF74ag2u78Y4b4zzxjjDV2uDu8Hd4MJXC75a8FXBVwVf1SNuPYGcyAu5kBvnGWRw4auCrwq+Kviq4KuCr8rAtUYeZI1zwVfl4Dq48FXBVwVfFXxV8FXBVwVfVYAbhoxxhq8KvqoAN8CFrwq+Kviq4KuCrwq+KviqEtzE9YWvCr4q+KoS3AUufFXwVcFXBV8VfFXwVcFXtcBduL7wVcFXBV9VgVvgwlcFXxV8VfBVwVcFXxV8VQ1u4/rCVwVfFXxVDW6DC18VfFXwVcFXBV8VfFXwVWF+VZhfFXxV8FXBV4X5VWF+VfBVwVcFXxV8VfBVwVcFX/Ujbj+G7MiBnMgL5ynkRh5kcOGrhq8avmr4qg1cW8iF3MiDDK6DC181fNXwVcNXDV81fNXwVTu4ruvb8FXDVw1fdYAb4MJXDV81fNXwVcNXDV81fNUJbuL6wlcNXzV81QluggtfNXzV8FXDVw1fNXzV8FUvcBeuL3zV8FXDV13gFrjwVcNXDV81fNXwVcNXDV91g9u4vvBVw1cNX3WD2+DCVw1fNXzV8FXDVw1fNXzVA+7g+sJXDV81fNVYDzbWgw1fNXzV8FXDVw1fNXzV8FVvcLeu78BXA18NfDVYD86TyAu5kBt5kFXvwFcDX42Ba4GcyAu5kME1cOGrga8Gvhr4auCrga8GvhoH1xt5kDHO8NVgPTgBLnw18NXAVwNfDXw18NXAV5PgJq4vfDXw1cBXg/XgJLjw1cBXA18NfDXw1cBXA1/NAnfh+sJXA18NfDVYD06BC18NfDXw1cBXA18NfDXw1RS4hesLXw18NfDVYD04DS58NfDVwFcDXw18NfDVwFcz4A6uL3w18NXAV4P14MBXg/nVYH418NVgPTgbXOxfDXw18NXAV4P51Xx89d5T3R9f7ZMN2ZEPN5+TE/lw856nkA/37MPf/vZvPtz13ru+/e119t5vf/s3O/Lhvn+vgt/+9m8+3Drv4frqkxv5cN+/V8Fvf/snX1+1nWzIjny4fd7n9dUnH26f93Z99cmHO6f266tP3srXV2dP/va3f/Phzhnn66t93sP11Scv5MPd5/1cX33y4e57zq18ffXJh/v+nQx++9u/+c3t54zt8dU3L+Q6+bzP46tvfnP77OHf/vZPPr7qs29/+9u/+c1tP7UcX33z4Z7nRLe//ZsL+XDjnn+QDzfOOBxfffPh3vv8+OqbAzmRF3IhN/Igb+V+kMFtcBvcBrfBbXAb3Aa3wR1wB9wBd8AdcAfcAXfAHXAH3A3uBneDu8Hd4G5wN7gb3A3u/uHG7W//ZkN25EBO5IVcyI08yOAauAaugWvgGrgGroFr4Bq4Bq6D65e7T3bkQE7khVzIjTzIWzke5MPN8x6Or775cN/PYeP2t3/zwmsKufGaQd56zfHVN19unQzu9dUng3t99cngXl99MrjXVzcvcBfqvb6672GBe331yeBeX30yuNdXnwzu9dUng1uo9/rqvocCtzDOBW5hnAvcwjg3uNdXnwxuo97rq/seGtzGODe4jXFucAfjPOBeX30yuIN6r6/uexhwB+M84A7GeYO7Mc4b3I37eYO7Ue/11X0PG9yNcd7i3v72bxb39rd/c+A1ibzwmkLun/dw+9u/xzXOt7/9cx4zZHAtkMG1hQyuNfLoPVxf3Xx99f6dWnH727/ZkQM5kRdyIR/uOtzrq0/eytdXn2zIjhzIibyQCxnc66v37/KK29/+yddXn3y4dd7z9VWdMby++uREXsiFfLh1xvP6qubkrXx99cmG7MiBnMgL+XDffSlx+9u/+XD71H591ef9XF99siE7ciAn8kIu5EYe5MN998DE7W//ZkN25EBO5IVcyI08yOAOuAPugDvgDrgD7oA74A64A+4Gd4O7wd3gbnA3uBvcDe4Gd4t7+9u/2ZAdOZATeSEXciMPMrgGroFr4Bq4Bq6Ba+BeX806+XDfa6W4/e2vHb93vr76ZEN25EBO5IVcyI08yOAGuAFugBvgBrgBboAb4Aa4AW6Cm+AmuAnu8dVr9/LkhVzIjTzIW/n46psN2ZEDGdwF7gJ3gbvAXeAWuAVugVvgFrgFboFb4Ba4BW6D2+A2uA1ug9vgNrgNboPb4A64A+6AO+AOuAPugDvgDrgD7gZ3g7vB3eBucDe4G9wN7gZ3i3v727/ZkB05kBN5IRdyIw8yuAaugWvgGrgGroFr4Bq4Bq6B6+A6uA6ug+vgOrgOroPr4Dq4AW6AG+AGuAFugBvgBrgBboCb4Ca4CW6CC18FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXAV8FfBXwVcBXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXCV8lfJXwVcJXC75a8NWCrxZ8teCrBV8t+GrBVwu+WvDVgq8WfLXgqwVfLfhqwVcLvlrw1YKvFny14KsFXy34asFXC75a8NWCrxZ8teCrBV8t+GrBV+vjq33y4ZqdfLjvZ2px+9u/+XD9fm8jD/Lhvj/bFbe/fd6/ez9uf/s3H248v//67T//4W9//od//Muf/u23//ffry//6T/+5Y///ue//svny3//r3/9/p9//Nuf//KXP//z3//r3/76xz/9///425/+/i9//eP7//32fP7zd7NeWzuzdv/h128v2t+9/zDu+vX+M7jxOhLvV7Tnr9ej/Xy/4v0t+X56/HKFvQ+8v+f1fNl/vf6Tf/j9nOS/7+usfrm9D/kX9v5TAy95fk78/iMHr392fk77vP6n/Zy0Xuese8r4OeXu11vz97H8OfZ6d77fh5YO9a84ryodWr/ieR9qvb/9y8/5533o/Y5eIx3z837yV57z7v/9HfYzfq99gF+v9fCnpNcWXv+cwN8D4D8FvXYnXl/2+Xb7+fbXg+zX0uvz7a/d1Xp+vv31zN3vl+fby15fxvn2nwF97ab+eu0qfr79tZf8yzSgr0v4+nK+J3jtzv567cSeE8T/9QSpAl5F3rvnXKB5XaD4ec+vL18LwvMdujrWr3E4x+o78PG+E77nWPZr1fn/ulb+Lv4Pv//++x9+/x8=",
      "brillig_names": [
        "discover_new_messages",
        "random",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "submit_score",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "tally",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "get_public_keys_and_partial_address",
        "decompose_hint",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "user_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAASyUAAABvLgIAAYBJKAIAAgSASScCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAABAonAgMAAC0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYtDgMGACIGAgYtDgMGACIGAgYtDgMGKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFAAgBBwEnAwYEAQAiBgIHLQoHCC0OAwgAIggCCC0OAwgAIggCCC0OAwgAIggCCC0OBQgtCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4GBC0IAQYAAAECAS4MgEUABi0IAQcAAAECAS4MgEQABycCCAATJwIJBAotCAAKLQoFCy0KBAwtCgYNLQoHDi0KCA8ACAAJACUAAAQzLQIAACcCCAQJLQgACS0KBQotCgQLLQoGDC0KBw0tCgEOAAgACAAlAAAEMy0CAAAtCwcBCyIAAYBEAAgkAgAIAAABqycCCQQAPAYJAScCAQQILQgACC0KBQktCgQKLQoGCy0KBwwACAABACUAAAVcLQIAAC0LBQEtCwQILQsGCS0OAQUtDggELQ4JBi4MgEYABwEiAAiARwAELQsEAQoqAQMECyIABIBEAAUkAgAFAAACFiUAAAZvHgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4DBwAiBwIHLQ4DBwAiBwIHLQ4DBy0IAQMAAAECAS0OBQMuCIBFAAIjAAACdA0iAAKAQwAFJAIABQAAA7sjAAACiS0LAwEBIgABgEcAAy0LAwInAgMEAgAqAQMGLQsGBQEiAAGAQwAHLQsHBi0IAQEnAgcEBAAIAQcBJwMBBAEAIgECBy0KBwgtDgIIACIIAggtDgUIACIIAggtDgYILQsBBQAiBQIFLQ4FAScCBgQHLQgABy0KAQguCIBHAAkACAAGACUAAAaBLQIAAC0KCAUtCwEGACIGAgYtDgYBJwIHBAgtCAAILQoBCS0KAwoACAAHACUAAAaBLQIAAC0KCQYnAgMEBy0IAActCgUIAAgAAwAlAAAHAS0CAAAtCggBJwIFBActCAAHLQoGCAAIAAUAJQAABwEtAgAALQoIAxwKAgYEHAoGBQAcCgUCBAwqBAIFFgoFAhwKBQQEHAoCBQQEKgQBAgQqBQMBACoCAQMtCgMBJhwKAgUAACoBBQYvCgAGAAUtCwMGLgIABoADKACABAQABCUAAAcmLgiABQAHACIHAggAKggCCS0OBQktDgcDASIAAoBHAAUtCgUCIwAAAnQoAIAEBHgADQAAAIAEgAMkAIADAAAEMioBAAEF96Hzr6Wt1Mo8BAIBJiUAAAQKLQsEBgsiAAaARAAHJAIABwAABFUnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAE6CMAAARuLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAABJMlAAAHtC4CAAeAAygAgAQEAAQlAAAHJi4IgAUACgAiCgILACoLBgwtDgUMASIABoBHAAUOKgYFByQCAAcAAATTJQAAB8YtDgoBLQ4IAi0OBQMtDgkEIwAABVsnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAFXC0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAAByYuCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARwADLQ4IBCMAAAVbJiUAAAQKLgiARQAFIwAABWwNIgAFgEMABiQCAAYAAAXcIwAABYEtCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAABfIjAAAGXi0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAAByYuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAGXgEiAAWARwAGLQoGBSMAAAVsKgEAAQUC3G4ngHYSnTwEAgEmJQAABAoBIgACgEcAAw4qAgMEJAIABAAABqAlAAAHxg0ogEMAAwAECyIABIBEAAMkAgADAAAGvSUAAAfYDSIAAoBDAAMkAgADAAAG0iUAAAe0ACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYlAAAECgEiAAGARwADLQsDAhwKAgMEHAoDAQAcCgECBC0KAgEmLgGAA4AGCwCABgACgAckAIAHAAAHQSMAAAdMLgCAA4AFIwAAB7MuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAHny4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAHbigBgAUEAAEDAIAGAAKABiMAAAezJioBAAEFxWvEWg4QAAI8BAIBJioBAAEFRafKcRlB5BU8BAIBJioBAAEF9C7lhLv0IdE8BAIBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "user_score"
      ]
    },
    {
      "name": "winner",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAo4tCAEBAAABAgEnAgIAAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFHAoFBgQcCgYEABwKBAUEDCoFAwQkAgAEAAAAqyMAAAI2HgIABAUcCgQGBBwKBgUAHAoFBAQtCAEFJwIGBAQACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBy0IAQIAAAECAS0OBQInAgUEACcCBgAULQoFAyMAAAERDSIAA4BDAAUkAgAFAAACPyMAAAEmLQsCAwEiAAOARAAFLQsFAicCBQQCACoDBQctCwcGASIAA4BDAAgtCwgHLQgBAycCCAQEAAgBCAEnAwMEAQAiAwIILQoICS0OAgkAIgkCCS0OBgkAIgkCCS0OBwktCwMGACIGAgYtDgYDJwIHBAgtCAAILQoDCS4IgEQACgAIAAcAJQAAArctAgAALQoJBi0LAwcAIgcCBy0OBwMnAggECS0IAAktCgMKLQoFCwAIAAgAJQAAArctAgAALQoKBwEiAAaARAAFLQsFAwEiAAeARAAGLQsGBRwKAgcEHAoHBgAcCgYCBAwqBAIGFgoGAhwKBgQAHAoCBgAEKgQDAgQqBgUDACoCAwQtDgQBIwAAAjYtCwECLQoCASYcCgMFAAAqBgUHLwoABwAFLQsCBy4CAAeAAygAgAQEAAQlAAADPi4IgAUACAAiCAIJACoJAwotDgUKLQ4IAgEiAAOARAAFLQoFAyMAAAERKACABAR4AA0AAACABIADJACAAwAAArYqAQABBfeh86+lrdTKPAQCASYlAAACjgEiAAKARAADDioCAwQkAgAEAAAC1iUAAAPMDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAAvUlAAAD3g0iAAKAQwADJwIEAQEkAgADAAADDyUAAAPwACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAANZIwAAA2QuAIADgAUjAAADyy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAO3LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAOGKAGABQQAAQMAgAYAAoAGIwAAA8smKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZjRbuM4DEX/xc95EClKovIrg6JI23QQIEiLTLLAosi/L2mLcjILCakz81IdM9a1KF/Srr+Gt+3L+efz7vD+8WtY//gaXo67/X7383n/8bo57T4OEv0anP7hPKxhNWQ/DTwO4HwZ07AmGQGHddAxTSOWY5Rj0BM9GqiCFyBvYJGgEVVLIMAKUSALMBhYJEsEdVYOE6BzBhYBi0CN5ALoDbiArnCCVIDAwKYHE0w6XZaKmQSCguh4txq8iwX06hOEAmgRpAJ60Ql0luyPJ2cQCgSLBItEi0Qy4AK6sAlSAUYDvYQs3mdnEAxkW7ykQ44MuIDe2Qksols3gUW8nTNmoTBmMUIw0EvIRlEgAy4Q0SAWUANMYBF2BjpdvEEZDeQckgSDLn4CUSYUAG9gEV08kQIX8EUn6H0fgSxCFgkWCepnWUbQpY6QJEFS0BVSVNCInqwWpaQQJpNEBwZcQFc4QS6AZGARb+eMzhRIanXKClxgzFQBwUBWGMRayZNBLkAW0bwm0LqVrUsxFEjOgAuwXCKgAhfIFsk6XYzEmuAEsQBYBCyCFkG9lr9cVoO1nefTcbvVrnPVh6Q7fW6O28NpWB/O+/1q+GezP48n/frcHMbxtDnKr5LH9vAmowi+7/Zbpctqnu3aUyNrMY+zIxNVgfANhTQr5KYCdhS8VumkIMVfFeKtgm8rcGJTYHbYUrgzi+z8kn3IHqsCcUshthV8VIuPCtLWZgWI/kYitSXksZOLBGDOs0S+leC2hLjd/JQ4QGsvc0dBCtgUYuSWAnQ2E4Cyt0QgYGyJdBPBOZHYVADsLSOHup0w74U8tO63BcRqi+AWGataU9pfbCloT247C3x1lr921m0eEB+uUkgPl+ndmVBqZ9LVCKlqpNzUwM5NoQjmcYpXffN/GvBwpWHHoIlyLbXg3CIJqa4qgWmRRASoBQ9tCXi4WLHXPjGbhFiVmsWKvf7pUm07jmdr+PCbRqfvcHUGe2ordBpoBFcrLbYVunlEqHkk19boWrzuBcnrVtPiHv+uhjz+7MEKMVzdEwjf0GArefkfi5dppFCfrYmprdHxKDqwdaCjuQNixFuN3r2NtWBla0Jbo5tLtmcKSOW1c8mP50LuL+cyt1Fgis1c7n4k5Nj0KXVeQiG7mkumq5cF8N/opHUd8uq0sBkTPixx1wscpT/wAtczh7wj1Bt7XbTBL5LAvEgih/m2xrhQAmeJtEyC/Gyu3xJ5ksPN6+548xHromLH3eZlvy2H7+fD69Wvp38/7Rf7CPZ5/Hjdvp2PW1Wav4TJnx9Snispryf99KWHUpHgkx6CHjKvxP9PF13Mfw==",
      "brillig_names": [
        "winner"
      ]
    },
    {
      "name": "winner_score",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEUlAAAARSUAAABULgIAAYBFKAIAAgSARScCAwQBOw4AAwACKACAQwQAAygAgEQEAAEmJQAAAuQtCAEBAAABAgEnAgIEAC0OAgEeAgADBRwKAwUEHAoFBAAcCgQDBCcCBAADLwoABAAFLQgBBCcCBgQCAAgBBgEnAwQEAQAiBAIGLQoGBy0OBQcnAgYEBy0IAActCgQIAAgABgAlAAADDS0CAAAtCggFDCoFAwQkAgAEAAAA2yMAAAKMHgIABAUcCgQGBBwKBgUAHAoFBAQnAgUAAC0IAQYnAgcEBAAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIIAggtDgUIACIIAggtDgUILQgBBQAAAQIBLQ4GBScCBgAYLQoCAyMAAAFBDSIAA4BDAAIkAgACAAAClSMAAAFWLQsFAgEiAAKARAAFLQsFAycCBQQCACoCBQctCwcGASIAAoBDAAgtCwgHLQgBAicCCAQEAAgBCAEnAwIEAQAiAgIILQoICS0OAwkAIgkCCS0OBgkAIgkCCS0OBwktCwIGACIGAgYtDgYCJwIHBAgtCAAILQoCCS4IgEQACgAIAAcAJQAAAzItAgAALQoJBi0LAgcAIgcCBy0OBwInAggECS0IAAktCgIKLQoFCwAIAAgAJQAAAzItAgAALQoKBycCBQQILQgACC0KBgkACAAFACUAAAMNLQIAAC0KCQInAgYECC0IAAgtCgcJAAgABgAlAAADDS0CAAAtCgkFHAoDBwQcCgcGABwKBgMEDCoEAwYWCgYDHAoGBAQcCgMGBAQqBAIDBCoGBQIAKgMCBC0OBAEjAAACjC0LAQItCgIBJhwKAwIAACoGAgcvCgAHAAItCwUHLgIAB4ADKACABAQABCUAAAO5LgiABQAIACIIAgkAKgkDCi0OAgotDggFASIAA4BEAAItCgIDIwAAAUEoAIAEBHgADQAAAIAEgAMkAIADAAADDCoBAAEF96Hzr6Wt1Mo8BAIBJiUAAALkASIAAYBEAAMtCwMCHAoCAwQcCgMBABwKAQIELQoCASYlAAAC5AEiAAKARAADDioCAwQkAgAEAAADUSUAAARHDSiAQwADAAQnAgMBAAoqBAMFJAIABQAAA3AlAAAEWQ0iAAKAQwADJwIEAQEkAgADAAADiiUAAARrACIBAgQAKgQCBS0LBQMtCAEBJwICBAIACAECAScDAQQBACIBAgItCgIELQ4DBCYuAYADgAYLAIAGAAKAByQAgAcAAAPUIwAAA98uAIADgAUjAAAERi4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAQyLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAQBKAGABQQAAQMAgAYAAoAGIwAABEYmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKgEAAQXFa8RaDhAAAjwEAgEm",
      "debug_symbols": "tZhRbtswDIbv4uc8iKJEUblKURRpmw4BgrTIkgFDkbuPtEQ5GSAjdbeX6jNj/SZFilb9Obxun88/nnaHt/efw/rhc3g+7vb73Y+n/fvL5rR7P4j1c3D6h/OwhtWQsQw8DuCwjmlYBxnBD+uoYyqjr9derkFvRG+gCl4geINUIZolmoXMQlQhiVOACtEgV2A04ArZLDkV8A4ExGEPOosFfBDICrkCmgXF4nVWCAZcIaKBWcgsZJbkDagCg0GskJ2BPSLX6eiqIHqdJT6jrpiPCiKITiAGA66gbhQwi7oxAjsDnQUKXEEXqkC1BIcGZtEUF6AK6liBWAGdgT4CFbhCQAPJBUo4QdNdgCqQMzBLAgOzsN0zRjECVxijGEEfIQsVnTegCuAMgkGu4M3iuYIWLZJCqhDAIFaIzqBZcoUxF0mBK4y5GIEqaEkUMIuWRAH1hxVyAXLBQCxBUkkaRQEuDyWPBmZBs6BZNBcgAdK44xRI3AigIG4E2WikKx+Cgm5xSRyN1as3c6owFu0IuUBysYKuc4FmsXvUwxE05CjOJ9UpIB5GcYO1/AqYRWcFmcUIBlRBt2cBXRYJkLWBjKANpIBZtG+MoIUUkgJX0PpRyNolCugjZMEzgIFZvE7PCsEgV0CzoFmCWbSBhHy5rAbrtE+n43arjfaq9UpD/tgct4fTsD6c9/vV8GuzP483/fzYHMbxtDnKr7Jm28OrjCL4tttvlS6rabbrT03gbbYgNIH4BQVNTFVIXQXfV5DSNAXCEJsC3SpgX4ETm4Ik1PcU7o2C3ZJ18C6bgvexp0B9BSTdD6OC9G1uCkB4I5H6EvKmNSfA5zxJ5FsJnomDsVUER+itZZ5RIN9Wgoh7CjCzmADSxi0QORHQIjegpZQg9RRml2LaHEy0qKxaGFIUaVFZxdQUcrestH336wqw1RVe1xXdatC39yikb2/SuyMJqR/JrEZbUKSUuxp+JimBwCo8UAh9Dfj2PvMzjTOF3DZadG6RhOytJuHTIon79tn8Wty10fxc85RDtKUVYUoJ4l8pmeueLrWm43gqDYx/acz0DG6VwRj6CjN9i8C1nUZ9hdk4CFocyfU1Zku8rUVIrt800P9fDXn5eYuF4lVOIH5Bg23LywmFl2mk2N6sicNCjRxMQyp+mcbUNoADdTXuboGZ+nmZqVKQU7H5kQNc+YFf6BzTu41oYfMJ/tsSdx1XAv6D48rckUfeiS2x10UacZGEz4skcpzSSrRQwk8SaZlEwKm4lgUibrSTsOu/D+6VALiVeJTLzcvuePOt7KJix93meb+tl2/nw8vVr6ffH/aLfWv7OL6/bF/Px60qTR/c5M8DZL/ygI/6hU0vI64gsl7K/6EPXg5b8gHr8aLO/AE=",
      "brillig_names": [
        "winner_score"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "CaptureNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "capture_block",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000003"
            },
            {
              "kind": "string",
              "value": "TallyNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "tally",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CTF"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "start",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "end",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "claim",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "spend_limit",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposit_size",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000b"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pot",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000f"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deposits",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000010"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenger",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000011"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "challenge_block",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000012"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "final_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000013"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000014"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "winner_score",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000018"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "capture_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tally_note",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000001d"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "challenger",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "defender",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "block",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::ChallengeEvent"
        },
        {
          "fields": [
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "tally",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::TallyEvent"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::_submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::_submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::challenge_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::challenge_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::has_flag_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::has_flag_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "start",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "claim",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "spend_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "challenge_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "deposit_size",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::initialize_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::initialize_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "want_flag",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::join_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::join_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::nothing_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::nothing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "challenger",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::respond_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::respond_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::slash_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::slash_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::submit_score_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::submit_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::tally_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::tally_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "CTF::user_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::user_score_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "CTF::winner_score_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "CTF::winner_score_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "101": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "102": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "104": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::fetch_tagged_logs},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "105": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "106": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "107": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "114": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n"
    },
    "115": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "122": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "125": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "128": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "130": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = packed_retrieved_note[2] as bool;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, nonce),\n    }\n}\n"
    },
    "131": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "136": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "137": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "138": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "143": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "144": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "145": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "146": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "147": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    // The log fields length is PUBLIC_LOG_SIZE_IN_FIELDS. + 1 because the contract address is prepended to the content.\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_SIZE_IN_FIELDS + 1>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "149": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "150": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "151": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "153": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "155": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<let N: u32>(self, new_note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> NoteEmission<Note>\n    where\n        Note: Packable<N>,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "163": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    // docs:start:public_immutable_struct_write\n    pub fn initialize<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN> + Eq,\n    {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "164": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "166": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "178": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "182": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "184": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "185": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "187": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "189": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "193": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "200": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "217": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "262": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "277": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "290": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "311": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "313": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "315": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "318": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "332": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        let len = fields[0] as u32;\n        let mut index = 1;\n\n        for _ in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[index];\n                index += 1;\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let len = self.len();\n        fields[0] = len as Field;\n\n        let mut index: u32 = 1;\n\n        for i in 0..len {\n            let item = self.get_unchecked(i);\n            let serialized_item = item.serialize();\n\n            for j in 0..O {\n                fields[index] = serialized_item[j];\n                index += 1;\n            }\n        }\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "336": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "337": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "354": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "356": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "366": {
      "path": "/Users/karan.kurbur/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "402": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        },\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/Users/karan.kurbur/Desktop/zk-ctf/contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract CTF {\n    use aztec::{\n        macros::{functions::{private, public, view}, storage::{storage}},\n        messages::logs::note::encode_and_encrypt_note};\n\n    use dep::aztec:: macros::{\n        functions::{internal}, \n    };\n    use dep::aztec::prelude::{AztecAddress, Map, SharedMutable, PublicImmutable, PublicMutable, PrivateMutable};\n    use aztec::{\n        macros::notes::note,\n        protocol_types::{traits::{Deserialize, Serialize}},\n    };\n    use aztec::protocol_types::traits::Packable;\n    use token::Token;\n    use aztec::{\n        macros::{events::event}\n    };\n\n    use aztec::oracle::random::{random};   // returns a Field\n\n    #[storage]\n    struct Storage<Context> {\n        start: PublicImmutable<u32, Context>,\n        end: PublicImmutable<u32, Context>,\n        claim: PublicImmutable<u32, Context>,\n        spend_limit: PublicImmutable<u128, Context>,\n        challenge_fee: PublicImmutable<u128, Context>,\n        deposit_size: PublicImmutable<u128, Context>,\n        token: PublicImmutable<AztecAddress, Context>,\n\n        pot: PublicMutable<u128, Context>,\n        deposits: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        challenger: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        challenge_block: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        \n        final_score: Map<AztecAddress, SharedMutable<u32, 1, Context>, Context>,\n        winner: SharedMutable<AztecAddress, 1, Context>,\n        winner_score: SharedMutable<u32, 1, Context>,\n        \n        capture_note: Map<AztecAddress, PrivateMutable<CaptureNote, Context>, Context>,\n        tally_note: Map<AztecAddress, PrivateMutable<TallyNote, Context>, Context>,\n    }\n\n    #[derive(Eq, Serialize, Deserialize, Packable)]\n    struct Challenge {\n        challenger: AztecAddress,\n        block: u32,\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct CaptureNote {\n        owner: AztecAddress,\n        // 0 indicates the player does not have the flag\n        capture_block: u32,\n        randomness: Field\n    }\n\n    impl CaptureNote {\n        pub fn new(owner: AztecAddress, capture_block: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n            CaptureNote { owner, capture_block, randomness }\n        }\n    }\n\n    #[note]\n    #[derive(Eq, Serialize, Deserialize)]\n    pub struct TallyNote {\n        owner: AztecAddress,\n        tally: u32,\n        randomness: Field\n    }\n\n    impl TallyNote {\n        pub fn new(owner: AztecAddress, tally: u32) -> Self {\n            // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n            // so a malicious sender could use non-random values to make the note less private. But they already know\n            // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n            // information. We can therefore assume that the sender will cooperate in the random value generation.\n            let randomness: Field = unsafe { random() };\n\n            TallyNote { owner, tally , randomness}\n        }\n    }\n\n    // Define an event structure\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct ChallengeEvent {\n        challenger: AztecAddress,\n        defender: AztecAddress,\n        block: Field\n    }\n\n    #[event]\n    #[derive(Eq, Serialize, Deserialize)]\n    struct TallyEvent {\n        address: AztecAddress,\n        tally: u32,\n    }\n\n    #[public]\n    fn initialize(\n        start: u32, \n        end: u32,\n        claim: u32,\n        spend_limit: u128,\n        challenge_fee: u128,\n        deposit_size: u128,\n        token: AztecAddress,\n    ) {\n        storage.start.initialize(start);\n        storage.end.initialize(end);\n        storage.claim.initialize(claim);\n        storage.spend_limit.initialize(spend_limit);\n        storage.challenge_fee.initialize(challenge_fee);\n        storage.deposit_size.initialize(deposit_size);\n        storage.token.initialize(token);\n    }\n\n    #[private]\n    fn join(want_flag: bool) {\n        // Token::at(storage.token.read())\n        //     .transfer_to_public(\n        //         context.msg_sender(),\n        //         context.this_address(),\n        //         storage.deposit_size.read(),\n        //         0\n        //     )\n        //     .call(&mut context);  \n\n        let mut capture_block = if want_flag {\n            storage.start.read()\n        } else {\n            0\n        };\n\n        let capture_note = CaptureNote::new(context.msg_sender(), capture_block);\n        let tally_note = TallyNote::new(context.msg_sender(), 0);\n        storage.capture_note.at(context.msg_sender()).initialize_or_replace(capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n        storage.tally_note.at(context.msg_sender()).initialize_or_replace(tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        CTF::at(context.this_address())\n            ._join(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _join(sender: AztecAddress) {\n        // assert(context.block_number() as u32 < storage.start.read(), \"Game has already started\");\n        storage.deposits.at(sender).write(storage.deposit_size.read());\n    }\n\n    #[public]\n    fn claim() {\n        assert(context.block_number() as u32 > storage.claim.read(), \"Claim period has not started yet\");\n        let mut refund = storage.deposits.at(context.msg_sender()).read();\n        if context.msg_sender() == storage.winner.get_current_value() {\n            refund += storage.pot.read();\n        }\n        // Token::at(storage.token.read())\n        //     .transfer_in_public(\n        //         context.this_address(),\n        //         context.msg_sender(),\n        //         refund,\n        //         0\n        //     )\n        //     .call(&mut context);\n    }\n\n    #[private]\n    fn has_flag() -> bool {\n        let note = storage.capture_note.at(context.msg_sender()).get_note();\n        note.note.capture_block != 0\n    }\n\n    #[public]\n    fn winner() -> AztecAddress {\n        let mut winner = AztecAddress::zero();\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner = storage.winner.get_current_value();\n        }\n\n        winner \n    }\n\n    #[public]\n    fn winner_score() -> u32 {\n        let mut winner_score = 0;\n        let current_block = context.block_number() as u32;\n        if current_block > storage.end.read() {\n            winner_score = storage.winner_score.get_current_value();\n        }\n\n        winner_score \n    }\n\n    #[public]\n    fn user_score(address: AztecAddress) -> u32 {\n        let score = storage.final_score.at(address).get_current_value();\n        score\n    }\n\n    #[private]\n    fn submit_score() {\n        let capture_note = storage.capture_note.at(context.msg_sender()).get_note();\n        let mut score  = storage.tally_note.at(context.msg_sender()).get_note().note.tally;\n        if capture_note.note.capture_block != 0 {\n            score += storage.end.read() - capture_note.note.capture_block;\n        }\n        CTF::at(context.this_address())\n            ._submit_score(context.msg_sender(), score)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _submit_score(sender: AztecAddress, score: u32) {\n        assert(context.block_number() as u32 > storage.end.read(), \"Game is not over yet\");\n\n        storage.final_score.at(sender).schedule_value_change(score);\n        let (winner_score, _) = storage.winner_score.get_scheduled_value();\n        if(winner_score < score) {\n            storage.winner_score.schedule_value_change(score);\n            storage.winner.schedule_value_change(sender);\n        }\n    }\n\n    #[private]\n    fn tally() -> u32 {\n        let note = storage.tally_note.at(context.msg_sender()).get_note();\n        note.note.tally\n    }\n\n    #[public]\n    fn challenge(address: AztecAddress) {\n        assert(context.block_number() as u32 < storage.end.read(), \"Game has ended\");\n        assert(context.block_number() as u32 > storage.start.read(), \"Game has not started\");\n\n        let challenge_fee = storage.challenge_fee.read();\n        // Token::at(storage.token.read())\n        //     .transfer_in_public(\n        //         context.this_address(),\n        //         context.msg_sender(),\n        //         challenge_fee,\n        //         0\n        //     )\n        //     .call(&mut context);\n        storage.pot.write(storage.pot.read() + challenge_fee);\n\n        // Ensure the game is initialized\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger == AztecAddress::zero(), \"Challenge already exists for this address\");\n\n        let challenger = context.msg_sender();\n\n        context.emit_public_log(\n            ChallengeEvent { challenger: challenger, defender: address, block: context.block_number() }        );\n\n        storage.challenger.at(address).write(context.msg_sender());\n        storage.challenge_block.at(address).schedule_value_change(context.block_number() as u32);\n    }\n\n    #[private]\n    fn slash(address: AztecAddress) {\n        // Set their tally back to 0.\n        let slot = storage.tally_note.at(address);\n        let note = TallyNote::new(address, 0);\n        slot.replace(note).emit(encode_and_encrypt_note(\n            &mut context,\n            address,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._slash(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn _slash(address: AztecAddress) {\n        let challenger = storage.challenger.at(address).read();\n    \n        // Abort if someone has already written to this key\n        assert(challenger != AztecAddress::zero() , \"Challenge is no longer open\");\n\n        storage.deposits.at(address).write(0);\n        storage.pot.write(storage.pot.read() + storage.deposit_size.read());\n    }\n\n    #[private]\n    fn respond(challenger: AztecAddress) {\n        let responder_slot = storage.capture_note.at(context.msg_sender());\n        let capture_note = responder_slot.get_note().note;\n        let challenge_block = storage.challenge_block.at(context.msg_sender()).get_current_value();\n\n        let tally_slot = storage.tally_note.at(context.msg_sender());\n        let tally_note = tally_slot.get_note().note;\n\n        // New values assuming the reponder does not have the flag \n        let mut new_tally_note = TallyNote::new(context.msg_sender(), tally_note.tally);\n        let new_responder_note = CaptureNote::new(context.msg_sender(), 0);\n        let mut challenger_capture_note = CaptureNote::new(challenger, 0);\n\n        // The responder has the flag\n        // Update the values accordingly\n        if capture_note.capture_block != 0 {\n            new_tally_note.tally = new_tally_note.tally + challenge_block - capture_note.capture_block;\n            challenger_capture_note.capture_block = challenge_block;\n        }\n\n        // Emit the tally note\n        tally_slot.initialize_or_replace(new_tally_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Relinquish the flag\n        responder_slot.initialize_or_replace(new_responder_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // emit the note to the challenger\n        let challenger_slot = storage.capture_note.at(challenger);\n        challenger_slot.initialize_or_replace(challenger_capture_note).emit(encode_and_encrypt_note(\n            &mut context,\n            challenger,\n            context.msg_sender(),\n        ));\n\n        // Publically ack the challenge\n        CTF::at(context.this_address())\n            ._respond(context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _respond(sender: AztecAddress) {\n        storage.challenger.at(sender).write(AztecAddress::zero());\n        storage.challenge_block.at(sender).schedule_value_change(0);\n    }\n\n    #[public]\n    fn nothing() {\n    }\n}\n"
    },
    "51": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "52": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let N: u32, T> UtilityCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n}\n\nimpl<let N: u32> UtilityVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: () }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "59": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "62": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "66": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "78": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "81": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "82": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "83": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "87": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n"
    },
    "88": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "95": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "98": {
      "path": "/Users/karan.kurbur/nargo/github.com/AztecProtocol/aztec-packages/v0.87.9/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    }
  }
}
